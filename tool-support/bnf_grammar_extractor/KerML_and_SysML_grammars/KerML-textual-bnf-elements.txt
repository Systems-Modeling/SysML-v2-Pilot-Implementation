Heading(clause_id='', lines=['Part 1 - Kernel Modeling Language (KerML)'])
Heading(clause_id='8.2', lines=['Clause 8.2 Concrete Syntax'])
Heading(clause_id='8.2.1', lines=['Clause 8.2.1 Concrete Syntax Overview'])
Heading(clause_id='8.2.2', lines=['Clause 8.2.2 Lexical Structure'])
Heading(clause_id='8.2.2.1', lines=['Clause 8.2.2.1 Line Terminators and White Space'])
Production(clause_id='8.2.2.1', lines=['LINE_TERMINATOR =', '    implementation defined character sequence'], name='LINE_TERMINATOR', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.1', lines=['LINE_TEXT =', '    character sequence excluding LINE_TERMINATORs'], name='LINE_TEXT', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.1', lines=['WHITE_SPACE =', '    space | tab | form_feed | LINE_TERMINATOR'], name='WHITE_SPACE', abstract_syntax_type='', is_partial=False)
NoteList(clause_id='8.2.2.1', lines=['  1. Notation text is divided up into lines separated by line terminators. A line terminator may be a single character (such as a line feed) or a sequence of characters (such as a carriage return/line feed combination). This specification does not require any specific encoding for a line terminator, but any encoding used must be consistent throughout any specific input text.', '  2. Any characters in text line that are not a part of the line terminator are referred to as line text.', '  3. A white space character is a space, tab, form feed or line terminator. Any contiguous sequence of white space characters can be used to separate tokens that would otherwise be considered to be part of a single token. It is otherwise ignored, with the single exception that a line terminator is used to mark the end of a single-line note (see 8.2.2.2 ).'], html_snippets=[<ol> <li> Notation text is divided up into lines separated by <em>line terminators</em>. A line terminator may be a single character (such as a line feed) or a sequence of characters (such as a carriage return/line feed combination). This specification does not require any specific encoding for a line terminator, but any encoding used must be consistent throughout any specific input text. </li> <li> Any characters in text line that are not a part of the line terminator are referred to as <em>line text</em>. </li> <li> A <em>white space</em> character is a space, tab, form feed or line terminator. Any contiguous sequence of white space characters can be used to separate tokens that would otherwise be considered to be part of a single token. It is otherwise ignored, with the single exception that a line terminator is used to mark the end of a single-line note (see 8.2.2.2). </li>
</ol>])
Heading(clause_id='8.2.2.2', lines=['Clause 8.2.2.2 Notes and Comments'])
Production(clause_id='8.2.2.2', lines=['SINGLE_LINE_NOTE =', "    '//' LINE_TEXT"], name='SINGLE_LINE_NOTE', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.2', lines=['MULTILINE_NOTE =', "    '//*' COMMENT_TEXT '*/'"], name='MULTILINE_NOTE', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.2', lines=['REGULAR_COMMENT =', "    '/*' COMMENT_TEXT '*/'"], name='REGULAR_COMMENT', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.2', lines=['COMMENT_TEXT =', '    ( COMMENT_LINE_TEXT | LINE_TERMINATOR )*'], name='COMMENT_TEXT', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.2', lines=['COMMENT_LINE_TEXT =', "    LINE_TEXT excluding the sequence '*/'"], name='COMMENT_LINE_TEXT', abstract_syntax_type='', is_partial=False)
Heading(clause_id='8.2.2.3', lines=['Clause 8.2.2.3 Names'])
Production(clause_id='8.2.2.3', lines=['NAME =', '    BASIC_NAME | UNRESTRICTED_NAME'], name='NAME', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['BASIC_NAME =', '    BASIC_INITIAL_CHARACTER BASIC_NAME_CHARACTER*'], name='BASIC_NAME', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['UNRESTRICTED_NAME =', '    SINGLE_QUOTE ( NAME_CHARACTER | ESCAPE_SEQUENCE )* SINGLE_QUOTE'], name='UNRESTRICTED_NAME', abstract_syntax_type='', is_partial=False)
NoteRef(clause_id='8.2.2.3', lines=['(See Note 1)'])
Production(clause_id='8.2.2.3', lines=["SINGLE_QUOTE = '\\''"], name='SINGLE_QUOTE', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['BASIC_INITIAL_CHARACTER =', "    ALPHABETIC_CHARACTER | '_'"], name='BASIC_INITIAL_CHARACTER', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['BASIC_NAME_CHARACTER =', '    BASIC_INITIAL_CHARACTER | DECIMAL_DIGIT'], name='BASIC_NAME_CHARACTER', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['ALPHABETIC_CHARACTER =', "    any character 'a' through 'z' or 'A' through 'Z'"], name='ALPHABETIC_CHARACTER', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['DECIMAL_DIGIT =', "    any character '0' through '9'"], name='DECIMAL_DIGIT', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['NAME_CHARACTER =', '    any printable character other than backslash or single_quote'], name='NAME_CHARACTER', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.3', lines=['ESCAPE_SEQUENCE ='], name='ESCAPE_SEQUENCE', abstract_syntax_type='', is_partial=False)
NoteRef(clause_id='8.2.2.3', lines=['(See Note 2)'])
NoteList(clause_id='8.2.2.3', lines=["  1. The single_quote character is '. The name represented by an UNRESTRICTED_NAME shall consist of the characters within the single quotes, with escape characters resolved as described below. The surrounding single quote characters are not part of the represented name.", '  2. An ESCAPE_SEQUENCE is a sequence of two text characters starting with a backslash that actually denotes only a single character, except for the newline escape sequence, which represents however many characters is necessary to represent an end of line in a specific implementation (see also 8.2.2.1 ). Table 4 shows the meaning of the allowed escape sequences. The ESCAPE_SEQUENCES in an UNRESTRICTED_NAME shall be replaced by the characters specified as their meanings in the actual represented name.'], html_snippets=[<ol> <li>The <code>single_quote</code> character is <code>'</code>. The name represented by an <code>UNRESTRICTED_NAME</code> shall consist of the characters <em>within</em> the single quotes, with escape characters resolved as described below. The surrounding single quote characters are <em>not</em> part of the represented name.</li> <li>An <code>ESCAPE_SEQUENCE</code><em> </em>is a sequence of two text characters starting with a backslash that actually denotes only a single character, except for the newline escape sequence, which represents however many characters is necessary to represent an end of line in a specific implementation (see also <a href="#c8.2.2.1">8.2.2.1</a>). Table 4 shows the meaning of the allowed escape sequences. The <code>ESCAPE_SEQUENCES</code> in an <code>UNRESTRICTED_NAME</code> shall be replaced by the characters specified as their meanings in the actual represented name.</li>
</ol>])
Heading(clause_id='8.2.2.4', lines=['Clause 8.2.2.4 Numeric Values'])
Production(clause_id='8.2.2.4', lines=['DECIMAL_VALUE =', '    DECIMAL_DIGIT+'], name='DECIMAL_VALUE', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.4', lines=['EXPONENTIAL_VALUE =', "    DECIMAL_VALUE ('e' | 'E') ('+' | '-')? DECIMAL_VALUE"], name='EXPONENTIAL_VALUE', abstract_syntax_type='', is_partial=False)
NoteList(clause_id='8.2.2.4', lines=['  1. A DECIMAL_VALUE may specify a natural literal, or it may be part of the specification of a real literal (see 8.2.5.8.4 ). Note that a DECIMAL_VALUE does not include a sign, because negating a literal is an operator in the KerML Expression syntax.', '  2. An EXPONENTIAL_VALUE may be used in the specification of a real literal (see 8.2.5.8.4 ). Note that a decimal point and fractional part are not included in the lexical structure of an exponential value. They are handled as part of the syntax of real  literals.'], html_snippets=[<ol> <li>A <code>DECIMAL_VALUE</code> may specify a natural literal, or it may be part of the specification of a real literal (see <a href="#c8.2.5.8.4">8.2.5.8.4</a>). Note that a <code>DECIMAL_VALUE</code> does not include a sign, because negating a literal is an operator in the KerML <code>Expression</code> syntax.</li> <li>An <code>EXPONENTIAL_VALUE</code> may be used in the specification of a real literal (see <a href="#c8.2.5.8.4">8.2.5.8.4</a>). Note that a decimal point and fractional part are not included in the lexical structure of an exponential value. They are handled as part of the syntax of real  literals.</li>
</ol>])
Heading(clause_id='8.2.2.5', lines=['Clause 8.2.2.5 String Value'])
Production(clause_id='8.2.2.5', lines=['STRING_VALUE =', '    \'"\' ( STRING_CHARACTER | ESCAPE_SEQUENCE )* \'"\''], name='STRING_VALUE', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.5', lines=['STRING_CHARACTER =', '    any printable character other than backslash or \'"\''], name='STRING_CHARACTER', abstract_syntax_type='', is_partial=False)
NoteList(clause_id='8.2.2.5', lines=['  1. ESCAPE_SEQUENCE is specified in 8.2.2.3.'], html_snippets=[<ol> <li><code>ESCAPE_SEQUENCE</code> is specified in <a href="#c8.2.2.3">8.2.2.3</a>.</li>
</ol>])
Heading(clause_id='8.2.2.6', lines=['Clause 8.2.2.6 Reserved Words'])
Production(clause_id='8.2.2.6', lines=['RESERVED_KEYWORD =', "    'about' | 'abstract' | 'alias' | 'all' | 'and' | 'as' | 'assoc' | 'behavior' | 'binding' | 'bool' | 'by' | 'chains'", "    | 'class' | 'classifier' | 'comment' | 'composite' | 'conjugate' | 'conjugates' | 'conjugation' | 'connector'", "    | 'const' | 'crosses' | 'datatype' | 'default' | 'dependency' | 'derived' | 'differences' | 'disjoining' | 'disjoint'", "    | 'doc' | 'else' | 'end' | 'expr' | 'false' | 'feature' | 'featured' | 'featuring' | 'filter' | 'first' | 'flow'", "    | 'for' | 'from' | 'function' | 'hastype' | 'if' | 'implies' | 'import' | 'in' | 'inout' | 'interaction'", "    | 'intersects' | 'inv' | 'inverse' | 'inverting' | 'istype' | 'language' | 'library' | 'locale' | 'member' | 'meta'", "    | 'metaclass' | 'metadata' | 'multiplicity' | 'namespace' | 'nonunique' | 'not' | 'null' | 'of' | 'or' | 'ordered'", "    | 'out' | 'package' | 'portion' | 'predicate' | 'private' | 'protected' | 'public' | 'redefines' | 'redefinition'", "    | 'references' | 'rep' | 'return' | 'specialization' | 'specializes' | 'standard' | 'step' | 'struct'", "    | 'subclassifier' | 'subset' | 'subsets' | 'subtype' | 'succession' | 'then' | 'to' | 'true' | 'type' | 'typed'", "    | 'typing' | 'unions' | 'var' | 'xor'"], name='RESERVED_KEYWORD', abstract_syntax_type='', is_partial=False)
Heading(clause_id='8.2.2.7', lines=['Clause 8.2.2.7 Symbols'])
Production(clause_id='8.2.2.7', lines=['RESERVED_SYMBOL = ', "    '~' | '}' | '|' | '{' | '^' | ']' | '[' | '@' | '??' | '?' | '>=' | '>' | '=>' | '===' | '==' | '=' | '<=' | '<'", "    | ';' | ':>>' | ':>' | ':=' | '::>' | '::' | ':' | '/' | '.?' | '..' | '.' | '->' | '-' | ',' | '+' | '**' | '*' | ')'", "    | '(' | '&' | '%' | '$' | '#' | '!==' | '!='"], name='RESERVED_SYMBOL', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["TYPED_BY    = ':'   | 'typed' 'by'"], name='TYPED_BY', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["SPECIALIZES = ':>'  | 'specializes'"], name='SPECIALIZES', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["SUBSETS     = ':>'  | 'subsets'"], name='SUBSETS', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["REFERENCES  = '::>' | 'references'"], name='REFERENCES', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["CROSSES     = '=>'  | 'crosses'"], name='CROSSES', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["REDEFINES   = ':>>' | 'redefines'"], name='REDEFINES', abstract_syntax_type='', is_partial=False)
Production(clause_id='8.2.2.7', lines=["CONJUGATES  = '~'   | 'conjugates'"], name='CONJUGATES', abstract_syntax_type='', is_partial=False)
Heading(clause_id='8.2.3', lines=['Clause 8.2.3 Root Concrete Syntax'])
Heading(clause_id='8.2.3.1', lines=['Clause 8.2.3.1 Elements and Relationships Concrete Syntax'])
Production(clause_id='8.2.3.1', lines=['Identification : Element =', "    ( '<' declaredShortName = NAME '>' )?", '    ( declaredName = NAME )?'], name='Identification', abstract_syntax_type='Element', is_partial=False)
Production(clause_id='8.2.3.1', lines=['RelationshipBody : Relationship =', "    ';' | '{' RelationshipOwnedElement* '}'"], name='RelationshipBody', abstract_syntax_type='Relationship', is_partial=False)
Production(clause_id='8.2.3.1', lines=['RelationshipOwnedElement : Relationship =', '      ownedRelatedElement += OwnedRelatedElement', '    | ownedRelationship += OwnedAnnotation'], name='RelationshipOwnedElement', abstract_syntax_type='Relationship', is_partial=False)
Production(clause_id='8.2.3.1', lines=['OwnedRelatedElement : Element =', '    NonFeatureElement | FeatureElement'], name='OwnedRelatedElement', abstract_syntax_type='Element', is_partial=False)
Heading(clause_id='8.2.3.2', lines=['Clause 8.2.3.2 Dependencies Concrete Syntax'])
Production(clause_id='8.2.3.2', lines=['Dependency =', '    ( ownedRelationship += PrefixMetadataAnnotation )*', "    'dependency' ( Identification? 'from' )?", "    client += [QualifiedName] ( ',' client += [QualifiedName] )* 'to'", "    supplier += [QualifiedName] ( ',' supplier += [QualifiedName] )*", '    RelationshipBody'], name='Dependency', abstract_syntax_type='Dependency', is_partial=False)
NoteList(clause_id='8.2.3.2', lines=['  1. PrefixMetadataAnnotation is defined in the Kernel layer (see 8.2.5.12 ).'], html_snippets=[<ol> <li><code>PrefixMetadataAnnotation</code> is defined in the Kernel layer (see <a href="#c8.2.5.12">8.2.5.12</a>).</li>
</ol>])
Heading(clause_id='8.2.3.3', lines=['Clause 8.2.3.3 Annotations Concrete Syntax'])
Heading(clause_id='8.2.3.3.1', lines=['Clause 8.2.3.3.1 Annotations'])
Production(clause_id='8.2.3.3.1', lines=['Annotation =', '    annotatedElement = [QualifiedName]'], name='Annotation', abstract_syntax_type='Annotation', is_partial=False)
Production(clause_id='8.2.3.3.1', lines=['OwnedAnnotation : Annotation =', '    ownedRelatedElement += AnnotatingElement'], name='OwnedAnnotation', abstract_syntax_type='Annotation', is_partial=False)
Production(clause_id='8.2.3.3.1', lines=['AnnotatingElement =', '      Comment', '    | Documentation', '    | TextualRepresentation', '    | MetadataFeature'], name='AnnotatingElement', abstract_syntax_type='AnnotatingElement', is_partial=False)
NoteList(clause_id='8.2.3.3.1', lines=['  1. MetadataFeature is defined in the Kernel layer (see 8.2.5.12 ).'], html_snippets=[<ol> <li><code>MetadataFeature</code> is defined in the Kernel layer (see <a href="#c8.2.5.12">8.2.5.12</a>).</li>
</ol>])
Heading(clause_id='8.2.3.3.2', lines=['Clause 8.2.3.3.2 Comments and Documentation'])
Production(clause_id='8.2.3.3.2', lines=['Comment =', "    ( 'comment' Identification", "      ( 'about' ownedRelationsip += Annotation", "        ( ',' ownedRelationship += Annotation )*", '      )?', '    )?', "    ( 'locale' locale = STRING_VALUE )?", '    body = REGULAR_COMMENT'], name='Comment', abstract_syntax_type='Comment', is_partial=False)
Production(clause_id='8.2.3.3.2', lines=['Documentation =', "    'doc' Identification", "    ( 'locale' locale = STRING_VALUE )?", '    body = REGULAR_COMMENT'], name='Documentation', abstract_syntax_type='Documentation', is_partial=False)
NoteList(clause_id='8.2.3.3.2', lines=['  1. The text of a lexical REGULAR_COMMENT or PREFIX_COMMENT shall be processed as follows before it is included as the body of a Comment or Documentation : Remove the initial /* and final */ characters. Remove any white space immediately after the initial /*, up to and including the first line terminator (if any). On each subsequent line of the text: Strip initial white space other than line terminators. Then, if the first remaining character is " * ", remove it. Then, if the first remaining character is now a space, remove it.', '  2. The body text of a Comment can include markup information (such as HTML), and a conforming tool may display such text as rendered according to the markup. However, marked up "rich text" for a Comment written using the KerML textual concrete syntax shall be stored in the Comment body in plain text including all mark up text, with all line terminators and white space included as entered, other than what is removed according to the rules above.'], html_snippets=[<ol> <li>The text of a lexical <code>REGULAR_COMMENT</code> or <code>PREFIX_COMMENT</code> shall be processed as follows before it is included as the body of a <code>Comment</code> or <code>Documentation</code>:

	<ol> <li> Remove the initial <code>/*</code> and final <code>*/</code> characters. </li> <li> Remove any white space immediately after the initial <code>/*</code>, up to and including the first line terminator (if any). </li> <li> On each subsequent line of the text: <ol> <li> Strip initial white space other than line terminators. </li> <li> Then, if the first remaining character is "<code>*</code>", remove it. </li> <li> Then, if the first remaining character is now a space, remove it. </li> </ol> </li> </ol> </li> <li>The body text of a <code>Comment</code> can include markup information (such as HTML), and a conforming tool may display such text as rendered according to the markup. However, marked up "rich text" for a <code>Comment</code> written using the KerML textual concrete syntax shall be stored in the <code>Comment</code> body in plain text including all mark up text, with all line terminators and white space included as entered, other than what is removed according to the rules above.</li>
</ol>])
Heading(clause_id='8.2.3.3.3', lines=['Clause 8.2.3.3.3 Textual Representation'])
Production(clause_id='8.2.3.3.3', lines=['TextualRepresentation =', "    ( 'rep' Identification )?", "    'language' language = STRING_VALUE", '    body = REGULAR_COMMENT'], name='TextualRepresentation', abstract_syntax_type='TextualRepresentation', is_partial=False)
NoteList(clause_id='8.2.3.3.3', lines=['  1. The lexical text of a REGULAR_COMMENT shall be processed as specified in 8.2.3.3.2 for Comments before being included as the body of a TextualRepresentation.', '  2. See also 8.3.2.3.6 on the standard language names recognized for a TextualRepresentation.'], html_snippets=[<ol> <li>The lexical text of a <code>REGULAR_COMMENT</code> shall be processed as specified in <a href="#c8.2.3.3.2">8.2.3.3.2</a> for <code>Comments</code> before being included as the body of a <code>TextualRepresentation</code>.</li> <li>See also 8.3.2.3.6 on the standard <code>language</code> names recognized for a <code>TextualRepresentation</code>.</li>
</ol>])
Heading(clause_id='8.2.3.4', lines=['Clause 8.2.3.4 Namespaces Concrete Syntax'])
Heading(clause_id='8.2.3.4.1', lines=['Clause 8.2.3.4.1 Namespaces'])
Production(clause_id='8.2.3.4.1', lines=['RootNamespace : Namespace =', '    NamespaceBodyElement*'], name='RootNamespace', abstract_syntax_type='Namespace', is_partial=False)
NoteRef(clause_id='8.2.3.4.1', lines=['(See Note 1)'])
Production(clause_id='8.2.3.4.1', lines=['Namespace =', '    ( ownedRelationship += PrefixMetadataMember )*', '    NamespaceDeclaration NamespaceBody'], name='Namespace', abstract_syntax_type='Namespace', is_partial=False)
NoteRef(clause_id='8.2.3.4.1', lines=['(See Note 2)'])
Production(clause_id='8.2.3.4.1', lines=['NamespaceDeclaration : Namespace =', "    'namespace' Identification"], name='NamespaceDeclaration', abstract_syntax_type='Namespace', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['NamespaceBody : Namespace =', "    ';' | '{' NamespaceBodyElement* '}'"], name='NamespaceBody', abstract_syntax_type='Namespace', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['NamespaceBodyElement : Namespace =', '      ownedRelationship += NamespaceMember', '    | ownedRelationship += AliasMember', '    | ownedRelationship += Import'], name='NamespaceBodyElement', abstract_syntax_type='Namespace', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['MemberPrefix : Membership =', '    ( visibility = VisibilityIndicator )?'], name='MemberPrefix', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['VisibilityIndicator : VisibilityKind =', "    'public' | 'private' | 'protected'"], name='VisibilityIndicator', abstract_syntax_type='VisibilityKind', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['NamespaceMember : OwningMembership =', '      NonFeatureMember', '    | NamespaceFeatureMember'], name='NamespaceMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['NonFeatureMember : OwningMembership =', '    MemberPrefix', '    ownedRelatedElement += MemberElement'], name='NonFeatureMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['NamespaceFeatureMember : OwningMembership =', '    MemberPrefix', '    ownedRelatedElement += FeatureElement'], name='NamespaceFeatureMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['AliasMember : Membership =', '    MemberPrefix', "    'alias' ( '<' memberShortName = NAME '>' )?", '    ( memberName = NAME )?', "    'for' memberElement = [QualifiedName]", '    RelationshipBody'], name='AliasMember', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.3.4.1', lines=['QualifiedName =', "   ( '$' '::' )? ( NAME '::' )* NAME"], name='QualifiedName', abstract_syntax_type='QualifiedName', is_partial=False)
NoteRef(clause_id='8.2.3.4.1', lines=['(See Note 3)'])
NoteList(clause_id='8.2.3.4.1', lines=['  1. A root Namespace is a Namespace that has no owningNamespace (see 8.3.2.4 ). Every Element other than a root Namespace must be contained, directly or indirectly, within some root Namespace. Therefore, every valid KerML concrete syntax text can be parsed starting from the RootNamespace production.', '  2. PrefixMetadataMember is defined in the Kernel layer (see 8.2.5.12 ).', '  3. A qualified name is notated as a sequence of segment names separated by " :: " punctuation, optionally with the global scope qualifier " $ " as an initial segment. An unqualified name can be considered the degenerate case of a qualified name with a single segment name. A qualified name is used in the KerML textual concrete syntax to identify an Element that is being referred to in the representation of another Element. A qualified name used in this way does not appear in the corresponding abstract syntax—instead, the abstract syntax representation contains an actual reference to the identified Element. Name resolution is the process of determining the Element that is identified by a qualified name. The segment names of the qualified name other than the last identify a sequence of nested Namespaces that provide the context for resolving the final segment name (see 8.2.3.5 ). The notation [QualifiedName] is used in concrete syntax grammar productions to indicate the result of resolving text parsed as a QualifiedName (see also 8.2.1 ).'], html_snippets=[<ol> <li>A <em>root</em> <code>Namespace</code> is a <code>Namespace</code> that has no <code>owningNamespace</code> (see 8.3.2.4). Every <code>Element</code> other than a root <code>Namespace</code> must be contained, directly or indirectly, within some root <code>Namespace</code>. Therefore, every valid KerML concrete syntax text can be parsed starting from the <code>RootNamespace</code> production.</li> <li><code>PrefixMetadataMember</code> is defined in the Kernel layer (see <a href="#c8.2.5.12">8.2.5.12</a>).</li> <li>A qualified name is notated as a sequence of <em>segment names</em> separated by "<code>::</code>" punctuation, optionally with the global scope qualifier "<code>$</code>" as an initial segment. An <em>unqualified</em> name can be considered the degenerate case of a qualified name with a single segment name. A qualified name is used in the KerML textual concrete syntax to identify an <code>Element</code> that is being referred to in the representation of another <code>Element</code>. A qualified name used in this way does not appear in the corresponding abstract syntax—instead, the abstract syntax representation contains an actual reference to the identified <code>Element</code>. <em>Name resolution</em> is the process of determining the <code>Element</code> that is identified by a qualified name. The segment names of the qualified name other than the last identify a sequence of nested <code>Namespaces</code> that provide the context for resolving the final segment name (see <a href="#c8.2.3.5">8.2.3.5</a>). The notation <code>[QualifiedName]</code> is used in concrete syntax grammar productions to indicate the result of resolving text parsed as a <code>QualifiedName</code> (see also <a href="#c8.2.1">8.2.1</a>).</li>
</ol>])
Heading(clause_id='8.2.3.4.2', lines=['Clause 8.2.3.4.2 Imports'])
Production(clause_id='8.2.3.4.2', lines=['Import =', '    visibility = VisibilityIndicator', "    'import' ( isImportAll ?= 'all' )?", '    ImportDeclaration RelationshipBody'], name='Import', abstract_syntax_type='Import', is_partial=False)
Production(clause_id='8.2.3.4.2', lines=['ImportDeclaration : Import', '    MembershipImport | NamespaceImport'], name='ImportDeclaration', abstract_syntax_type='Import', is_partial=False)
Production(clause_id='8.2.3.4.2', lines=['MembershipImport =', '    importedMembership = [QualifiedName]', "    ( '::' isRecursive ?= '**' )?"], name='MembershipImport', abstract_syntax_type='MembershipImport', is_partial=False)
NoteRef(clause_id='8.2.3.4.2', lines=['(See Note 1)'])
Production(clause_id='8.2.3.4.2', lines=['NamespaceImport =', "      importedNamespace = [QualifiedName] '::' '*'", "      ( '::' isRecursive ?= '**' )?", '    | importedNamespace = FilterPackage', '      { ownedRelatedElement += importedNamespace }'], name='NamespaceImport', abstract_syntax_type='NamespaceImport', is_partial=False)
Production(clause_id='8.2.3.4.2', lines=['FilterPackage : Package =', '    ownedRelationship += ImportDeclaration', '    ( ownedRelationship += FilterPackageMember )+'], name='FilterPackage', abstract_syntax_type='Package', is_partial=False)
Production(clause_id='8.2.3.4.2', lines=['FilterPackageMember : ElementFilterMembership =', "    '[' ownedRelatedElement += OwnedExpression ']'"], name='FilterPackageMember', abstract_syntax_type='ElementFilterMembership', is_partial=False)
NoteList(clause_id='8.2.3.4.2', lines=['  1. The importedMembership of a MembershipImport is the single case in which the Element required from the resolution [QualifiedName] is the actual Membership identified by the QualifedName, not the memberElement of that Membership (see 8.2.3.5 ).'], html_snippets=[<ol> <li>The <code>importedMembership</code> of a <code>MembershipImport</code> is the single case in which the <code>Element</code> required from the resolution <code>[QualifiedName]</code> is the actual <code>Membership</code> identified by the <code>QualifedName</code>, <em>not</em> the <code>memberElement</code> of that <code>Membership</code> (see <a href="#c8.2.3.5">8.2.3.5</a>).</li>
</ol>])
Heading(clause_id='8.2.3.4.3', lines=['Clause 8.2.3.4.3 Namespace Elements'])
Production(clause_id='8.2.3.4.3', lines=['MemberElement : Element =', '    AnnotatingElement | NonFeatureElement'], name='MemberElement', abstract_syntax_type='Element', is_partial=False)
Production(clause_id='8.2.3.4.3', lines=['NonFeatureElement : Element =', '      Dependency', '    | Namespace', '    | Type', '    | Classifier', '    | DataType', '    | Class', '    | Structure', '    | Metaclass', '    | Association', '    | AssociationStructure', '    | Interaction', '    | Behavior', '    | Function', '    | Predicate', '    | Multiplicity', '    | Package', '    | LibraryPackage', '    | Specialization', '    | Conjugation', '    | Subclassification', '    | Disjoining', '    | FeatureInverting', '    | FeatureTyping', '    | Subsetting', '    | Redefinition', '    | TypeFeaturing'], name='NonFeatureElement', abstract_syntax_type='Element', is_partial=False)
Production(clause_id='8.2.3.4.3', lines=['FeatureElement : Feature =', '      Feature', '    | Step', '    | Expression', '    | BooleanExpression', '    | Invariant', '    | Connector', '    | BindingConnector', '    | Succession', '    | Flow', '    | SuccessionFlow'], name='FeatureElement', abstract_syntax_type='Feature', is_partial=False)
Heading(clause_id='8.2.3.5', lines=['Clause 8.2.3.5 Name Resolution'])
Heading(clause_id='8.2.3.5.1', lines=['Clause 8.2.3.5.1 Name Resolution Overview'])
Heading(clause_id='8.2.3.5.2', lines=['Clause 8.2.3.5.2 Local and Global Namespaces'])
Heading(clause_id='8.2.3.5.3', lines=['Clause 8.2.3.5.3 Local and Visible Resolution'])
Heading(clause_id='8.2.3.5.4', lines=['Clause 8.2.3.5.4 Full Resolution'])
Heading(clause_id='8.2.4', lines=['Clause 8.2.4 Core Concrete Syntax'])
Heading(clause_id='8.2.4.1', lines=['Clause 8.2.4.1 Types Concrete Syntax'])
Heading(clause_id='8.2.4.1.1', lines=['Clause 8.2.4.1.1 Types'])
Production(clause_id='8.2.4.1.1', lines=['Type =', "    TypePrefix 'type'", '    TypeDeclaration TypeBody'], name='Type', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['TypePrefix : Type =', "    ( isAbstract ?= 'abstract' )?", '    ( ownedRelationship += PrefixMetadataMember )*'], name='TypePrefix', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['TypeDeclaration : Type =', "    ( isSufficient ?= 'all' )? Identification", '    ( ownedRelationship += OwnedMultiplicity )?', '    ( SpecializationPart | ConjugationPart )+', '    TypeRelationshipPart*'], name='TypeDeclaration', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['SpecializationPart : Type =', '    SPECIALIZES ownedRelationship += OwnedSpecialization', "    ( ',' ownedRelationship += OwnedSpecialization )*"], name='SpecializationPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['ConjugationPart : Type =', '    CONJUGATES ownedRelationship += OwnedConjugation'], name='ConjugationPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['TypeRelationshipPart : Type =', '      DisjoiningPart', '    | UnioningPart', '    | IntersectingPart', '    | DifferencingPart'], name='TypeRelationshipPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['DisjoiningPart : Type =', "    'disjoint' 'from' ownedRelationship += OwnedDisjoining", "    ( ',' ownedRelationship += OwnedDisjoining )*"], name='DisjoiningPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['UnioningPart : Type =', "    'unions' ownedRelationship += Unioning", "    ( ',' ownedRelationship += Unioning )*"], name='UnioningPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['IntersectingPart : Type =', "    'intersects' ownedRelationship += Intersecting", "    ( ',' ownedRelationship += Intersecting )*"], name='IntersectingPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['DifferencingPart : Type =', "    'differences' ownedRelationship += Differencing", "    ( ',' ownedRelationship += Differencing )*"], name='DifferencingPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['TypeBody : Type =', "    ';' | '{' TypeBodyElement* '}'"], name='TypeBody', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.4.1.1', lines=['TypeBodyElement : Type =', '      ownedRelationship += NonFeatureMember', '    | ownedRelationship += FeatureMember', '    | ownedRelationship += AliasMember', '    | ownedRelationship += Import'], name='TypeBodyElement', abstract_syntax_type='Type', is_partial=False)
Heading(clause_id='8.2.4.1.2', lines=['Clause 8.2.4.1.2 Specialization'])
Production(clause_id='8.2.4.1.2', lines=['Specialization =', "    ( 'specialization' Identification )?", "    'subtype' SpecificType", '    SPECIALIZES GeneralType', '    RelationshipBody'], name='Specialization', abstract_syntax_type='Specialization', is_partial=False)
Production(clause_id='8.2.4.1.2', lines=['OwnedSpecialization : Specialization =', '    GeneralType'], name='OwnedSpecialization', abstract_syntax_type='Specialization', is_partial=False)
Production(clause_id='8.2.4.1.2', lines=['SpecificType : Specialization :', '      specific = [QualifiedName]', '    | specific += OwnedFeatureChain', '      { ownedRelatedElement += specific }'], name='SpecificType', abstract_syntax_type='Specialization :', is_partial=False)
Production(clause_id='8.2.4.1.2', lines=['GeneralType : Specialization =', '      general = [QualifiedName]', '    | general += OwnedFeatureChain', '      { ownedRelatedElement += general }'], name='GeneralType', abstract_syntax_type='Specialization', is_partial=False)
Heading(clause_id='8.2.4.1.3', lines=['Clause 8.2.4.1.3 Conjugation'])
Production(clause_id='8.2.4.1.3', lines=['Conjugation =', "    ( 'conjugation' Identification )?", "    'conjugate'", '    ( conjugatedType = [QualifiedName]', '    | conjugatedType = FeatureChain', '      { ownedRelatedElement += conjugatedType }', '    )', '    CONJUGATES', '    ( originalType = [QualifiedName]', '    | originalType = FeatureChain', '      { ownedRelatedElement += originalType }', '    )', '    RelationshipBody'], name='Conjugation', abstract_syntax_type='Conjugation', is_partial=False)
Production(clause_id='8.2.4.1.3', lines=['OwnedConjugation : Conjugation =', '      originalType = [QualifiedName]', '    | originalType = FeatureChain', '      { ownedRelatedElement += originalType }'], name='OwnedConjugation', abstract_syntax_type='Conjugation', is_partial=False)
Heading(clause_id='8.2.4.1.4', lines=['Clause 8.2.4.1.4 Disjoining'])
Production(clause_id='8.2.4.1.4', lines=['Disjoining =', "    ( 'disjoining' Identification )?", "    'disjoint'", '    ( typeDisjoined = [QualifiedName]', '    | typeDisjoined = FeatureChain', '      { ownedRelatedElement += typeDisjoined }', '    )', "    'from'", '    ( disjoiningType = [QualifiedName]', '    | disjoiningType = FeatureChain', '      { ownedRelatedElement += disjoiningType }', '    )', '    RelationshipBody'], name='Disjoining', abstract_syntax_type='Disjoining', is_partial=False)
Production(clause_id='8.2.4.1.4', lines=['OwnedDisjoining : Disjoining =', '      disjoiningType = [QualifiedName]', '    | disjoiningType = FeatureChain', '      { ownedRelatedElement += disjoiningType }'], name='OwnedDisjoining', abstract_syntax_type='Disjoining', is_partial=False)
Heading(clause_id='8.2.4.1.5', lines=['Clause 8.2.4.1.5 Unioning, Intersecting and Differencing'])
Production(clause_id='8.2.4.1.5', lines=['Unioning =', '      unioningType = [QualifiedName]', '    | ownedRelatedElement += OwnedFeatureChain'], name='Unioning', abstract_syntax_type='Unioning', is_partial=False)
Production(clause_id='8.2.4.1.5', lines=['Intersecting =', '      intersectingType = [QualifiedName]', '    | ownedRelatedElement += OwnedFeatureChain'], name='Intersecting', abstract_syntax_type='Intersecting', is_partial=False)
Production(clause_id='8.2.4.1.5', lines=['Differencing =', '      differencingType = [QualifiedName]', '    | ownedRelatedElement += OwnedFeatureChain'], name='Differencing', abstract_syntax_type='Differencing', is_partial=False)
Heading(clause_id='8.2.4.1.6', lines=['Clause 8.2.4.1.6 Feature Membership'])
Production(clause_id='8.2.4.1.6', lines=['FeatureMember : OwningMembership =', '      TypeFeatureMember', '    | OwnedFeatureMember'], name='FeatureMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.4.1.6', lines=['TypeFeatureMember : OwningMembership =', "    MemberPrefix 'member' ownedRelatedElement += FeatureElement"], name='TypeFeatureMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.4.1.6', lines=['OwnedFeatureMember : FeatureMembership =', '    MemberPrefix ownedRelatedElement += FeatureElement'], name='OwnedFeatureMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Heading(clause_id='8.2.4.2', lines=['Clause 8.2.4.2 Classifiers Concrete Syntax'])
Heading(clause_id='8.2.4.2.1', lines=['Clause 8.2.4.2.1 Classifiers'])
Production(clause_id='8.2.4.2.1', lines=['Classifier =', "    TypePrefix 'classifier'", '    ClassifierDeclaration TypeBody'], name='Classifier', abstract_syntax_type='Classifier', is_partial=False)
Production(clause_id='8.2.4.2.1', lines=['ClassifierDeclaration : Classifier =', "    ( isSufficient ?= 'all' )? Identification", '    ( ownedRelationship += OwnedMultiplicity )?', '    ( SuperclassingPart | ConjugationPart )?', '    TypeRelationshipPart*'], name='ClassifierDeclaration', abstract_syntax_type='Classifier', is_partial=False)
Production(clause_id='8.2.4.2.1', lines=['SuperclassingPart : Classifier =', '      SPECIALIZES ownedRelationship += OwnedSubclassification', "      ( ',' ownedRelationship += OwnedSubclassification )*"], name='SuperclassingPart', abstract_syntax_type='Classifier', is_partial=False)
Heading(clause_id='8.2.4.2.2', lines=['Clause 8.2.4.2.2 Subclassification'])
Production(clause_id='8.2.4.2.2', lines=['Subclassification =', "    ( 'specialization' Identification )?", "    'subclassifier' subclassifier = [QualifiedName]", '    SPECIALIZES superclassifier = [QualifiedName]', '    RelationshipBody'], name='Subclassification', abstract_syntax_type='Subclassification', is_partial=False)
Production(clause_id='8.2.4.2.2', lines=['OwnedSubclassification : Subclassification =', '    superclassifier = [QualifiedName]'], name='OwnedSubclassification', abstract_syntax_type='Subclassification', is_partial=False)
Heading(clause_id='8.2.4.3', lines=['Clause 8.2.4.3 Features Concrete Syntax'])
Heading(clause_id='8.2.4.3.1', lines=['Clause 8.2.4.3.1 Features'])
Production(clause_id='8.2.4.3.1', lines=['Feature =', '    ( FeaturePrefix', "      ( 'feature' | ownedRelationship += PrefixMetadataMember )", '      FeatureDeclaration?', '      )', '    | ( EndFeaturePrefix | BasicFeaturePrefix )', '      FeatureDeclaration', '    )', '    ValuePart? TypeBody'], name='Feature', abstract_syntax_type='Feature', is_partial=False)
NoteRef(clause_id='8.2.4.3.1', lines=['(See Note 1)'])
Production(clause_id='8.2.4.3.1', lines=['EndFeaturePrefix : Feature =', "    ( isConstant ?= 'const' { isVariable = true } )?", "    isEnd ?= 'end'"], name='EndFeaturePrefix', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['BasicFeaturePrefix : Feature :', '    ( direction = FeatureDirection )?', "    ( isDerived ?= 'derived' )?", "    ( isAbstract ?= 'abstract' )?", "    ( isComposite ?= 'composite' | isPortion ?= 'portion' )?", "    ( isVariable ?= 'var' | isConstant ?= 'const' { isVariable = true } )?"], name='BasicFeaturePrefix', abstract_syntax_type='Feature :', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeaturePrefix :', '    ( EndFeaturePrefix ( ownedRelationship += OwnedCrossFeatureMember )?', '    | BasicFeaturePrefix', '    )', '    ( ownedRelationship += PrefixMetadataMember )*'], name='FeaturePrefix', abstract_syntax_type='', is_partial=False)
NoteRef(clause_id='8.2.4.3.1', lines=['(See Note 1)'])
Production(clause_id='8.2.4.3.1', lines=['OwnedCrossFeatureMember : OwningMembership =', '    ownedRelatedElement += OwnedCrossFeature'], name='OwnedCrossFeatureMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['OwnedCrossFeature : Feature =', '    BasicFeaturePrefix FeatureDeclaration'], name='OwnedCrossFeature', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeatureDirection : FeatureDirectionKind =', "    'in' | 'out' | 'inout'"], name='FeatureDirection', abstract_syntax_type='FeatureDirectionKind', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeatureDeclaration : Feature =', "    ( isSufficient ?= 'all' )?", '    ( FeatureIdentification', '      ( FeatureSpecializationPart | ConjugationPart )?', '    | FeatureSpecializationPart', '    | ConjugationPart', '    )', '    FeatureRelationshipPart*'], name='FeatureDeclaration', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeatureIdentification : Feature =', "      '<' declaredShortName = NAME '>' ( declaredName = NAME )?", '    | declaredName = NAME'], name='FeatureIdentification', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeatureRelationshipPart : Feature =', '      TypeRelationshipPart', '    | ChainingPart', '    | InvertingPart', '    | TypeFeaturingPart'], name='FeatureRelationshipPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['ChainingPart : Feature =', "    'chains'", '    ( ownedRelationship += OwnedFeatureChaining', '    | FeatureChain )'], name='ChainingPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['InvertingPart : Feature =', "    'inverse' 'of' ownedRelationship += OwnedFeatureInverting"], name='InvertingPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['TypeFeaturingPart : Feature =', "    'featured' 'by' ownedRelatioship += OwnedTypeFeaturing", "    ( ',' ownedTypeFeaturing += OwnedTypeFeaturing )*"], name='TypeFeaturingPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeatureSpecializationPart : Feature =', '      FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*', '    | MultiplicityPart FeatureSpecialization*'], name='FeatureSpecializationPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['MultiplicityPart : Feature =', '      ownedRelationship += OwnedMultiplicity', '    | ( ownedRelationship += OwnedMultiplicity )?', "      ( isOrdered ?= 'ordered' ( {isUnique = false} 'nonunique' )?", "      | {isUnique = false} 'nonunique' ( isOrdered ?= 'ordered' )? )"], name='MultiplicityPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['FeatureSpecialization : Feature =', '    Typings | Subsettings | References | Crosses | Redefinitions'], name='FeatureSpecialization', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['Typings : Feature =', "      TypedBy ( ',' ownedRelationship += OwnedFeatureTyping )*"], name='Typings', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['TypedBy : Feature =', '    TYPED_BY ownedRelationship += OwnedFeatureTyping'], name='TypedBy', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['Subsettings : Feature =', "    Subsets ( ',' ownedRelationship += OwnedSubsetting )*"], name='Subsettings', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['Subsets : Feature =', '    SUBSETS ownedRelationship += OwnedSubsetting'], name='Subsets', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['References : Feature =', '    REFERENCES ownedRelationship += OwnedReferenceSubsetting'], name='References', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['Crosses : Feature =', '    CROSSES ownedRelationship += OwnedCrossSubsetting'], name='Crosses', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['Redefinitions : Feature =', "    Redefines ( ',' ownedRelationship += OwnedRedefinition )*"], name='Redefinitions', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.1', lines=['Redefines : Feature =', '    REDEFINES ownedRelationship += OwnedRedefinition'], name='Redefines', abstract_syntax_type='Feature', is_partial=False)
NoteList(clause_id='8.2.4.3.1', lines=['  1. PrefixMetadataMember is defined in the Kernel layer (see 8.3.4.12 ).'], html_snippets=[<ol> <li><code>PrefixMetadataMember</code> is defined in the Kernel layer (see 8.3.4.12).</li>
</ol>])
Heading(clause_id='8.2.4.3.2', lines=['Clause 8.2.4.3.2 Feature Typing'])
Production(clause_id='8.2.4.3.2', lines=['FeatureTyping =', "    ( 'specialization' Identification )?", "    'typing' typedFeature = [QualifiedName]", '    TYPED_BY GeneralType', '    RelationshipBody'], name='FeatureTyping', abstract_syntax_type='FeatureTyping', is_partial=False)
Production(clause_id='8.2.4.3.2', lines=['OwnedFeatureTyping : FeatureTyping =', '    GeneralType'], name='OwnedFeatureTyping', abstract_syntax_type='FeatureTyping', is_partial=False)
Heading(clause_id='8.2.4.3.3', lines=['Clause 8.2.4.3.3 Subsetting'])
Production(clause_id='8.2.4.3.3', lines=['Subsetting =', "    ( 'specialization' Identification )?", "    'subset' SpecificType", '    SUBSETS GeneralType', '    RelationshipBody'], name='Subsetting', abstract_syntax_type='Subsetting', is_partial=False)
Production(clause_id='8.2.4.3.3', lines=['OwnedSubsetting : Subsetting =', '    GeneralType'], name='OwnedSubsetting', abstract_syntax_type='Subsetting', is_partial=False)
Production(clause_id='8.2.4.3.3', lines=['OwnedReferenceSubsetting : ReferenceSubsetting =', '    GeneralType'], name='OwnedReferenceSubsetting', abstract_syntax_type='ReferenceSubsetting', is_partial=False)
Production(clause_id='8.2.4.3.3', lines=['OwnedCrossSubsetting : CrossSubsetting =', '    GeneralType'], name='OwnedCrossSubsetting', abstract_syntax_type='CrossSubsetting', is_partial=False)
Heading(clause_id='8.2.4.3.4', lines=['Clause 8.2.4.3.4 Redefinition'])
Production(clause_id='8.2.4.3.4', lines=['Redefinition =', "    ( 'specialization' Identification )?", "    'redefinition' SpecificType", '    REDEFINES GeneralType', '    RelationshipBody'], name='Redefinition', abstract_syntax_type='Redefinition', is_partial=False)
Production(clause_id='8.2.4.3.4', lines=['OwnedRedefinition : Redefinition =', '    GeneralType'], name='OwnedRedefinition', abstract_syntax_type='Redefinition', is_partial=False)
Heading(clause_id='8.2.4.3.5', lines=['Clause 8.2.4.3.5 Feature Chaining'])
Production(clause_id='8.2.4.3.5', lines=['OwnedFeatureChain : Feature =', '    FeatureChain'], name='OwnedFeatureChain', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.5', lines=['FeatureChain : Feature =', '    ownedRelationship += OwnedFeatureChaining', "    ( '.' ownedRelationship += OwnedFeatureChaining )+"], name='FeatureChain', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.4.3.5', lines=['OwnedFeatureChaining : FeatureChaining =', '    chainingFeature = [QualifiedName]'], name='OwnedFeatureChaining', abstract_syntax_type='FeatureChaining', is_partial=False)
Heading(clause_id='8.2.4.3.6', lines=['Clause 8.2.4.3.6 Feature Inverting'])
Production(clause_id='8.2.4.3.6', lines=['FeatureInverting =', "    ( 'inverting' Identification? )?", "    'inverse'", '    ( featureInverted = [QualifiedName]', '    | featureInverted = OwnedFeatureChain', '      { ownedRelatedElement += featureInverted }', '    )', "    'of'", '    ( invertingFeature = [QualifiedName]', '    | ownedRelatedElement += OwnedFeatureChain', '      { ownedRelatedElement += invertingFeature }', '    )', '    RelationshipBody'], name='FeatureInverting', abstract_syntax_type='FeatureInverting', is_partial=False)
Production(clause_id='8.2.4.3.6', lines=['OwnedFeatureInverting : FeatureInverting =', '      invertingFeature = [QualifiedName]', '    | invertingFeature = OwnedFeatureChain', '      { ownedRelatedElement += invertingFeature }'], name='OwnedFeatureInverting', abstract_syntax_type='FeatureInverting', is_partial=False)
Heading(clause_id='8.2.4.3.7', lines=['Clause 8.2.4.3.7 Type Featuring'])
Production(clause_id='8.2.4.3.7', lines=['TypeFeaturing =', "    'featuring' ( Identification 'of' )?", '    featureOfType = [QualifiedName]', "    'by' featuringType = [QualifiedName]", '    RelationshipBody'], name='TypeFeaturing', abstract_syntax_type='TypeFeaturing', is_partial=False)
Production(clause_id='8.2.4.3.7', lines=['OwnedTypeFeaturing : TypeFeaturing =', '    featuringType = [QualifiedName]'], name='OwnedTypeFeaturing', abstract_syntax_type='TypeFeaturing', is_partial=False)
Heading(clause_id='8.2.5', lines=['Clause 8.2.5 Kernel Concrete Syntax'])
Heading(clause_id='8.2.5.1', lines=['Clause 8.2.5.1 Data Types Concrete Syntax'])
Production(clause_id='8.2.5.1', lines=['DataType =', "    TypePrefix 'datatype'", '    ClassifierDeclaration TypeBody'], name='DataType', abstract_syntax_type='DataType', is_partial=False)
Heading(clause_id='8.2.5.2', lines=['Clause 8.2.5.2 Classes Concrete Syntax'])
Production(clause_id='8.2.5.2', lines=['Class =', "    TypePrefix 'class'", '    ClassifierDeclaration TypeBody'], name='Class', abstract_syntax_type='Class', is_partial=False)
Heading(clause_id='8.2.5.3', lines=['Clause 8.2.5.3 Structures Concrete Syntax'])
Production(clause_id='8.2.5.3', lines=['Structure =', "    TypePrefix 'struct'", '    ClassifierDeclaration TypeBody'], name='Structure', abstract_syntax_type='Structure', is_partial=False)
Heading(clause_id='8.2.5.4', lines=['Clause 8.2.5.4 Associations Concrete Syntax'])
Production(clause_id='8.2.5.4', lines=['Association =', "    TypePrefix 'assoc'", '    ClassifierDeclaration TypeBody'], name='Association', abstract_syntax_type='Association', is_partial=False)
Production(clause_id='8.2.5.4', lines=['AssociationStructure =', "    TypePrefix 'assoc' 'struct'", '    ClassifierDeclaration TypeBody'], name='AssociationStructure', abstract_syntax_type='AssociationStructure', is_partial=False)
Heading(clause_id='8.2.5.5', lines=['Clause 8.2.5.5 Connectors Concrete Syntax'])
Heading(clause_id='8.2.5.5.1', lines=['Clause 8.2.5.5.1 Connectors'])
Production(clause_id='8.2.5.5.1', lines=['Connector =', "    FeaturePrefix 'connector'", '    ( FeatureDeclaration? ValuePart?', '    | ConnectorDeclaration', '    )', '    TypeBody'], name='Connector', abstract_syntax_type='Connector', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['ConnectorDeclaration : Connector =', '    BinaryConnectorDeclaration | NaryConnectorDeclaration'], name='ConnectorDeclaration', abstract_syntax_type='Connector', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['BinaryConnectorDeclaration : Connector =', "    ( FeatureDeclaration? 'from' | isSufficient ?= 'all' 'from'? )?", "    ownedRelationship += ConnectorEndMember 'to'", '    ownedRelationship += ConnectorEndMember'], name='BinaryConnectorDeclaration', abstract_syntax_type='Connector', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['NaryConnectorDeclaration : Connector =', '    FeatureDeclaration?', "    '(' ownedRelationship += ConnectorEndMember ','", '        ownedRelationship += ConnectorEndMember', "        ( ',' ownedRelationship += ConnectorEndMember )*", "    ')'"], name='NaryConnectorDeclaration', abstract_syntax_type='Connector', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['ConnectorEndMember : EndFeatureMembership =', '    ownedRelatedElement += ConnectorEnd'], name='ConnectorEndMember', abstract_syntax_type='EndFeatureMembership', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['ConnectorEnd : Feature =', '\t( ownedRelationship += OwnedCrossMultiplicityMember )?', '\t( declaredName = NAME REFERENCES )?', '\townedRelationship += OwnedReferenceSubsetting'], name='ConnectorEnd', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['OwnedCrossMultiplicityMember : OwningMembership =', '\townedRelatedElement += OwnedCrossMultiplicity'], name='OwnedCrossMultiplicityMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.5.5.1', lines=['OwnedCrossMultiplicity : Feature =', '\townedRelationship += OwnedMultiplicity'], name='OwnedCrossMultiplicity', abstract_syntax_type='Feature', is_partial=False)
Heading(clause_id='8.2.5.5.2', lines=['Clause 8.2.5.5.2 Binding Connectors'])
Production(clause_id='8.2.5.5.2', lines=['BindingConnector =', "    FeaturePrefix 'binding'", '    BindingConnectorDeclaration TypeBody'], name='BindingConnector', abstract_syntax_type='BindingConnector', is_partial=False)
Production(clause_id='8.2.5.5.2', lines=['BindingConnectorDeclaration : BindingConnector =', '      FeatureDeclaration', "      ( 'of' ownedRelationship += ConnectorEndMember", "        '='  ownedRelationship += ConnectorEndMember )?", "    | ( isSufficient ?= 'all' )?", "      ( 'of'? ownedRelationship += ConnectorEndMember", "        '='   ownedRelationship += ConnectorEndMember )?"], name='BindingConnectorDeclaration', abstract_syntax_type='BindingConnector', is_partial=False)
Heading(clause_id='8.2.5.5.3', lines=['Clause 8.2.5.5.3 Successions'])
Production(clause_id='8.2.5.5.3', lines=['Succession =', "    FeaturePrefix 'succession'", '    SuccessionDeclaration TypeBody'], name='Succession', abstract_syntax_type='Succession', is_partial=False)
Production(clause_id='8.2.5.5.3', lines=['SuccessionDeclaration : Succession =', '      FeatureDeclaration', "      ( 'first' ownedRelationship += ConnectorEndMember", "        'then'  ownedRelationship += ConnectorEndMember )?", "    | ( s.isSufficient ?= 'all' )?", "      ( 'first'? ownedRelationship += ConnectorEndMember", "        'then'   ownedRelationship += ConnectorEndMember )?"], name='SuccessionDeclaration', abstract_syntax_type='Succession', is_partial=False)
Heading(clause_id='8.2.5.6', lines=['Clause 8.2.5.6 Behaviors Concrete Syntax'])
Heading(clause_id='8.2.5.6.1', lines=['Clause 8.2.5.6.1 Behaviors'])
Production(clause_id='8.2.5.6.1', lines=['Behavior =', "    TypePrefix 'behavior'", '    ClassifierDeclaration TypeBody'], name='Behavior', abstract_syntax_type='Behavior', is_partial=False)
Heading(clause_id='8.2.5.6.2', lines=['Clause 8.2.5.6.2 Steps'])
Production(clause_id='8.2.5.6.2', lines=['Step =', '    FeaturePrefix', "    'step' FeatureDeclaration ValuePart?", '    TypeBody'], name='Step', abstract_syntax_type='Step', is_partial=False)
Heading(clause_id='8.2.5.7', lines=['Clause 8.2.5.7 Functions Concrete Syntax'])
Heading(clause_id='8.2.5.7.1', lines=['Clause 8.2.5.7.1 Functions'])
Production(clause_id='8.2.5.7.1', lines=['Function =', "    TypePrefix 'function'", '    ClassifierDeclaration FunctionBody'], name='Function', abstract_syntax_type='Function', is_partial=False)
Production(clause_id='8.2.5.7.1', lines=['FunctionBody : Type =', "    ';' | '{' FunctionBodyPart '}'"], name='FunctionBody', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.5.7.1', lines=['FunctionBodyPart : Type =', '    ( TypeBodyElement', '    | ownedRelationship += ReturnFeatureMember', '    )*', '   ( ownedRelationship += ResultExpressionMember )?'], name='FunctionBodyPart', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.5.7.1', lines=['ReturnFeatureMember : ReturnParameterMembership =', "    MemberPrefix 'return'", '    ownedRelatedElement += FeatureElement'], name='ReturnFeatureMember', abstract_syntax_type='ReturnParameterMembership', is_partial=False)
Production(clause_id='8.2.5.7.1', lines=['ResultExpressionMember : ResultExpressionMembership =', '    MemberPrefix', '    ownedRelatedElement += OwnedExpression'], name='ResultExpressionMember', abstract_syntax_type='ResultExpressionMembership', is_partial=False)
Heading(clause_id='8.2.5.7.2', lines=['Clause 8.2.5.7.2 Expressions'])
Production(clause_id='8.2.5.7.2', lines=['Expression =', '    FeaturePrefix', "    'expr' FeatureDeclaration ValuePart?", '    FunctionBody'], name='Expression', abstract_syntax_type='Expression', is_partial=False)
Heading(clause_id='8.2.5.7.3', lines=['Clause 8.2.5.7.3 Predicates'])
Production(clause_id='8.2.5.7.3', lines=['Predicate =', "    TypePrefix 'predicate'", '    ClassifierDeclaration FunctionBody'], name='Predicate', abstract_syntax_type='Predicate', is_partial=False)
Heading(clause_id='8.2.5.7.4', lines=['Clause 8.2.5.7.4 Boolean Expressions and Invariants'])
Production(clause_id='8.2.5.7.4', lines=['BooleanExpression =', '    FeaturePrefix', "    'bool' FeatureDeclaration ValuePart?", '    FunctionBody'], name='BooleanExpression', abstract_syntax_type='BooleanExpression', is_partial=False)
Production(clause_id='8.2.5.7.4', lines=['Invariant =', '    FeaturePrefix', "    'inv' ( 'true' | isNegated ?= 'false' )?", '    FeatureDeclaration ValuePart?', '    FunctionBody'], name='Invariant', abstract_syntax_type='Invariant', is_partial=False)
Heading(clause_id='8.2.5.8', lines=['Clause 8.2.5.8 Expressions Concrete Syntax'])
Heading(clause_id='8.2.5.8.1', lines=['Clause 8.2.5.8.1 Operator Expressions'])
Production(clause_id='8.2.5.8.1', lines=['OwnedExpressionReferenceMember : FeatureMembership =', '    ownedRelationship += OwnedExpressionReference'], name='OwnedExpressionReferenceMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['OwnedExpressionReference : FeatureReferenceExpression =', '    ownedRelationship += OwnedExpressionMember'], name='OwnedExpressionReference', abstract_syntax_type='FeatureReferenceExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['OwnedExpressionMember : FeatureMembership =', '    ownedFeatureMember = OwnedExpression'], name='OwnedExpressionMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['OwnedExpression : Expression =', '      ConditionalExpression', '    | ConditionalBinaryOperatorExpression', '    | BinaryOperatorExpression', '    | UnaryOperatorExpression', '    | ClassificationExpression', '    | MetaclassificationExpression', '    | ExtentExpression', '    | PrimaryExpression'], name='OwnedExpression', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ConditionalExpression : OperatorExpression =', "    operator = 'if'", "    ownedRelationship += ArgumentMember '?'", "    ownedRelationship += ArgumentExpressionMember 'else'", '    ownedRelationship += ArgumentExpressionMember', '    ownedRelationship += EmptyResultMember'], name='ConditionalExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ConditionalBinaryOperatorExpression : OperatorExpression =', '    ownedRelationship += ArgumentMember', '    operator = ConditionalBinaryOperator', '    ownedRelationship += ArgumentExpressionMember', '    ownedRelationship += EmptyResultMember'], name='ConditionalBinaryOperatorExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ConditionalBinaryOperator =', "    '??' | 'or' | 'and' | 'implies'"], name='ConditionalBinaryOperator', abstract_syntax_type='ConditionalBinaryOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['BinaryOperatorExpression : OperatorExpression =', '    ownedRelationship += ArgumentMember', '    operator = BinaryOperator', '    ownedRelationship += ArgumentMember', '    ownedRelationship += EmptyResultMember'], name='BinaryOperatorExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['BinaryOperator =', "      '|'  | '&'  | 'xor' | '..'", "    | '==' | '!=' | '===' | '!=='", "    | '<'  | '>'  | '<='  | '>='", "    | '+'  | '-'  | '*'   | '/'", "    | '%'  | '^'  | '**'"], name='BinaryOperator', abstract_syntax_type='BinaryOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['UnaryOperatorExpression : OperatorExpression =', '    operator = UnaryOperator', '    ownedRelationship += ArgumentMember', '    ownedRelationship += EmptyResultMember'], name='UnaryOperatorExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['UnaryOperator =', "    '+' | '-' | '~' | 'not'"], name='UnaryOperator', abstract_syntax_type='UnaryOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ClassificationExpression : OperatorExpression =', '    ( ownedRelationship += ArgumentMember )?', '    ( operator = ClassificationTestOperator', '      ownedRelationship += TypeReferenceMember', '    | operator = CastOperator', '      ownedRelationship += TypeResultMember', '    )', '    ownedRelationship += EmptyResultMember'], name='ClassificationExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ClassificationTestOperator =', "    'istype' | 'hastype' | '@'"], name='ClassificationTestOperator', abstract_syntax_type='ClassificationTestOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['CastOperator =', "    'as'"], name='CastOperator', abstract_syntax_type='CastOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetaclassificationExpression : OperatorExpression =', '    ownedRelationship += MetadataArgumentMember', '    ( operator = MetaClassificationTestOperator', '      ownedRelationship += TypeReferenceMember', '    | operator = MetaCastOperator', '      ownedRelationship += TypeResultMember', '    )', '    ownedRelationship += EmptyResultMember'], name='MetaclassificationExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ArgumentMember : ParameterMembership =', '    ownedMemberParameter = Argument'], name='ArgumentMember', abstract_syntax_type='ParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['Argument : Feature =', '    ownedRelationship += ArgumentValue'], name='Argument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ArgumentValue : FeatureValue =', '    value = OwnedExpression'], name='ArgumentValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ArgumentExpressionMember : FeatureMembership =', '    ownedRelatedElement += ArgumentExpression'], name='ArgumentExpressionMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ArgumentExpression : Feature =', '    ownedRelationship += ArgumentExpressionValue'], name='ArgumentExpression', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ArgumentExpressionValue : FeatureValue =', '    value = OwnedExpressionReference'], name='ArgumentExpressionValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetadataArgumentMember : ParameterMembership =', '    ownedRelatedElement += MetadataArgument'], name='MetadataArgumentMember', abstract_syntax_type='ParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetadataArgument : Feature =', '    ownedRelationship += MetadataValue'], name='MetadataArgument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetadataValue : FeatureValue =', '    value = MetadataReference'], name='MetadataValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetadataReference : MetadataAccessExpression =', '    ownedRelationship += ElementReferenceMember'], name='MetadataReference', abstract_syntax_type='MetadataAccessExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetaclassificationTestOperator =', "    '@@'"], name='MetaclassificationTestOperator', abstract_syntax_type='MetaclassificationTestOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['MetaCastOperator =', "    'meta'"], name='MetaCastOperator', abstract_syntax_type='MetaCastOperator', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ExtentExpression : OperatorExpression =', "    operator = 'all'", '    ownedRelationship += TypeReferenceMember'], name='ExtentExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['TypeReferenceMember : ParameterMembership =', '    ownedMemberFeature = TypeReference'], name='TypeReferenceMember', abstract_syntax_type='ParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['TypeResultMember : ResultParameterMembership =', '    ownedMemberFeature = TypeReference'], name='TypeResultMember', abstract_syntax_type='ResultParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['TypeReference : Feature =', '    ownedRelationship += ReferenceTyping'], name='TypeReference', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['ReferenceTyping : FeatureTyping =', '    type = [QualifiedName]'], name='ReferenceTyping', abstract_syntax_type='FeatureTyping', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['EmptyResultMember : ReturnParameterMembership =', '    ownedRelatedElement += EmptyFeature'], name='EmptyResultMember', abstract_syntax_type='ReturnParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.1', lines=['EmptyFeature : Feature =', '    { }'], name='EmptyFeature', abstract_syntax_type='Feature', is_partial=False)
NoteList(clause_id='8.2.5.8.1', lines=['  1. OperatorExpressions provide a shorthand notation for InvocationExpressions that invoke a library Function represented as an operator symbol. Table 5 shows the mapping from operator symbols to the Functions they represent from the Kernel Model Library (see Clause 9 ). An OperatorExpression contains subexpressions called its operands that generally correspond to the argument Expressions of the OperatorExpression, except in the case of operators representing control Functions, in which case the evaluation of certain operands is as determined by the Function (see 8.4.4.9 for details).', '  2. Though not directly expressed in the syntactic productions given above, in any OperatorExpression containing nested OperatorExpressions, the nested OperatorExpressions shall be implicitly grouped according to the precedence of the operators involved, as given in Table 6. OperatorExpressions with higher precedence operators shall be grouped more tightly than those with lower precedence operators. Further, all BinaryOperators other than exponentiation are left-associative (i.e, they group to the left), while the exponentiation operators ( ^ and ** ) are right-associative (i.e., they group to the right).', "  3. The unary operator symbol ~ maps to the library Function DataFunctions::'~', as shown in Table 5. This abstract Function may be given a concrete definition in a domain-specific Function library, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this operator is used."], html_snippets=[<ol> <li><code>OperatorExpressions</code> provide a shorthand notation for <code>InvocationExpressions</code> that invoke a library <code>Function</code> represented as an <code>operator</code><em> symbol.</em> Table 5 shows the mapping from <code>operator</code> symbols to the <code>Functions</code> they represent from the Kernel Model Library (see Clause 9). An <code>OperatorExpression</code> contains subexpressions called its <em>operands</em> that generally correspond to the <code>argument</code> <code>Expressions</code> of the <code>OperatorExpression</code>, except in the case of <code>operators</code> representing <em>control </em><code>Functions</code>, in which case the evaluation of certain operands is as determined by the <code>Function</code> (see 8.4.4.9 for details).</li> <li>Though not directly expressed in the syntactic productions given above, in any <code>OperatorExpression</code> containing nested <code>OperatorExpressions</code>, the nested <code>OperatorExpressions</code> shall be implicitly grouped according to the <em>precedence</em> of the <code>operators</code> involved, as given in Table 6. <code>OperatorExpressions</code> with higher precedence <code>operators</code> shall be grouped more tightly than those with lower precedence <code>operators</code>. Further, all <code>BinaryOperators</code> other than exponentiation are left-associative (i.e, they group to the left), while the exponentiation operators (<code>^</code> and <code>**</code>) are right-associative (i.e., they group to the right).</li> <li>The unary <code>operator</code> symbol <code>~</code> maps to the library <code>Function</code> <em><code>DataFunctions::'~'</code></em>, as shown in Table 5. This abstract <code>Function</code> may be given a concrete definition in a domain-specific <code>Function</code> library, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this <code>operator</code> is used.</li>
</ol>])
Heading(clause_id='8.2.5.8.2', lines=['Clause 8.2.5.8.2 Primary Expressions'])
Production(clause_id='8.2.5.8.2', lines=['PrimaryExpression : Expression =', '      FeatureChainExpression', '    | NonFeatureChainPrimaryExpression'], name='PrimaryExpression', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['PrimaryArgumentValue : FeatureValue =', '    value = PrimaryExpression'], name='PrimaryArgumentValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['PrimaryArgument : Feature =', '    ownedRelationship += PrimaryArgumentValue'], name='PrimaryArgument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['PrimaryArgumentMember : ParameterMembership =', '    ownedMemberParameter = PrimaryArgument'], name='PrimaryArgumentMember', abstract_syntax_type='ParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['NonFeatureChainPrimaryExpression : Expression =', '      BracketExpression', '    | IndexExpression', '    | SequenceExpression', '    | SelectExpression', '    | CollectExpression', '    | FunctionOperationExpression', '    | BaseExpression'], name='NonFeatureChainPrimaryExpression', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['NonFeatureChainPrimaryArgumentValue : FeatureValue =', '    value = NonFeatureChainPrimaryExpression'], name='NonFeatureChainPrimaryArgumentValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['NonFeatureChainPrimaryArgument : Feature =', '    ownedRelationship += NonFeatureChainPrimaryArgumentValue'], name='NonFeatureChainPrimaryArgument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['NonFeatureChainPrimaryArgumentMember : ParameterMembership =', '    ownedMemberParameter = PrimaryArgument'], name='NonFeatureChainPrimaryArgumentMember', abstract_syntax_type='ParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['BracketExpression : OperatorExpression =', '    ownedRelationship += PrimaryArgumentMember', "    operator = '['", "    ownedRelationship += SequenceExpressionListMember ']'"], name='BracketExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['IndexExpression =', "    ownedRelationship += PrimaryArgumentMember '#'", "    '(' ownedRelationship += SequenceExpressionListMember ')'"], name='IndexExpression', abstract_syntax_type='IndexExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['SequenceExpression : Expression =', "    '(' SequenceExpressionList ')'"], name='SequenceExpression', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['SequenceExpressionList : Expression =', "    OwnedExpression ','? | SequenceOperatorExpression"], name='SequenceExpressionList', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['SequenceOperatorExpression : OperatorExpression =', '    ownedRelationship += OwnedExpressionMember', "    operator = ','", '    ownedRelationship += SequenceExpressionListMember'], name='SequenceOperatorExpression', abstract_syntax_type='OperatorExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['SequenceExpressionListMember : FeatureMembership =', '    ownedMemberFeature = SequenceExpressionList'], name='SequenceExpressionListMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FeatureChainExpression =', "    ownedRelationship += NonFeatureChainPrimaryArgumentMember '.'", '    ownedRelationship += FeatureChainMember'], name='FeatureChainExpression', abstract_syntax_type='FeatureChainExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['CollectExpression =', "    ownedRelationship += PrimaryArgumentMember '.'", '    ownedRelationship += BodyArgumentMember'], name='CollectExpression', abstract_syntax_type='CollectExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['SelectExpression =', "    ownedRelationship += PrimaryArgumentMember '.?'", '    ownedRelationship += BodyArgumentMember'], name='SelectExpression', abstract_syntax_type='SelectExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionOperationExpression : InvocationExpression =', "    ownedRelationship += PrimaryArgumentMember '->'", '    ownedRelationship += InvocationTypeMember', '    ( ownedRelationship += BodyArgumentMember', '    | ownedRelationship += FunctionReferenceArgumentMember', '    | ArgumentList )', '    ownedRelationship += EmptyResultMember'], name='FunctionOperationExpression', abstract_syntax_type='InvocationExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['BodyArgumentMember : ParameterMembership =', '    ownedMemberParameter = BodyArgument'], name='BodyArgumentMember', abstract_syntax_type='ParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['BodyArgument : Feature =', '    ownedRelationship += BodyArgumentValue'], name='BodyArgument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['BodyArgumentValue : FeatureValue =', '    value = BodyExpression'], name='BodyArgumentValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionReferenceArgumentMember : ParameterMembershiup =', '    ownedMemberParameter = FunctionReferenceArgument'], name='FunctionReferenceArgumentMember', abstract_syntax_type='ParameterMembershiup', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionReferenceArgument : Feature =', '    ownedRelationship += FunctionReferenceArgumentValue'], name='FunctionReferenceArgument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionReferenceArgumentValue : FeatureValue =', '    value = FunctionReferenceExpression'], name='FunctionReferenceArgumentValue', abstract_syntax_type='FeatureValue', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionReferenceExpression : FeatureReferenceExpression =', '    ownedRelationship += FunctionReferenceMember'], name='FunctionReferenceExpression', abstract_syntax_type='FeatureReferenceExpression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionReferenceMember : FeatureMembership =', '    ownedMemberFeature = FunctionReference'], name='FunctionReferenceMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FunctionReference : Expression =', '    ownedRelationship += ReferenceTyping'], name='FunctionReference', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['FeatureChainMember : Membership =', '      FeatureReferenceMember', '    | OwnedFeatureChainMember'], name='FeatureChainMember', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.5.8.2', lines=['OwnedFeatureChainMember : OwningMembership =', '    ownedMemberElement = FeatureChain'], name='OwnedFeatureChainMember', abstract_syntax_type='OwningMembership', is_partial=False)
NoteList(clause_id='8.2.5.8.2', lines=['  1. Primary expressions provide additional shorthand notations for certain kinds of InvocationExpressions. For those cases in which the InvocationExpression is an OperatorExpression, its operator shall be resolved to the appropriate library function as given in Table 7. Note also that, for a CollectionExpression or SelectExpression, the abstract syntax constrains the operator to be collect and select, respectively, separately from the. and.? symbols used in their concrete syntax notation (see 8.3.4.8.2 and 8.3.4.8.18 ).', "  2. The grammar allows a bracket syntax [... ] that parses to an invocation of the library Function Base Functions::'[', as shown in Table 7. This notation is available for use with domain-specific library models that given a concrete definition to the abstract base '[' Function, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this operator is used."], html_snippets=[<ol> <li>Primary expressions provide additional shorthand notations for certain kinds of <code>InvocationExpressions</code>. For those cases in which the <code>InvocationExpression</code> is an <code>OperatorExpression</code>, its <code>operator</code> shall be resolved to the appropriate library function as given in Table 7. Note also that, for a <code>CollectionExpression</code> or <code>SelectExpression</code>, the abstract syntax constrains the <code>operator</code> to be <em><code>collect</code></em> and <em><code>select</code></em>, respectively, separately from the <code>.</code> and <code>.?</code> symbols used in their concrete syntax notation (see 8.3.4.8.2 and 8.3.4.8.18).</li> <li>The grammar allows a bracket syntax <code>[</code>...<code>]</code>that parses to an invocation of the library <code>Function</code> <code><em>Base</em></code><em><code>Functions::'['</code>,</em> as shown in Table 7. This notation is available for use with domain-specific library models that given a concrete definition to the abstract base <code>'['</code> <code>Function</code>, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this operator is used.</li>
</ol>])
Heading(clause_id='8.2.5.8.3', lines=['Clause 8.2.5.8.3 Base Expressions'])
Production(clause_id='8.2.5.8.3', lines=['BaseExpression : Expression =', '      NullExpression', '    | LiteralExpression', '    | FeatureReferenceExpression', '    | MetadataAccessExpression', '    | InvocationExpression', '    | ConstructorExpression', '    | BodyExpression'], name='BaseExpression', abstract_syntax_type='Expression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['NullExpression : NullExpression =', "    'null' | '(' ')'"], name='NullExpression', abstract_syntax_type='NullExpression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['FeatureReferenceExpression : FeatureReferenceExpression =', '    ownedRelationship += FeatureReferenceMember', '    ownedRelationship += EmptyResultMember'], name='FeatureReferenceExpression', abstract_syntax_type='FeatureReferenceExpression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['FeatureReferenceMember : Membership =', '    memberElement = FeatureReference'], name='FeatureReferenceMember', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['FeatureReference : Feature =', '    [QualifiedName]'], name='FeatureReference', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['MetadataAccessExpression =', "    ownedRelationship += ElementReferenceMember '.' 'metadata'"], name='MetadataAccessExpression', abstract_syntax_type='MetadataAccessExpression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ElementReferenceMember : Membership =', '    memberElement = [QualifiedName]'], name='ElementReferenceMember', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['InvocationExpression : InvocationExpression =', '    ownedRelationship += InstatiatedTypeMember', '    ArgumentList', '    ownedRelationship += EmptyResultMember'], name='InvocationExpression', abstract_syntax_type='InvocationExpression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ConstructorExpression =', "    'new' ownedRelationship += InstantiatedTypeMember", '    ownedRelationship += ConstructorResultMember'], name='ConstructorExpression', abstract_syntax_type='ConstructorExpression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ConstructorResultMember : ReturnParameterMembership =', '    ownedRelatedElement += ConstructorResult'], name='ConstructorResultMember', abstract_syntax_type='ReturnParameterMembership', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ConstructorResult : Feature =', '    ArgumentList'], name='ConstructorResult', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['InstantiatedTypeMember : Membership =', '      memberElement = InstantiatedTypeReference', '    | OwnedFeatureChainMember'], name='InstantiatedTypeMember', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['InstantiatedTypeReference : Type =', '    [QualifiedName]'], name='InstantiatedTypeReference', abstract_syntax_type='Type', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ArgumentList : Feature =', "    '(' ( PositionalArgumentList | NamedArgumentList )? ')'"], name='ArgumentList', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['PositionalArgumentList : Feature =', '    e.ownedRelationship += ArgumentMember', "    ( ',' e.ownedRelationship += ArgumentMember )*"], name='PositionalArgumentList', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['NamedArgumentList : Feature =', '    ownedRelationship += NamedArgumentMember', "    ( ',' ownedRelationship += NamedArgumentMember )*"], name='NamedArgumentList', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['NamedArgumentMember : FeatureMembership =', '    ownedMemberFeature = NamedArgument'], name='NamedArgumentMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['NamedArgument : Feature =', "    ownedRelationship += ParameterRedefinition '='", '    ownedRelationship += ArgumentValue'], name='NamedArgument', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ParameterRedefinition : Redefinition =', '    redefinedFeature = [QualifiedName]'], name='ParameterRedefinition', abstract_syntax_type='Redefinition', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['BodyExpression : FeatureReferenceExpression =', '    ownedRelationship += ExpressionBodyMember'], name='BodyExpression', abstract_syntax_type='FeatureReferenceExpression', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ExpressionBodyMember : FeatureMembership =', '    ownedMemberFeature = ExpressionBody'], name='ExpressionBodyMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.8.3', lines=['ExpressionBody : Expression =', "    '{' FunctionBodyPart '}'"], name='ExpressionBody', abstract_syntax_type='Expression', is_partial=False)
Heading(clause_id='8.2.5.8.4', lines=['Clause 8.2.5.8.4 Literal Expressions'])
Production(clause_id='8.2.5.8.4', lines=['LiteralExpression =', '      LiteralBoolean', '    | LiteralString', '    | LiteralInteger', '    | LiteralReal', '    | LiteralInfinity'], name='LiteralExpression', abstract_syntax_type='LiteralExpression', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['LiteralBoolean =', '    value = BooleanValue'], name='LiteralBoolean', abstract_syntax_type='LiteralBoolean', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['BooleanValue : Boolean =', "    'true' | 'false'"], name='BooleanValue', abstract_syntax_type='Boolean', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['LiteralString =', '    value = STRING_VALUE'], name='LiteralString', abstract_syntax_type='LiteralString', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['LiteralInteger =', '    value = DECIMAL_VALUE'], name='LiteralInteger', abstract_syntax_type='LiteralInteger', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['LiteralReal =', '    value = RealValue'], name='LiteralReal', abstract_syntax_type='LiteralReal', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['RealValue : Real =', "      DECIMAL_VALUE? '.' ( DECIMAL_VALUE | EXPONENTIAL_VALUE )", '    | EXPONENTIAL_VALUE'], name='RealValue', abstract_syntax_type='Real', is_partial=False)
Production(clause_id='8.2.5.8.4', lines=['LiteralInfinity =', "    '*'"], name='LiteralInfinity', abstract_syntax_type='LiteralInfinity', is_partial=False)
Heading(clause_id='8.2.5.9', lines=['Clause 8.2.5.9 Interactions Concrete Syntax'])
Heading(clause_id='8.2.5.9.1', lines=['Clause 8.2.5.9.1 Interactions'])
Production(clause_id='8.2.5.9.1', lines=['Interaction =', "    TypePrefix 'interaction'", '    ClassifierDeclaration TypeBody'], name='Interaction', abstract_syntax_type='Interaction', is_partial=False)
Heading(clause_id='8.2.5.9.2', lines=['Clause 8.2.5.9.2 Flows'])
Production(clause_id='8.2.5.9.2', lines=['Flow =', "    FeaturePrefix 'flow'", '    ItemFlowDeclaration TypeBody'], name='Flow', abstract_syntax_type='Flow', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['SuccessionFlow =', "    FeaturePrefix 'succession' 'flow'", '    ItemFlowDeclaration TypeBody'], name='SuccessionFlow', abstract_syntax_type='SuccessionFlow', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['FlowDeclaration : Flow =', '      FeatureDeclaration ValuePart?', "      ( 'of' ownedRelationship += PayloadFeatureMember )?", "      ( 'from' ownedRelationship += FlowEndMember", "        'to' ownedRelationship += FlowEndMember )?", "    | ( isSufficient ?= 'all' )?", "      ownedRelationship += FlowEndMember 'to'", '      ownedRelationship += FlowEndMember'], name='FlowDeclaration', abstract_syntax_type='Flow', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['PayloadFeatureMember : FeatureMembership =', '    ownedRelatedElement = PayloadFeature'], name='PayloadFeatureMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['PayloadFeature =', '      Identification PayloadFeatureSpecializationPart ValuePart?', '    | Identification ValuePart', '    | ( ownedRelationship += OwnedFeatureTyping', '      ( ownedRelationship += OwnedMultiplicity )?', '    | ownedRelationship += OwnedMultiplicity', '      ( ownedRelationship += OwnedFeatureTyping )?'], name='PayloadFeature', abstract_syntax_type='PayloadFeature', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['PayloadFeatureSpecializationPart : Feature =', '      FeatureSpecialization+ MultiplicityPart?', '      FeatureSpecialization*', '    | MultiplicityPart FeatureSpecialization+'], name='PayloadFeatureSpecializationPart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['FlowEndMember : EndFeatureMembership =', '    ownedRelatedElement += FlowEnd'], name='FlowEndMember', abstract_syntax_type='EndFeatureMembership', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['FlowEnd =', "    ( ownedRelationship += OwnedReferenceSubsetting '.' )?", '    ownedRelationship += FlowFeatureMember'], name='FlowEnd', abstract_syntax_type='FlowEnd', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['FlowFeatureMember : FeatureMembership =', '    ownedRelatedElement += FlowFeature'], name='FlowFeatureMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.9.2', lines=['FlowFeature : Feature =', '    ownedRelationship += FlowFeatureRedefinition'], name='FlowFeature', abstract_syntax_type='Feature', is_partial=False)
NoteRef(clause_id='8.2.5.9.2', lines=['(See Note 1)'])
Production(clause_id='8.2.5.9.2', lines=['FlowFeatureRedefinition : Redefinition =', '    redefinedFeature = [QualifiedName]'], name='FlowFeatureRedefinition', abstract_syntax_type='Redefinition', is_partial=False)
NoteList(clause_id='8.2.5.9.2', lines=['  1. To ensure that an FlowFeature passes the validateRedefinitionDirectionConformance constraint (see 8.3.3.3.8 ), its direction must be set to the direction of its redefinedFeature, relative to its owning FlowEnd, that is, the result of the following OCL expression: owningType.directionOf(ownedRedefinition->at(1).redefinedFeature)'], html_snippets=[<ol> <li>To ensure that an <code>FlowFeature</code> passes the <code>validateRedefinitionDirectionConformance</code> constraint (see 8.3.3.3.8), its <code>direction</code> must be set to the direction of its <code>redefinedFeature</code>, relative to its owning <code>FlowEnd</code>, that is, the result of the following OCL expression:

	<code>owningType.directionOf(ownedRedefinition-&gt;at(1).redefinedFeature)</code> </li>
</ol>])
Heading(clause_id='8.2.5.10', lines=['Clause 8.2.5.10 Feature Values Concrete Syntax'])
Production(clause_id='8.2.5.10', lines=['ValuePart : Feature =', '    ownedRelationship += FeatureValue'], name='ValuePart', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.10', lines=['FeatureValue =', "    ( '='", "    | isInitial ?= ':='", "    | isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?", '    )', '    ownedRelatedElement += OwnedExpression'], name='FeatureValue', abstract_syntax_type='FeatureValue', is_partial=False)
Heading(clause_id='8.2.5.11', lines=['Clause 8.2.5.11 Multiplicities Concrete Syntax'])
Production(clause_id='8.2.5.11', lines=['Multiplicity =', '    MultiplicitySubset | MultiplicityRange'], name='Multiplicity', abstract_syntax_type='Multiplicity', is_partial=False)
Production(clause_id='8.2.5.11', lines=['MultiplicitySubset : Multiplicity =', "    'multiplicity' Identification Subsets", '    TypeBody'], name='MultiplicitySubset', abstract_syntax_type='Multiplicity', is_partial=False)
Production(clause_id='8.2.5.11', lines=['MultiplicityRange =', "    'multiplicity' Identification MultiplicityBounds", '    TypeBody'], name='MultiplicityRange', abstract_syntax_type='MultiplicityRange', is_partial=False)
Production(clause_id='8.2.5.11', lines=['OwnedMultiplicity : OwningMembership =', '    ownedRelatedElement += OwnedMultiplicityRange'], name='OwnedMultiplicity', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.5.11', lines=['OwnedMultiplicityRange : MultiplicityRange =', '    MultiplicityBounds'], name='OwnedMultiplicityRange', abstract_syntax_type='MultiplicityRange', is_partial=False)
Production(clause_id='8.2.5.11', lines=['MultiplicityBounds : MultiplicityRange =', "    '[' ( ownedRelationship += MultiplicityExpressionMember '..' )?", "          ownedRelationship += MultiplicityExpressionMember ']'"], name='MultiplicityBounds', abstract_syntax_type='MultiplicityRange', is_partial=False)
Production(clause_id='8.2.5.11', lines=['MultiplicityExpressionMember : OwningMembership =', '    ownedRelatedElement += ( LiteralExpression | FeatureReferenceExpression )'], name='MultiplicityExpressionMember', abstract_syntax_type='OwningMembership', is_partial=False)
Heading(clause_id='8.2.5.12', lines=['Clause 8.2.5.12 Metadata Concrete Syntax'])
Production(clause_id='8.2.5.12', lines=['Metaclass =', "    TypePrefix 'metaclass'", '    ClassifierDeclaration TypeBody'], name='Metaclass', abstract_syntax_type='Metaclass', is_partial=False)
Production(clause_id='8.2.5.12', lines=['PrefixMetadataAnnotation : Annotation =', "    '#' ownedRelatedElement += PrefixMetadataFeature"], name='PrefixMetadataAnnotation', abstract_syntax_type='Annotation', is_partial=False)
Production(clause_id='8.2.5.12', lines=['PrefixMetadataMember : OwningMembership =', "    '#' ownedRelatedElement += PrefixMetadataFeature"], name='PrefixMetadataMember', abstract_syntax_type='OwningMembership', is_partial=False)
Production(clause_id='8.2.5.12', lines=['PrefixMetadataFeature : MetadataFeature :', '    ownedRelationship += OwnedFeatureTyping'], name='PrefixMetadataFeature', abstract_syntax_type='MetadataFeature :', is_partial=False)
Production(clause_id='8.2.5.12', lines=['MetadataFeature =', '    ( ownedRelationship += PrefixMetadataMember )*', "    ( '@' | 'metadata' )", '    MetadataFeatureDeclaration', "    ( 'about' ownedRelationship += Annotation", "      ( ',' ownedRelationship += Annotation )*", '    )?', '    MetadataBody'], name='MetadataFeature', abstract_syntax_type='MetadataFeature', is_partial=False)
Production(clause_id='8.2.5.12', lines=['MetadataFeatureDeclaration : MetadataFeature =', "    ( Identification ( ':' | 'typed' 'by' ) )?", '    ownedRelationship += OwnedFeatureTyping'], name='MetadataFeatureDeclaration', abstract_syntax_type='MetadataFeature', is_partial=False)
Production(clause_id='8.2.5.12', lines=['MetadataBody : Feature =', "    ';' | '{' ( ownedRelationship += MetadataBodyElement )* '}'"], name='MetadataBody', abstract_syntax_type='Feature', is_partial=False)
Production(clause_id='8.2.5.12', lines=['MetadataBodyElement : Membership =', '      NonFeatureMember', '    | MetadataBodyFeatureMember', '    | AliasMember', '    | Import'], name='MetadataBodyElement', abstract_syntax_type='Membership', is_partial=False)
Production(clause_id='8.2.5.12', lines=['MetadataBodyFeatureMember : FeatureMembership =', '    ownedMemberFeature = MetadataBodyFeature'], name='MetadataBodyFeatureMember', abstract_syntax_type='FeatureMembership', is_partial=False)
Production(clause_id='8.2.5.12', lines=['MetadataBodyFeature : Feature =', "    'feature'? ( ':>>' | 'redefines')? ownedRelationship += OwnedRedefinition", '    FeatureSpecializationPart? ValuePart?', '    MetadataBody'], name='MetadataBodyFeature', abstract_syntax_type='Feature', is_partial=False)
Heading(clause_id='8.2.5.13', lines=['Clause 8.2.5.13 Packages Concrete Syntax'])
Production(clause_id='8.2.5.13', lines=['Package =', '    ( ownedRelationship += PrefixMetadataMember )*', '    PackageDeclaration PackageBody'], name='Package', abstract_syntax_type='Package', is_partial=False)
Production(clause_id='8.2.5.13', lines=['LibraryPackage =', "    ( isStandard ?= 'standard' ) 'library'", '    ( ownedRelationship += PrefixMetadataMember )*', '    PackageDeclaration PackageBody'], name='LibraryPackage', abstract_syntax_type='LibraryPackage', is_partial=False)
Production(clause_id='8.2.5.13', lines=['PackageDeclaration : Package =', "    'package' Identification"], name='PackageDeclaration', abstract_syntax_type='Package', is_partial=False)
Production(clause_id='8.2.5.13', lines=['PackageBody : Package =', "      ';'", "    | '{' ( NamespaceBodyElement", '          | ownedRelationship += ElementFilterMember', '          )*', "      '}'"], name='PackageBody', abstract_syntax_type='Package', is_partial=False)
Production(clause_id='8.2.5.13', lines=['ElementFilterMember : ElementFilterMembership =', '    MemberPrefix', "    'filter' condition = OwnedExpression ';'"], name='ElementFilterMember', abstract_syntax_type='ElementFilterMembership', is_partial=False)
