package ControlFunctions {
	import Base::*;
	import ScalarValues::*;
	
	abstract function '?'(test: Boolean): Anything[0..*] {
		abstract expr 'then'[0..1] (): Anything[0..*];
		abstract expr else[0..1] (): Anything[0..*];
	}
	
	abstract function '??'(first: Anything[0..*]) {
		abstract expr second[0..1] (): Anything[0..*];
	}
	
	abstract function '&&'(first: Boolean): Boolean {
		abstract expr second[0..1] ():Boolean;
	}
	
	abstract function '||'(first: Boolean): Boolean {
		abstract expr second[0..1] ():Boolean;
	}
	
	abstract function while('initial': Anything[0..*]): Anything[0..*] {
		abstract expr condition[1..*] (argument: Anything[0..*]): Boolean;
		abstract expr body[0..*] (argument: Anything[0..*]): Anything[0..*];
	}
	
	abstract function collect(collection: Anything[0..*]): Anything[0..*] {
		abstract expr mapper[0..*] (argument: Anything[1]): Anything[0..*];
	}
	
	abstract function select(collection: Anything[0..*]): Anything[0..*] {
		abstract expr selector[0..*] (argument: Anything[1]): Boolean;
	}
	
	abstract function reject(collection: Anything[0..*]): Anything[0..*] {
		abstract expr rejector[0..*] (argument: Anything[1]): Boolean;
	}
	
	abstract function reduce(collection: Anything[0..*]): Anything[0..*] {
		abstract expr reducer[0..*] (first: Anything[1], second: Anything[1]): Anything[1];
	}
	
	abstract function forAll(collection: Anything[0..*]): Boolean {
		abstract expr test[0..*] (argument: Anything[1]): Boolean;
	}
	
	abstract function exists(collection: Anything[0..*]): Boolean {
		abstract expr test[0..*] (argument: Anything[1]): Boolean;
	}
	
}