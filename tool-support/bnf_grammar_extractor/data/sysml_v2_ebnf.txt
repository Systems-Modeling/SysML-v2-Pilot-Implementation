// Source document: data/Part 2 - Systems Modeling Language (SysML)-r2025-02--2025-03-19-source.html

// Generated by ebnf_extractor at: 2025-06-09T22:45:34Z

// Clause 8.2.2 Textual Notation

// Clause 8.2.2.1 Textual Notation Overview

// Clause 8.2.2.1.1 EBNF Conventions

// Clause 8.2.2.1.2 Lexical Structure

// RESERVED_KEYWORD =
//       'about'
//     | 'abstract'
//     | 'accept'
//     | 'action'
//     | 'actor'
//     | 'after'
//     | 'alias'
//     | 'all'
//     | 'allocate'
//     | 'allocation'
//     | 'analysis'
//     | 'and'
//     | 'as'
//     | 'assert'
//     | 'assign'
//     | 'assoc'
//     | 'assume'
//     | 'at'
//     | 'attribute'
//     | 'bind'
//     | 'binding'
//     | 'block'
//     | 'by'
//     | 'calc'
//     | 'case'
//     | 'comment'
//     | 'concern'
//     | 'connect'
//     | 'connection'
//     | 'constraint'
//     | 'crosses'
//     | 'decide'
//     | 'def'
//     | 'default'
//     | 'defined'
//     | 'dependency'
//     | 'derived'
//     | 'do'
//     | 'doc'
//     | 'else'
//     | 'end'
//     | 'entry'
//     | 'enum'
//     | 'event'
//     | 'exhibit'
//     | 'exit'
//     | 'expose'
//     | 'filter'
//     | 'first'
//     | 'flow'
//     | 'for'
//     | 'fork'
//     | 'frame'
//     | 'from'
//     | 'hastype'
//     | 'if'
//     | 'implies'
//     | 'import'
//     | 'in'
//     | 'include'
//     | 'individual'
//     | 'inout'
//     | 'interface'
//     | 'istype'
//     | 'item'
//     | 'join'
//     | 'language'
//     | 'loop'
//     | 'merge'
//     | 'message'
//     | 'metadata'
//     | 'nonunique'
//     | 'not'
//     | 'objective'
//     | 'occurrence'
//     | 'of'
//     | 'or'
//     | 'ordered'
//     | 'out'
//     | 'package'
//     | 'parallel'
//     | 'part'
//     | 'perform'
//     | 'port'
//     | 'private'
//     | 'protected'
//     | 'public'
//     | 'readonly'
//     | 'redefines'
//     | 'ref'
//     | 'references'
//     | 'render'
//     | 'rendering'
//     | 'rep'
//     | 'require'
//     | 'requirement'
//     | 'return'
//     | 'satisfy'
//     | 'send'
//     | 'snapshot'
//     | 'specializes'
//     | 'stakeholder'
//     | 'state'
//     | 'subject'
//     | 'subsets'
//     | 'succession'
//     | 'terminate'
//     | 'then'
//     | 'timeslice'
//     | 'to'
//     | 'transition'
//     | 'until'
//     | 'use'
//     | 'variant'
//     | 'variation'
//     | 'verification'
//     | 'verify'
//     | 'via'
//     | 'view'
//     | 'viewpoint'
//     | 'when'
//     | 'while'
//     | 'xor'

DEFINED_BY  = ':'   | 'defined' 'by'
SPECIALIZES = ':>'  | 'specializes'
SUBSETS     = ':>'  | 'subsets'
REFERENCES  = '::>' | 'references'
CROSSES     = '=>'  | 'crosses'
REDEFINES   = ':>>' | 'redefines'

// Clause 8.2.2.2 Elements and Relationships Textual Notation

Identification : Element =
    ( '<' declaredShortName = NAME '>' )? 
    ( declaredName = NAME )?

RelationshipBody : Relationship =
    ';' | '{' ( ownedRelationship += OwnedAnnotation )* '}'

// Clause 8.2.2.3 Dependencies Textual Notation

Dependency =
    ( ownedRelationship += PrefixMetadataAnnotation )*
    'dependency' DependencyDeclaration
    RelationshipBody

DependencyDeclaration =
    ( Identification 'from' )?
    client += [QualifiedName] ( ',' client += [QualifiedName] )* 'to'
    supplier += [QualifiedName] ( ',' supplier += [QualifiedName] )*

// Clause 8.2.2.4 Annotations Textual Notation

// Clause 8.2.2.4.1 Annotations

Annotation =
    annotatedElement = [QualifiedName]

OwnedAnnotation : Annotation =
    ownedRelatedElement += AnnotatingElement

AnnotatingMember : OwningMembership =
    ownedRelatedElement += AnnotatingElement

AnnotatingElement =
      Comment
    | Documentation
    | TextualRepresentation
    | MetadataFeature

// Clause 8.2.2.4.2 Comments and Documentation

Comment =
    ( 'comment' Identification
      ( 'about' ownedRelationship += Annotation
        ( ',' ownedRelationship += Annotation )*
      )?
    )?
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT

Documentation =
    'doc' Identification
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT

// Clause 8.2.2.4.3 Textual Representation

TextualRepresentation =
    ( 'rep' Identification )?
    'language' language = STRING_VALUE body = REGULAR_COMMENT

// Clause 8.2.2.5 Namespaces and Packages Textual Notation

// Clause 8.2.2.5.1 Packages

RootNamespace : Namespace =
    PackageBodyElement*

Package =
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody

LibraryPackage =
    ( isStandard ?= 'standard' ) 'library'
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody

PackageDeclaration : Package =
    'package' Identification

PackageBody : Package =
    ';' | '{' PackageBodyElement* '}'

PackageBodyElement : Package =
      ownedRelationship += PackageMember
    | ownedRelationship += ElementFilterMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

MemberPrefix : Membership =
    ( visibility = VisibilityIndicator )?
    
PackageMember : OwningMembership
    MemberPrefix
    ( ownedRelatedElement += DefinitionElement
    | ownedRelatedElement = UsageElement )

ElementFilterMember : ElementFilterMembership =
    MemberPrefix
    'filter' ownedRelatedElement += OwnedExpression ';'

AliasMember : Membership =
    MemberPrefix
    'alias' ( '<' memberShortName = NAME '>' )?
    ( memberName = NAME )?
     'for' memberElement = [QualifiedName]
    RelationshipBody

Import =
    visibility = VisibilityIndicator
    'import' ( isImportAll ?= 'all' )?
    ImportDeclaration
    RelationshipBody

ImportDeclaration : Import =
    MembershipImport | NamespaceImport

MembershipImport =
    importedMembership = [QualifiedName]
    ( '::' isRecursive ?= '**' )?

NamespaceImport =
      importedNamespace = [QualifiedName] '::' '*'
      ( '::' isRecursive ?= '**' )?
    | importedNamspace = FilterPackage
      { ownedRelatedElement += importedNamespace }

FilterPackage : Package =
    ownedRelationship += FilterPackageImport
    ( ownedRelationship += FilterPackageMember )+

FilterPackageMember : ElementFilterMembership =
    '[' ownedRelatedElement += OwnedExpression ']'

VisibilityIndicator : VisibilityKind =
    'public' | 'private' | 'protected'

// Clause 8.2.2.5.2 Package Elements

DefinitionElement : Element =
      Package
    | LibraryPackage
    | AnnotatingElement
    | Dependency
    | AttributeDefinition
    | EnumerationDefinition
    | OccurrenceDefinition
    | IndividualDefinition
    | ItemDefinition
    | PartDefinition
    | ConnectionDefinition
    | FlowDefinition
    | InterfaceDefinition
    | PortDefinition
    | ActionDefinition
    | CalculationDefinition
    | StateDefinition
    | ConstraintDefinition
    | RequirementDefinition
    | ConcernDefinition
    | CaseDefinition
    | AnalysisCaseDefinition
    | VerificationCaseDefinition
    | UseCaseDefinition
    | ViewDefinition
    | ViewpointDefinition
    | RenderingDefinition
    | MetadataDefinition
    | ExtendedDefinition
    
UsageElement : Usage =
      NonOccurrenceUsageElement
    | OccurrenceUsageElement

// Clause 8.2.2.6 Definition and Usage Textual Notation

// Clause 8.2.2.6.1 Definitions

BasicDefinitionPrefix =
    isAbstract ?= 'abstract' | isVariation ?= 'variation'

DefinitionExtensionKeyword : Definition =
    ownedRelationship += PrefixMetadataMember

DefinitionPrefix : Definition =
    BasicDefinitionPrefix? DefinitionExtensionKeyword*

Definition =
    DefinitionDeclaration DefinitionBody

DefinitionDeclaration : Definition
    Identification SubclassificationPart?

DefinitionBody : Type =
      ';' | '{' DefinitionBodyItem* '}'

DefinitionBodyItem : Type =
      ownedRelationship += DefinitionMember
    | ownedRelationship += VariantUsageMember
    | ownedRelationship += NonOccurrenceUsageMember
    | ( ownedRelationship += SourceSuccessionMember )?
      ownedRelationship += OccurrenceUsageMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

DefinitionMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += DefinitionElement

VariantUsageMember : VariantMembership =
    MemberPrefix 'variant'
    ownedVariantUsage = VariantUsageElement

NonOccurrenceUsageMember : FeatureMembership =
    MemberPrefix
    ownedRelatedElement += NonOccurrenceUsageElement

OccurrenceUsageMember : FeatureMembership =
    MemberPrefix
    ownedRelatedElement += OccurrenceUsageElement

StructureUsageMember : FeatureMembership =
    MemberPrefix
    ownedRelatedElement += StructureUsageElement

BehaviorUsageMember : FeatureMembership =
    MemberPrefix
    ownedRelatedElement += BehaviorUsageElement

// Clause 8.2.2.6.2 Usages

FeatureDirection : FeatureDirectionKind =
    'in' | 'out' | 'inout'

RefPrefix : Usage =
    ( direction = FeatureDirection )?
    ( isDerived ?= 'derived' )?
    ( isVariation ?= 'variation'
    | isConstant ?= 'constant'
    | isAbstract ?= 'abstract' ( isConstant ?= 'constant' )?
    )?

BasicUsagePrefix : Usage =
    RefPrefix
    ( isReference ?= 'ref' )?

EndUsagePrefix : Usage =
    isEnd ?= 'end' ( ownedRelationship += OwnedCrossFeatureMember )?

// (See Note 1)

OwnedCrossFeatureMember : OwningMembership =
    ownedRelatedElement += OwnedCrossFeature

OwnedCrossFeature : ReferenceUsage =
    BasicUsagePrefix UsageDeclaration

UsageExtensionKeyword : Usage =
    ownedRelationship += PrefixMetadataMember

UnextendedUsagePrefix : Usage =
    EndUsagePrefix | BasicUsagePrefix

UsagePrefix : Usage
    UnextendedUsagePrefix UsageExtensionKeyword*

Usage =
    UsageDeclaration UsageCompletion

UsageDeclaration : Usage =
    Identification FeatureSpecializationPart?

UsageCompletion : Usage =
    ValuePart? UsageBody

UsageBody : Usage =
    DefinitionBody

ValuePart : Feature =
    ownedRelationship += FeatureValue

FeatureValue =
    ( '='
    | isInitial ?= ':='
    | isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?
    )
    ownedRelatedElement += OwnedExpression


// Note 1: A Usage parsed with isEnd = true for which mayTimeVary = true must also have isConstant set to true, even though this is not explicitly notated in the textual notation, in order to satisfy the KerML constraint checkFeatureEndIsConstant.

// Clause 8.2.2.6.3 Reference Usages

DefaultReferenceUsage : ReferenceUsage =
    RefPrefix Usage

ReferenceUsage =
    ( EndUsagePrefix | RefPrefix )
    'ref' Usage

VariantReference : ReferenceUsage =
    ownedRelationship += OwnedReferenceSubsetting
    FeatureSpecialization* UsageBody

// Clause 8.2.2.6.4 Body Elements

NonOccurrenceUsageElement : Usage =
      DefaultReferenceUsage
    | ReferenceUsage
    | AttributeUsage
    | EnumerationUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage
    | ExtendedUsage

OccurrenceUsageElement : Usage =
    StructureUsageElement | BehaviorUsageElement

StructureUsageElement : Usage =
      OccurrenceUsage
    | IndividualUsage
    | PortionUsage
    | EventOccurrenceUsage
    | ItemUsage
    | PartUsage
    | ViewUsage
    | RenderingUsage
    | PortUsage
    | ConnectionUsage
    | InterfaceUsage
    | AllocationUsage
    | Message
    | FlowUsage
    | SuccessionFlowUsage

BehaviorUsageElement : Usage =
      ActionUsage
    | CalculationUsage
    | StateUsage
    | ConstraintUsage
    | RequirementUsage
    | ConcernUsage
    | CaseUsage
    | AnalysisCaseUsage
    | VerificationCaseUsage
    | UseCaseUsage
    | ViewpointUsage
    | PerformActionUsage
    | ExhibitStateUsage
    | IncludeUseCaseUsage
    | AssertConstraintUsage
    | SatisfyRequirementUsage

VariantUsageElement : Usage =
      VariantReference
    | ReferenceUsage
    | AttributeUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage
    | OccurrenceUsage
    | IndividualUsage
    | PortionUsage
    | EventOccurrenceUsage
    | ItemUsage
    | PartUsage
    | ViewUsage
    | RenderingUsage
    | PortUsage
    | ConnectionUsage
    | InterfaceUsage
    | AllocationUsage
    | Message
    | FlowUsage
    | SuccessionFlowUsage
    | BehaviorUsageElement

// Clause 8.2.2.6.5 Specialization

SubclassificationPart : Classifier =
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )*

OwnedSubclassification : Subclassification =
    superClassifier = [QualifiedName]

FeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization*

FeatureSpecialization : Feature =
    Typings | Subsettings | References | Crosses | Redefinitions

Typings : Feature =
      TypedBy ( ',' ownedRelationship += FeatureTyping )*

TypedBy : Feature =
    DEFINED_BY ownedRelationship += FeatureTyping

FeatureTyping =
    OwnedFeatureTyping | ConjugatedPortTyping

OwnedFeatureTyping : FeatureTyping =
      type = [QualifiedName]
    | type = OwnedFeatureChain
      { ownedRelatedElement += type }

Subsettings : Feature =
    Subsets ( ',' ownedRelationship += OwnedSubsetting )*

Subsets : Feature =
    SUBSETS ownedRelationship += OwnedSubsetting

OwnedSubsetting : Subsetting =
      subsettedFeature = [QualifiedName]
    | subsettedFeature = OwnedFeatureChain
      { ownedRelatedElement += subsettedFeature }

References : Feature =
    REFERENCES ownedRelationship += OwnedReferenceSubsetting

OwnedReferenceSubsetting : ReferenceSubsetting =
      referencedFeature = [QualifiedName]
    | referencedFeature = OwnedFeatureChain
      { ownedRelatedElement += referenceFeature }

Crosses : Feature =
    CROSSES ownedRelationship += OwnedCrossSubsetting

OwnedCrossSubsetting : CrossSubsetting =
      crossedFeature = [QualifiedName]
    | crossedFeature = OwnedFeatureChain
      { ownedRelatedElement += crossedFeature }

Redefinitions : Feature =
    Redefines ( ',' ownedRelationship += OwnedRedefinition )*

Redefines : Feature =
    REDEFINES ownedRelationship += OwnedRedefinition

OwnedRedefinition : Redefinition =
      redefinedFeature = [QualifiedName]
    | redefinedFeature = OwnedFeatureChain
      { ownedRelatedElement += redefinedFeature }

OwnedFeatureChain : Feature =
    ownedRelationship += OwnedFeatureChaining
    ( '.' ownedRelationship += OwnedFeatureChaining )+

OwnedFeatureChaining : FeatureChaining =
    chainingFeature = [QualifiedName]

// Clause 8.2.2.6.6 Multiplicity

MultiplicityPart : Feature =
      ownedRelationship += OwnedMultiplicity
    | ( ownedRelationship += OwnedMultiplicity )?
      ( isOrdered ?= 'ordered' ( { isUnique = false } 'nonunique' )?
      | { isUnique = false } 'nonunique' ( isOrdered ?= 'ordered' )? )

OwnedMultiplicity : OwningMembership =
    ownedRelatedElement += MultiplicityRange

MultiplicityRange =
    '[' ( ownedRelationship += MultiplicityExpressionMember '..' )?
          ownedRelationship += MultiplicityExpressionMember ']'

MultiplicityExpressionMember : OwningMembership =
    ownedRelatedElement += ( LiteralExpression | FeatureReferenceExpression )

// Clause 8.2.2.7 Attributes Textual Notation

AttributeDefinition : AttributeDefinition =
    DefinitionPrefix 'attribute' 'def' Definition

AttributeUsage : AttributeUsage =
    UsagePrefix 'attribute' Usage

// Clause 8.2.2.8 Enumerations Textual Notation

EnumerationDefinition =
    DefinitionExtensionKeyword*
    'enum' 'def' DefinitionDeclaration EnumerationBody

EnumerationBody : EnumerationDefinition =
      ';'
    | '{' ( ownedRelationship += AnnotatingMember
          | ownedRelationship += EnumerationUsageMember )*
      '}'

EnumerationUsageMember : VariantMembership =
    MemberPrefix ownedRelatedElement += EnumeratedValue

EnumeratedValue : EnumerationUsage =
    'enum'? Usage

EnumerationUsage : EnumerationUsage =
    UsagePrefix 'enum' Usage

// Clause 8.2.2.9 Occurrences Textual Notation

// Clause 8.2.2.9.1 Occurrence Definitions

OccurrenceDefinitionPrefix : OccurrenceDefinition =
    BasicDefinitionPrefix?
    ( isIndividual ?= 'individual' 
      ownedRelationship += EmptyMultiplicityMember
    )?
    DefinitionExtensionKeyword*

OccurrenceDefinition =
    OccurrenceDefinitionPrefix 'occurrence' 'def' Definition

IndividualDefinition : OccurrenceDefinition =
    BasicDefinitionPrefix? isIndividual ?= 'individual'
    DefinitionExtensionKeyword* 'def' Definition
    ownedRelationship += EmptyMultiplicityMember

EmptyMultiplicityMember : OwningMembership =
    ownedRelatedElement += EmptyMultiplicity

EmptyMultiplicity : Multiplicity =
    { }

// Clause 8.2.2.9.2 Occurrence Usages

OccurrenceUsagePrefix : OccurrenceUsage =
    BasicUsagePrefix
    ( isIndividual ?= 'individual' )?
    ( portionKind = PortionKind 
      { isPortion = true } 
    )?
    UsageExtensionKeyword*

OccurrenceUsage =
    OccurrenceUsagePrefix 'occurrence' Usage

IndividualUsage : OccurrenceUsage =
    BasicUsagePrefix isIndividual ?= 'individual'
    UsageExtensionKeyword* Usage

PortionUsage : OccurrenceUsage  =
    BasicUsagePrefix ( isIndividual ?= 'individual' )?
    portionKind = PortionKind
    UsageExtensionKeyword* Usage
    { isPortion = true }

PortionKind =
    'snapshot' | 'timeslice'

EventOccurrenceUsage =
    OccurrenceUsagePrefix 'event'
    ( ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
    | 'occurrence' UsageDeclaration? )
    UsageCompletion

// Clause 8.2.2.9.3 Occurrence Successions

SourceSuccessionMember  : FeatureMembership =
    'then' ownedRelatedElement += SourceSuccession

SourceSuccession : SuccessionAsUsage =
    ownedRelationship += SourceEndMember

SourceEndMember : EndFeatureMembership =
    ownedRelatedElement += SourceEnd

SourceEnd : ReferenceUsage =
    ( ownedRelationship += OwnedMultiplicity )?

// Clause 8.2.2.10 Items Textual Notation

ItemDefinition =
    OccurrenceDefinitionPrefix
    'item' 'def' Definition

ItemUsage =
    OccurrenceUsagePrefix 'item' Usage

// Clause 8.2.2.11 Parts Textual Notation

PartDefinition =
    OccurrenceDefinitionPrefix 'part' 'def' Definition

PartUsage =
    OccurrenceUsagePrefix 'part' Usage

// Clause 8.2.2.12 Ports Textual Notation

PortDefinition =
    DefinitionPrefix 'port' 'def' Definition
    ownedRelationship += ConjugatedPortDefinitionMember
    { conjugatedPortDefinition.ownedPortConjugator.
        originalPortDefinition = this }

// (See Note 1)

ConjugatedPortDefinitionMember : OwningMembership =
    ownedRelatedElement += ConjugatedPortDefinition

ConjugatedPortDefinition =
    ownedRelationship += PortConjugation

PortConjugation =
    {}

PortUsage =
    OccurrenceUsagePrefix 'port' Usage

ConjugatedPortTyping : ConjugatedPortTyping =
    '~' originalPortDefinition = ~[QualifiedName]

// (See Note 2)

// Note 1: Even though it is not explicitly represented in the text, a PortDefinition is always parsed as containing a nested ConjugatedPortDefinition with a PortDefinition Relationship pointing back to the containing PortDefinition. The abstract syntax for ConjugatedPortDefinition sets its effectiveName to the name of its originalPortDefinition with the symbol ~ prepended to it (see 8.3.12.2 ). (See also 8.4.8.1.)
// Note 2: The notation ~[QualifiedName] indicates that a QualifiedName shall be parsed from the input text, but that it shall be resolved as if it was the qualified name constructed as follows: Extract the last segment name of the given QualifiedName and prepend the symbol ~ to it. Append the name so constructed to the end of the entire original QualifiedName. For example, if the ConjugatedPortTyping is ~A::B::C, then the given QualifiedName is A::B::C, and ~[QualifiedName] is resolved as A::B::C::'~C'. Alternatively, a conforming tool may first resolve the given QualifiedName as usual to a PortDefinition and then use the conjugatedPortDefinition of this PortDefinition as the resolution of ~[QualifiedName ].

// Clause 8.2.2.13 Connections Textual Notation

// Clause 8.2.2.13.1 Connection Definition and Usage

ConnectionDefinition =
    OccurrenceDefinitionPrefix 'connection' 'def' Definition

ConnectionUsage =
    OccurrenceUsagePrefix
    ( 'connection' UsageDeclaration ValuePart?
      ( 'connect' ConnectorPart )?
    | 'connect' ConnectorPart )
    UsageBody

ConnectorPart : ConnectionUsage =
    BinaryConnectorPart | NaryConnectorPart

BinaryConnectorPart : ConnectionUsage =
    ownedRelationship += ConnectorEndMember 'to'
    ownedRelationship += ConnectorEndMember

NaryConnectorPart : ConnectionUsage =
    '(' ownedRelationship += ConnectorEndMember ','
        ownedRelationship += ConnectorEndMember
        ( ',' ownedRelationship += ConnectorEndMember )* ')'

ConnectorEndMember : EndFeatureMembership :
    ownedRelatedElement += ConnectorEnd

ConnectorEnd : ReferenceUsage =
	( ownedRelationship += OwnedCrossMultiplicityMember )?
	( declaredName = NAME REFERENCES )? 
	ownedRelationship += OwnedReferenceSubsetting

OwnedCrossMultiplicityMember : OwningMembership =
	ownedRelatedElement += OwnedCrossMultiplicity

OwnedCrossMultiplicity : Feature =
	ownedRelationship += OwnedMultiplicity

// Clause 8.2.2.13.2 Binding Connectors

BindingConnectorAsUsage =
    UsagePrefix ( 'binding' UsageDeclaration )?
    'bind' ownedRelationship += ConnectorEndMember
    '=' ownedRelationship += ConnectorEndMember
    UsageBody

// Clause 8.2.2.13.3 Successions

SuccessionAsUsage =
    UsagePrefix ( 'succession' UsageDeclaration )?
    'first' s.ownedRelationship += ConnectorEndMember
    'then' s.ownedRelationship += ConnectorEndMember
    UsageBody

// Clause 8.2.2.14 Interfaces Textual Notation

// Clause 8.2.2.14.1 Interface Definitions

InterfaceDefinition =
    OccurrenceDefinitionPrefix 'interface' 'def'
    DefinitionDeclaration InterfaceBody

InterfaceBody : Type =
    ';' | '{' InterfaceBodyItem* '}'

InterfaceBodyItem : Type =
      ownedRelationship += DefinitionMember
    | ownedRelationship += VariantUsageMember
    | ownedRelationship += InterfaceNonOccurrenceUsageMember
    | ( ownedRelationship += SourceSuccessionMember )?
      ownedRelationship += InterfaceOccurrenceUsageMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

InterfaceNonOccurrenceUsageMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += InterfaceNonOccurrenceUsageElement

InterfaceNonOccurrenceUsageElement : Usage =
      ReferenceUsage
    | AttributeUsage
    | EnumerationUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage

InterfaceOccurrenceUsageMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += InterfaceOccurrenceUsageElement

InterfaceOccurrenceUsageElement : Usage =
    DefaultInterfaceEnd | StructureUsageElement | BehaviorUsageElement

DefaultInterfaceEnd : PortUsage =
    isEnd ?= 'end' Usage

// Clause 8.2.2.14.2 Interface Usages

InterfaceUsage =
    OccurrenceUsagePrefix 'interface'
    InterfaceUsageDeclaration InterfaceBody

InterfaceUsageDeclaration : InterfaceUsage =
      UsageDeclaration ValuePart?
      ( 'connect' InterfacePart )?
    | InterfacePart

InterfacePart : InterfaceUsage =
    BinaryInterfacePart | NaryInterfacePart

BinaryInterfacePart : InterfaceUsage =
    ownedRelationship += InterfaceEndMember 'to'
    ownedRelationship += InterfaceEndMember

NaryInterfacePart : InterfaceUsage =
    '(' ownedRelationship += InterfaceEndMember ','
        ownedRelationship += InterfaceEndMember
        ( ',' ownedRelationship += InterfaceEndMember )* ')'

InterfaceEndMember : EndFeatureMembership =
    ownedRelatedElement += InterfaceEnd

InterfaceEnd : PortUsage :
    ( ownedRelationship += OwnedCrossMultiplicityMember )?
    ( declaredName = NAME REFERENCES )?
    ownedRelationship += OwnedReferenceSubsetting

// Clause 8.2.2.15 Allocations Textual Notation

AllocationDefinition =
    OccurrenceDefinitionPrefix 'allocation' 'def' Definition

AllocationUsage =
    OccurrenceUsagePrefix
    AllocationUsageDeclaration UsageBody

AllocationUsageDeclaration : AllocationUsage =
      'allocation' UsageDeclaration
      ( 'allocate' ConnectorPart )?
    | 'allocate' ConnectorPart

// Clause 8.2.2.16 Flows Textual Notation

FlowDefinition :
    OccurrenceDefinitionPrefix 'flow' 'def' Definition

Message : FlowUsage =
    OccurrenceUsagePrefix 'message'
    MessageDeclaration DefinitionBody
    { isAbstract = true }

MessageDeclaration : FlowUsage =
      UsageDeclaration ValuePart?
      ( 'of' ownedRelationship += FlowPayloadFeatureMember )?
      ( 'from' ownedRelationship += MessageEventMember
        'to' ownedRelationship += MessageEventMember
      )?
    | ownedRelationship += MessageEventMember 'to'
      ownedRelationship += MessageEventMember    

MessageEventMember : ParameterMembership =
    ownedRelatedElement += MessageEvent

MessageEvent : EventOccurrenceUsage =
    ownedRelationship += OwnedReferenceSubsetting

FlowUsage =
    OccurrenceUsagePrefix 'flow'
    FlowDeclaration DefinitionBody

SuccessionFlowUsage =
    OccurrenceUsagePrefix 'succession' 'flow'
    FlowDeclaration DefinitionBody

FlowDeclaration : FlowUsage =
      UsageDeclaration ValuePart?
      ( 'of'  ownedRelationship += FlowPayloadFeatureMember )?
      ( 'from' ownedRelationship += FlowEndMember 
        'to'   ownedRelationship += FlowEndMember )?
    | ownedRelationship += FlowEndMember 'to'
      ownedRelationship += FlowEndMember

FlowPayloadFeatureMember : FeatureMembership =
    ownedRelatedElement += FlowPayloadFeature

FlowPayloadFeature : PayloadFeature =
    PayloadFeature

PayloadFeature : Feature =
      Identification? PayloadFeatureSpecializationPart 
      ValuePart?
    | ownedRelationship += OwnedFeatureTyping 
      ( ownedRelationship += OwnedMultiplicity )?
    | ownedRelationship += OwnedMultiplicity 
      ownedRelationship += OwnedFeatureTyping

PayloadFeatureSpecializationPart : Feature =
      ( -> FeatureSpecialization )+ MultiplicityPart? 
      FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization+

FlowEndMember : EndFeatureMembership =
    ownedRelatedElement += FlowEnd

FlowEnd =
    ( ownedRelationship += FlowEndSubsetting )?
    ownedRelationship += FlowFeatureMember

FlowEndSubsetting : ReferenceSubsetting =
      referencedFeature = [QualifiedName]
    | referencedFeature = FeatureChainPrefix
      { ownedRelatedElement += referencedFeature }

FeatureChainPrefix : Feature =
    ( ownedRelationship += OwnedFeatureChaining '.' )+
    ownedRelationship += OwnedFeatureChaining '.'

FlowFeatureMember : FeatureMembership =
    ownedRelatedElement += FlowFeature

FlowFeature : ReferenceUsage =
    ownedRelationship += FlowFeatureRedefinition

// (See Note 1)

FlowFeatureRefefinition : Redefinition =
    redefinedFeature = [QualifiedName]


// Note 1: To ensure that a FlowFeature passes the validateRedefinitionDirectionConformance constraint (see [KerML, 8.3.3.3.8]), its direction must be set to the direction of its redefinedFeature, relative to its owning FlowEnd, that is, the result of the following OCL expression: owningType.directionOf(ownedRedefinition->at(1).redefinedFeature)

owningType.directionOf(ownedRedefinition->at(1).redefinedFeature)

// Clause 8.2.2.17 Actions Textual Notation

// Clause 8.2.2.17.1 Action Definitions

ActionDefinition =
    OccurrenceDefinitionPrefix 'action' 'def'
    DefinitionDeclaration ActionBody

ActionBody : Type =
    ';' | '{' ActionBodyItem* '}'

ActionBodyItem : Type =
      NonBehaviorBodyItem
    | ownedRelationship += InitialNodeMember
      ( ownedRelationship += ActionTargetSuccessionMember )*
    | ( ownedRelationship += SourceSuccessionMember )?
      ownedRelationsuip += ActionBehaviorMember
      ( ownedRelationship += ActionTargetSuccessionMember )*
    | ownedRelationship += GuardedSuccessionMember

NonBehaviorBodyItem =
      ownedRelationship += Import
    | ownedRelationship += AliasMember
    | ownedRelationship += DefinitionMember
    | ownedRelationship += VariantUsageMember
    | ownedRelationship += NonOccurrenceUsageMember
    | ( ownedRelationship += SourceSuccessionMember )?
      ownedRelationship += StructureUsageMember

ActionBehaviorMember : FeatureMembership =
    BehaviorUsageMember | ActionNodeMember

InitialNodeMember : FeatureMembership =
    MemberPrefix 'first' memberFeature = [QualifiedName]
    RelationshipBody

ActionNodeMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += ActionNode

ActionTargetSuccessionMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += ActionTargetSuccession

GuardedSuccessionMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += GuardedSuccession

// Clause 8.2.2.17.2 Action Usages

ActionUsage =
    OccurrenceUsagePrefix 'action'
    ActionUsageDeclaration ActionBody

ActionUsageDeclaration : ActionUsage =
    UsageDeclaration ValuePart?

PerformActionUsage =
    OccurrenceUsagePrefix 'perform'
    PerformActionUsageDeclaration ActionBody

PerformActionUsageDeclaration : PerformActionUsage =
    ( ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
    | 'action' UsageDeclaration )
    ValuePart?

ActionNode : ActionUsage =
      ControlNode
    | SendNode | AcceptNode
    | AssignmentNode
    | TerminateNode
    | IfNode | WhileLoopNode | ForLoopNode

ActionNodeUsageDeclaration : ActionUsage =
    'action' UsageDeclaration?

ActionNodePrefix : ActionUsage =
    OccurrenceUsagePrefix ActionNodeUsageDeclaration?

// Clause 8.2.2.17.3 Control Nodes

ControlNode =
    MergeNode | DecisionNode | JoinNode| ForkNode

ControlNodePrefix : OccurrenceUsage =
    RefPrefix
    ( isIndividual ?= 'individual )?
    ( portionKind = PortionKind 
      { isPortion = true }
    )?
    UsageExtensionKeyword*

MergeNode =
    ControlNodePrefix
    isComposite ?= 'merge' UsageDeclaration
    ActionBody

DecisionNode =
    ControlNodePrefix
    isComposite ?= 'decide' UsageDeclaration
    ActionBody

JoinNode =
    ControlNodePrefix
    isComposite ?= 'join' UsageDeclaration
    ActionBody

ForkNode =
    ControlNodePrefix
    isComposite ?= 'fork' UsageDeclaration
    ActionBody

// Clause 8.2.2.17.4 Send and Accept Action Usages

AcceptNode : AcceptActionUsage =
    OccurrenceUsagePrefix
    AcceptNodeDeclaration ActionBody

AcceptNodeDeclaration : AcceptActionUsage =
    ActionNodeUsageDeclaration?
    'accept' AcceptParameterPart

AcceptParameterPart : AcceptActionUsage =
    ownedRelationship += PayloadParameterMember
    ( 'via' ownedRelationship += NodeParameterMember )?

PayloadParameterMember : ParameterMembership =
    ownedRelatedElement += PayloadParameter

PayloadParameter : ReferenceUsage =
      PayloadFeature
    | Identification PayloadFeatureSpecializationPart?
      TriggerValuePart

TriggerValuePart : Feature =
    ownedRelationship += TriggerFeatureValue

TriggerFeatureValue : FeatureValue =
    ownedRelatedElement += TriggerExpression

TriggerExpression : TriggerInvocationExpression =
      kind = ( 'at | 'after' )
      ownedRelationship += ArgumentMember
    | kind = 'when'
      ownedRelationship += ArgumentExpressionMember

ArgumentMember : ParameterMembership =
    ownedMemberParameter = Argument

Argument : Feature =
    ownedRelationship += ArgumentValue

ArgumentValue : FeatureValue =
    value = OwnedExpression

ArgumentExpressionMember : ParameterMembership =
    ownedRelatedElement += ArgumentExpression

ArgumentExpression : Feature =
    ownedRelationship += ArgumentExpressionValue

ArgumentExpressionValue : FeatureValue =
    ownedRelatedElement += OwnedExpressionReference

SendNode : SendActionUsage =
    OccurrenceUsagePrefix ActionUsageDeclaration? 'send' 
    ( ownedRelationship += NodeParameterMember SenderReceiverPart?
    | ownedRelationship += EmptyParameterMember SendReceiverPart )?
    ActionBody

SendNodeDeclaration : SendActionUsage =
    ActionNodeUsageDeclaration?  'send' 
    ownedRelationship += NodeParameterMember SenderReceiverPart?

SenderReceiverPart : SendActionUsage =
      'via' ownedRelationship += NodeParameterMember
      ( 'to' ownedRelationship += NodeParameterMember )?
    | ownedRelationship += EmptyParameterMember
      'to' ownedRelationship += NodeParameterMember

NodeParameterMember : ParameterMembership =
    ownedRelatedElement += NodeParameter

NodeParameter : ReferenceUsage =
    ownedRelationship += FeatureBinding

FeatureBinding : FeatureValue =
    ownedRelatedElement += OwnedExpression

EmptyParameterMember : ParameterMembership =
    ownedRelatedElement += EmptyUsage

EmptyUsage : ReferenceUsage =
    {}

// Clause 8.2.2.17.5 Assignment Action Usages

AssignmentNode : AssignmentActionUsage =
    OccurrenceUsagePrefix
    AssignmentNodeDeclaration ActionBody

AssignmentNodeDeclaration: ActionUsage =
    ( ActionNodeUsageDeclaration )? 'assign'
    ownedRelationship += AssignmentTargetMember
    ownedRelationship += FeatureChainMember ':='
    ownedRelationship += NodeParameterMember

AssignmentTargetMember : ParameterMembership =
    ownedRelatedElement += AssignmentTargetParameter

AssignmentTargetParameter : ReferenceUsage =
    ( ownedRelationship += AssignmentTargetBinding '.' )?

AssignmentTargetBinding : FeatureValue =
    ownedRelatedElement += NonFeatureChainPrimaryExpression

FeatureChainMember : Membership =
      memberElement = [QualifiedName]
    | OwnedFeatureChainMember

OwnedFeatureChainMember : OwningMembership =
    ownedRelatedElement += OwnedFeatureChain

// Clause 8.2.2.17.6 Terminate Action Usages

TerminateNode : TerminateActionUsage =
    OccurrenceUsagePrefix ActionNodeUsageDeclaration?
    'terminate' ( ownedRelationship += NodeParameterMember )?
    ActionBody

// Clause 8.2.2.17.7 Structured Control Action Usages

IfNode : IfActionUsage =
    ActionNodePrefix
    'if' ownedRelationship += ExpressionParameterMember
    ownedRelationship += ActionBodyParameterMember
    ( 'else' ownedRelationship +=
      ( ActionBodyParameterMember | IfNodeParameterMember ) )?

ExpressionParameterMember : ParameterMembership = 
    ownedRelatedElement += OwnedExpression 

ActionBodyParameterMember : ParameterMembership =
    ownedRelatedElement += ActionBodyParameter

ActionBodyParameter : ActionUsage =
    ( 'action' UsageDeclaration? )?
    '{' ActionBodyItem* '}'

IfNodeParameterMember : ParameterMembership =
    ownedRelatedElement += IfNode

WhileLoopNode : WhileLoopActionUsage =
    ActionNodePrefix
    ( 'while' ownedRelationship += ExpressionParameterMember
    | 'loop' ownedRelationship += EmptyParameterMember
    )
    ownedRelationship += ActionBodyParameterMember
    ( 'until' ownedRelationship += ExpressionParameterMember ';' )?

ForLoopNode : ForLoopActionUsage =
    ActionNodePrefix
    'for' ownedRelationship += ForVariableDeclarationMember
    'in' ownedRelationship += NodeParameterMember
    ownedRelationship += ActionBodyParameterMember

ForVariableDeclarationMember : FeatureMembership =
    ownedRelatedElement += UsageDeclaration

ForVariableDeclaration : ReferenceUsage =
    UsageDeclaration

// Clause 8.2.2.17.8 Action Successions

ActionTargetSuccession : Usage =
    ( TargetSuccession | GuardedTargetSuccession | DefaultTargetSuccession )
    UsageBody

TargetSuccession : SuccessionAsUsage =
    ownedRelationship += SourceEndMember
    'then' ownedRelationship += ConnectorEndMember

GuardedTargetSuccession : TransitionUsage =
    ownedRelationship += GuardExpressionMember
    'then' ownedRelationship += TransitionSuccessionMember

DefaultTargetSuccession : TransitionUsage =
    'else' ownedRelationship += TransitionSuccessionMember

GuardedSuccession : TransitionUsage =
    ( 'succession' UsageDeclaration )?
    'first' ownedRelationship += FeatureChainMember
    ownedRelationship += GuardExpressionMember
    'then' ownedRelationship += TransitionSuccessionMember
    UsageBody

// Clause 8.2.2.18 States Textual Notation

// Clause 8.2.2.18.1 State Definitions

StateDefinition =
    OccurrenceDefinitionPrefix 'state' 'def'
    DefinitionDeclaration StateDefBody

StateDefBody : StateDefinition =
      ';'
    | ( isParallel ?= 'parallel' )?
      '{' StateBodyItem* '}'

StateBodyItem : Type =
      NonBehaviorBodyItem
    | ( ownedRelationsup += SourceSuccessionMember )?
      ownedRelationship += BehaviorUsageMember  
      ( ownedRelationship += TargetTransitionUsageMember )*
    | ownedRelationship += TransitionUsageMember
    | ownedRelationship += EntryActionMember
      ( ownedRelationship += EntryTransitionMember )*
    | ownedRelationship += DoActionMember
    | ownedRelationship += ExitActionMember

EntryActionMember : StateSubactionMembership =
    MemberPrefix kind = 'entry'
    ownedRelatedElement += StateActionUsage

DoActionMember : StateSubactionMembership =
    MemberPrefix kind = 'do'
    ownedRelatedElement += StateActionUsage

ExitActionMember : StateSubactionMembership =
    MemberPrefix kind = 'exit'
    ownedRelatedElement += StateActionUsage

EntryTransitionMember : FeatureMembership :
    MemberPrefix
    ( ownedRelatedElement += GuardedTargetSuccession
    | 'then' ownedRelatedElement += TargetSuccession
    ) ';'

StateActionUsage : ActionUsage =
    EmptyActionUsage ';'
    | StatePerformActionUsage
    | StateAcceptActionUsage
    | StateSendActionUsage
    | StateAssignmentActionUsage

EmptyActionUsage : ActionUsage =
    {}

StatePerformActionUsage : PerformActionUsage =
    PerformActionUsageDeclaration ActionBody

StateAcceptActionUsage : AcceptActionUsage =
    AcceptNodeDeclaration ActionBody

StateSendActionUsage : SendActionUsage
    SendNodeDeclaration ActionBody

StateAssignmentActionUsage : AssignmentActionUsage =
    AssignmentNodeDeclaration ActionBody

TransitionUsageMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += TransitionUsage

TargetTransitionUsageMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += TargetTransitionUsage

// Clause 8.2.2.18.2 State Usages

StateUsage =
    OccurrenceUsagePrefix 'state'
    ActionUsageDeclaration StateUsageBody

StateUsageBody : StateUsage =
       ';'
     | ( isParallel ?= 'parallel' )?
       '{' StateBodyItem* '}'

ExhibitStateUsage =
    OccurrenceUsagePrefix 'exhibit'
    ( ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
    | 'state' UsageDeclaration )
    ValuePart? StateUsageBody

// Clause 8.2.2.18.3 Transition Usages

TransitionUsage =
    'transition' ( UsageDeclaration 'first' )?
    ownedRelationship += FeatureChainMember
    ownedRelationship += EmptyParameterMember
    ( ownedRelationship += EmptyParameterMember
      ownedRelationship += TriggerActionMember )?
    ( ownedRelationship += GuardExpressionMember )?
    ( ownedRelationship += EffectBehaviorMember )?
    'then' ownedRelationship += TransitionSuccessionMember
    ActionBody

TargetTransitionUsage : TransitionUsage =
    ownedRelationship += EmptyParameterMember
    ( 'transition'
      ( ownedRelationship += EmptyParameterMember
        ownedRelationship += TriggerActionMember )?
      ( ownedRelationship += GuardExpressionMember )?
      ( ownedRelationship += EffectBehaviorMember )?
    | ownedRelationship += EmptyParameterMember
      ownedRelationship += TriggerActionMember
      ( ownedRelationship += GuardExpressionMember )?
      ( ownedRelationship += EffectBehaviorMember )?
    | ownedRelationship += GuardExpressionMember
      ( ownedRelationship += EffectBehaviorMember )?
    )?
    'then' ownedRelationship += TransitionSuccessionMember
    ActionBody

TriggerActionMember : TransitionFeatureMembership =
    'accept' { kind = 'trigger' } ownedRelatedElement += TriggerAction

TriggerAction : AcceptActionUsage =
    AcceptParameterPart

GuardExpressionMember : TransitionFeatureMembership =
    'if' { kind = 'guard' } ownedRelatedElement += OwnedExpression

EffectBehaviorMember : TransitionFeatureMembership =
    'do' { kind = 'effect' } ownedRelatedElement += EffectBehaviorUsage

EffectBehaviorUsage : ActionUsage =
      EmptyActionUsage
    | TransitionPerformActionUsage
    | TransitionAcceptActionUsage
    | TransitionSendActionUsage
    | TransitionAssignmentActionUsage

TransitionPerformActionUsage : PerformActionUsage =
    PerformActionUsageDeclaration ( '{' ActionBodyItem* '}' )?

TransitionAcceptActionUsage : AcceptActionUsage =
    AcceptNodeDeclaration ( '{' ActionBodyItem* '}' )?

TransitionSendActionUsage : SendActionUsage =
    SendNodeDeclaration ( '{' ActionBodyItem* '}' )?

TransitionAssignmentActionUsage : AssignmentActionUsage =
    AssignmentNodeDeclaration ( '{' ActionBodyItem* '}' )?

TransitionSuccessionMember : OwningMembership =
    ownedRelatedElement += TransitionSuccession

TransitionSuccession : Succession =
    ownedRelationship += EmptyEndMember
    ownedRelationship += ConnectorEndMember

EmptyEndMember : EndFeatureMembership =
    ownedRelatedElement += EmptyFeature

EmptyFeature : ReferenceUsage =
    {}

// Clause 8.2.2.19 Calculations Textual Notation

CalculationDefinition =
    OccurrenceDefinitionPrefix 'calc' 'def'
    DefinitionDeclaration CalculationBody

CalculationUsage : CalculationUsage =
    OccurrenceUsagePrefix 'calc'
    ActionUsageDeclaration CalculationBody

CalculationBody : Type =
      ';' | '{' CalculationBodyPart '}'

CalculationBodyPart : Type =
      CalculationBodyItem*
      ( ownedRelationship += ResultExpressionMember )?

CalculationBodyItem : Type =
      ActionBodyItem
    | ownedRelationship += ReturnParameterMember

ReturnParameterMember : ReturnParameterMembership =
    MemberPrefix? 'return' ownedRelatedElement += UsageElement

ResultExpressionMember : ResultExpressionMembership =
    MemberPrefix? ownedRelatedElement += OwnedExpression

// Clause 8.2.2.20 Constraints Textual Notation

ConstraintDefinition =
    OccurrenceDefinitionPrefix 'constraint' 'def'
    DefinitionDeclaration CalculationBody

ConstraintUsage =
    OccurrenceUsagePrefix 'constraint'
    ConstraintUsageDeclaration CalculationBody

AssertConstraintUsage =
    OccurrenceUsagePrefix 'assert' ( isNegated ?= 'not' )?
    ( ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
    | 'constraint' ConstraintUsageDeclaration )
    CalculationBody

ConstraintUsageDeclaration : ConstraintUsage =
    UsageDeclaration ValuePart?

// Clause 8.2.2.21 Requirements Textual Notation

// Clause 8.2.2.21.1 Requirement Definitions

RequirementDefinition =
    OccurrenceDefinitionPrefix 'requirement' 'def'
    DefinitionDeclaration RequirementBody

RequirementBody : Type =
      ';' | '{' RequirementBodyItem* '}'

RequirementBodyItem : Type =
      DefinitionBodyItem
    | ownedRelationship += SubjectMember
    | ownedRelationship += RequirementConstraintMember
    | ownedRelationship += FramedConcernMember
    | ownedRelationship += RequirementVerificationMember
    | ownedRelationship += ActorMember
    | ownedRelationship += StakeholderMember

SubjectMember : SubjectMembership =
    MemberPrefix ownedRelatedElement += SubjectUsage

SubjectUsage : ReferenceUsage =
    'subject' UsageExtensionKeyword* Usage

RequirementConstraintMember : RequirementConstraintMembership =
    MemberPrefix? RequirementKind
    ownedRelatedElement += RequirementConstraintUsage

RequirementKind : RequirementConstraintMembership =
      'assume' { kind = 'assumption' }
    | 'require' { kind = 'requirement' }

RequirementConstraintUsage : ConstraintUsage =
      ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart? RequirementBody
    | ( UsageExtensionKeyword* 'constraint' 
      | UsageExtensionKeyword+ )
      ConstraintUsageDeclaration CalculationBody

FramedConcernMember : FramedConcernMembership =
    MemberPrefix? 'frame'
    ownedRelatedElement += FramedConcernUsage

FramedConcernUsage : ConcernUsage =
      ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart? CalculationBody
    | ( UsageExtensionKeyword* 'concern'
      | UsageExtensionKeyword+ )
      CalculationUsageDeclaration CalculationBody

ActorMember : ActorMembership =
    MemberPrefix ownedRelatedElement += ActorUsage

ActorUsage : PartUsage =
    'actor' UsageExtensionKeyword* Usage

StakeholderMember : StakeholderMembership =
    MemberPrefix ownedRelatedElement += StakeholderUsage

StakeholderUsage : PartUsage =
    'stakeholder' UsageExtensionKeyword* Usage

// Clause 8.2.2.21.2 Requirement Usages

RequirementUsage =
    OccurrenceUsagePrefix 'requirement'
    ConstraintUsageDeclaration RequirementBody

SatisfyRequirementUsage =
    OccurrenceUsagePrefix 'assert' ( isNegated ?= 'not' ) 'satisfy'
    ( ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
    | 'requirement' UsageDeclaration )    
    ValuePart?
    ( 'by' ownedRelationship += SatisfactionSubjectMember )?
    RequirementBody

SatisfactionSubjectMember : SubjectMembership =
    ownedRelatedElement += SatisfactionParameter

SatisfactionParameter : ReferenceUsage =
    ownedRelationship += SatisfactionFeatureValue

SatisfactionFeatureValue : FeatureValue =
    ownedRelatedElement += SatisfactionReferenceExpression

SatisfactionReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FeatureChainMember

// Clause 8.2.2.21.3 Concerns

ConcernDefinition =
    OccurrenceDefinitionPrefix 'concern' 'def'
    DefinitionDeclaration RequirementBody

ConcernUsage =
    OccurrenceUsagePrefix 'concern'
    ConstraintUsageDeclaration RequirementBody

// Clause 8.2.2.22 Cases Textual Notation

CaseDefinition =
    OccurrenceDefinitionPrefix 'case' 'def'
    DefinitionDeclaration CaseBody

CaseUsage =
    OccurrenceUsagePrefix 'case'
    ConstraintUsageDeclaration CaseBody

CaseBody : Type =
      ';'
    | '{' CaseBodyItem*
          ( ownedRelationship += ResultExpressionMember )?
      '}'

CaseBodyItem : Type =
      ActionBodyItem
    | ownedRelationship += SubjectMember
    | ownedRelationship += ActorMember
    | ownedRelationship += ObjectiveMember

ObjectiveMember : ObjectiveMembership =
    MemberPrefix 'objective'
    ownedRelatedElement += ObjectiveRequirementUsage

ObjectiveRequirementUsage : RequirementUsage =
    UsageExtensionKeyword* ConstraintUsageDeclaration 
    RequirementBody

// Clause 8.2.2.23 Analysis Cases Textual Notation

AnalysisCaseDefinition =
    OccurrenceDefinitionPrefix 'analysis' 'def'
    DefinitionDeclaration CaseBody

AnalysisCaseUsage =
    OccurrenceUsagePrefix 'analysis'
    ConstraintUsageDeclaration CaseBody

// Clause 8.2.2.24 Verification Cases Textual Notation

VerificationCaseDefinition =
    OccurrenceDefinitionPrefix 'verification' 'def'
    DefinitionDeclaration CaseBody

VerificationCaseUsage =
    OccurrenceUsagePrefix 'verification'
    ConstraintUsageDeclaration CaseBody

RequirementVerificationMember : RequirementVerificationMembership =
    MemberPrefix 'verify' { kind = 'requirement' }
    ownedRelatedElement += RequirementVerificationUsage

RequirementVerificationUsage : RequirementUsage =
      ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecialization* RequirementBody
    | ( UsageExtensionKeyword* 'requirement' 
      | UsageExtensionKeyword+ )
      ConstraintUsageDeclaration RequirementBody

// Clause 8.2.2.25 Use Cases Textual Notation

UseCaseDefinition =
    OccurrenceDefinitionPrefix 'use' 'case' 'def'
    DefinitionDeclaration CaseBody

UseCaseUsage =
    OccurrenceUsagePrefix 'use' 'case'
    ConstraintUsageDeclaration CaseBody

IncludeUseCaseUsage :
    OccurrenceUsagePrefix 'include'
    ( ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
    | 'use' 'case' UsageDeclaration )
    ValuePart?
    CaseBody

// Clause 8.2.2.26 Views and Viewpoints Textual Notation

// Clause 8.2.2.26.1 View Definitions

ViewDefinition =
    OccurrenceDefinitionPrefix 'view' 'def'
    DefinitionDeclaration ViewDefinitionBody

ViewDefinitionBody : ViewDefinition =
    ';' | '{' ViewDefinitionBodyItem* '}'

ViewDefinitionBodyItem : ViewDefinition =
      DefinitionBodyItem
    | ownedRelationship += ElementFilterMember
    | ownedRelationship += ViewRenderingMember

ViewRenderingMember : ViewRenderingMembership =
    MemberPrefix 'render'
    ownedRelatedElement += ViewRenderingUsage

ViewRenderingUsage : RenderingUsage =
      ownedRelationship += OwnedReferenceSubsetting
      FeatureSpecializationPart?
      UsageBody
    | ( UsageExtensionKeyword* 'rendering'
      | UsageExtensionKeyword+ )
      Usage

// Clause 8.2.2.26.2 View Usages

ViewUsage =
    OccurrenceUsagePrefix 'view'
    UsageDeclaration? ValuePart?
    ViewBody

ViewBody : ViewUsage =
    ';' | '{' ViewBodyItem* '}'

ViewBodyItem : ViewUsage =
      DefinitionBodyItem
    | ownedRelationship += ElementFilterMember
    | ownedRelationship += ViewRenderingMember
    | ownedRelationship += Expose

Expose =
    'expose' ( MembershipExpose | NamespaceExpose )
    RelationshipBody

MembershipExpose =
    MembershipImport

NamespaceExpose =
    NamespaceImport

// Clause 8.2.2.26.3 Viewpoints

ViewpointDefinition =
    OccurrenceDefinitionPrefix 'viewpoint' 'def'
    DefinitionDeclaration RequirementBody

ViewpointUsage =
    OccurrenceUsagePrefix 'viewpoint'
    ConstraintUsageDeclaration RequirementBody

// Clause 8.2.2.26.4 Renderings

RenderingDefinition =
    OccurrenceDefinitionPrefix 'rendering' 'def'
    Definition

RenderingUsage =
    OccurrenceUsagePrefix 'rendering'
    Usage

// Clause 8.2.2.27 Metadata Textual Notation

MetadataDefinition =
    ( isAbstract ?= 'abstract')? DefinitionExtensionKeyWord* 
    'metadata' 'def' Definition

PrefixMetadataAnnotation : Annotation =
    '#' annotatingElement = PrefixMetadataUsage
    { ownedRelatedElement += annotatingElement }

PrefixMetadataMember : OwningMembership =
    '#' ownedRelatedEleemnt = PrefixMetadataUsage

PrefixMetadataUsage : MetadataUsage =
    ownedRelationship += OwnedFeatureTyping

MetadataUsage =
    UsageExtensionKeyword* ( '@' | 'metadata' ) 
    MetadataUsageDeclaration
    ( 'about' ownedRelationship += Annotation
      ( ',' ownedRelationship += Annotation )*
    )?
    MetadataBody

MetadataUsageDeclaration : MetadataUsage =
    ( Identification ( ':' | 'typed' 'by' ) )?
    ownedRelationship += OwnedFeatureTyping

MetadataBody : Type =
    ';' |
    '{' ( ownedRelationship += DefinitionMember
        | ownedRelationship += MetadataBodyUsageMember
        | ownedRelationship += AliasMember
        | ownedRelationship += Import
        )*
    '}'

MetadataBodyUsageMember : FeatureMembership =
    ownedMemberFeature = MetadataBodyUsage

MetadataBodyUsage : ReferenceUsage :
    'ref'? ( ':>>' | 'redefines' )? ownedRelationship += OwnedRedefinition
    FeatureSpecializationPart? ValuePart?
    MetadataBody

ExtendedDefinition : Definition =
    BasicDefinitionPrefix? DefinitionExtensionKeyword+
    'def' Definition

ExtendedUsage : Usage =
    UnextendedUsagePrefix UsageExtensionKeyword+
    Usage

// End of EBNF

// EBNF Grammar Checks
// 
// Keywords extracted from EBNF grammar scan:
//   '@'
//   'about'
//   'abstract'
//   'accept'
//   'action'
//   'actor'
//   'after'
//   'alias'
//   'all'
//   'allocate'
//   'allocation'
//   'analysis'
//   'assert'
//   'assign'
//   'assume'
//   'assumption'
//   'attribute'
//   'bind'
//   'binding'
//   'by'
//   'calc'
//   'case'
//   'comment'
//   'concern'
//   'connect'
//   'connection'
//   'constant'
//   'constraint'
//   'crosses'
//   'decide'
//   'def'
//   'default'
//   'defined'
//   'dependency'
//   'derived'
//   'do'
//   'doc'
//   'effect'
//   'else'
//   'end'
//   'entry'
//   'enum'
//   'event'
//   'exhibit'
//   'exit'
//   'expose'
//   'filter'
//   'first'
//   'flow'
//   'for'
//   'fork'
//   'frame'
//   'from'
//   'guard'
//   'if'
//   'import'
//   'in'
//   'include'
//   'individual'
//   'inout'
//   'interface'
//   'item'
//   'join'
//   'language'
//   'library'
//   'locale'
//   'loop'
//   'merge'
//   'message'
//   'metadata'
//   'nonunique'
//   'not'
//   'objective'
//   'occurrence'
//   'of'
//   'ordered'
//   'out'
//   'package'
//   'parallel'
//   'part'
//   'perform'
//   'port'
//   'private'
//   'protected'
//   'public'
//   'redefines'
//   'ref'
//   'references'
//   'render'
//   'rendering'
//   'rep'
//   'require'
//   'requirement'
//   'return'
//   'satisfy'
//   'send'
//   'snapshot'
//   'specializes'
//   'stakeholder'
//   'standard'
//   'state'
//   'subject'
//   'subsets'
//   'succession'
//   'terminate'
//   'then'
//   'timeslice'
//   'to'
//   'transition'
//   'trigger'
//   'typed'
//   'until'
//   'use'
//   'variant'
//   'variation'
//   'verification'
//   'verify'
//   'via'
//   'view'
//   'viewpoint'
//   'when'
//   'while'

// Comparison of declared reserved keywords versus extracted keywords
// 
// Declared reserved keywords not in extracted keywords:
//   and, as, assoc, at, block, hastype, implies, istype, or, readonly, xor
// 
// Extracted keywords not in declared reserved keywords:
//   @, assumption, constant, effect, guard, library, locale, standard, trigger, typed

// End of EBNF Grammar Checks

// Start of GBNF Grammar Checks
// img_tokens:

// End of GBNF Grammar Checks
