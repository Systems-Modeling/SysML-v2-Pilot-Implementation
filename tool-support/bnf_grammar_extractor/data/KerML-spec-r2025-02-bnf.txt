// Source document: KerML-spec-r2025-02.html

// Generated by bnf_grammar_extractor at: 2025-06-18T11:49:30Z

// Part 1 - Kernel Modeling Language (KerML)

// Clause 8.2 Concrete Syntax

// Clause 8.2.1 Concrete Syntax Overview

// Clause 8.2.2 Lexical Structure

// Clause 8.2.2.1 Line Terminators and White Space

LINE_TERMINATOR =
    implementation defined character sequence

LINE_TEXT =
    character sequence excluding LINE_TERMINATORs

WHITE_SPACE =
    space | tab | form_feed | LINE_TERMINATOR

// Clause 8.2.2.2 Notes and Comments

SINGLE_LINE_NOTE =
    '//' LINE_TEXT

MULTILINE_NOTE =
    '//*' COMMENT_TEXT '*/'

REGULAR_COMMENT =
    '/*' COMMENT_TEXT '*/'

COMMENT_TEXT =
    ( COMMENT_LINE_TEXT | LINE_TERMINATOR )*

COMMENT_LINE_TEXT =
    LINE_TEXT excluding the sequence '*/'

// Clause 8.2.2.3 Names

NAME =
    BASIC_NAME | UNRESTRICTED_NAME

BASIC_NAME =
    BASIC_INITIAL_CHARACTER BASIC_NAME_CHARACTER*

UNRESTRICTED_NAME =
    single_quote ( NAME_CHARACTER | ESCAPE_SEQUENCE )* single_quote

//     (see Note 1)

BASIC_INITIAL_CHARACTER =
    ALPHABETIC_CHARACTER | '_'

BASIC_NAME_CHARACTER =
    BASIC_INITIAL_CHARACTER | DECIMAL_DIGIT

ALPHABETIC_CHARACTER =
    any character 'a' through 'z' or 'A' through 'Z'

DECIMAL_DIGIT =
    any character '0' through '9'

NAME_CHARACTER =
    any printable character other than backslash or single_quote

ESCAPE_SEQUENCE =

//     see Note 2

// Notes:
// Note 1: The single_quote character is '. The name represented by an UNRESTRICTED_NAME shall consist of the characters within the single quotes, with escape characters resolved as described below. The surrounding single quote characters are not part of the represented name.
// Note 2: An ESCAPE_SEQUENCE is a sequence of two text characters starting with a backslash that actually denotes only a single character, except for the newline escape sequence, which represents however many characters is necessary to represent an end of line in a specific implementation (see also 8.2.2.1 ). Table 4 shows the meaning of the allowed escape sequences. The ESCAPE_SEQUENCES in an UNRESTRICTED_NAME shall be replaced by the characters specified as their meanings in the actual represented name.

// Clause 8.2.2.4 Numeric Values

DECIMAL_VALUE =
    DECIMAL_DIGIT+

EXPONENTIAL_VALUE =
    DECIMAL_VALUE ('e' | 'E') ('+' | '-')? DECIMAL_VALUE

// Clause 8.2.2.5 String Value

STRING_VALUE =
    '"' ( STRING_CHARACTER | ESCAPE_SEQUENCE )* '"'

STRING_CHARACTER =
    any printable character other than backslash or '"'

// Clause 8.2.2.6 Reserved Words

RESERVED_KEYWORD =
      'about'
    | 'abstract'
    | 'alias'
    | 'all'
    | 'and'
    | 'as'
    | 'assoc'
    | 'behavior'
    | 'binding'
    | 'bool'
    | 'by'
    | 'chains'
    | 'class'
    | 'classifier'
    | 'comment'
    | 'composite'
    | 'conjugate'
    | 'conjugates'
    | 'conjugation'
    | 'connector'
    | 'const'
    | 'crosses'
    | 'datatype'
    | 'default'
    | 'dependency'
    | 'derived'
    | 'differences'
    | 'disjoining'
    | 'disjoint'
    | 'doc'
    | 'else'
    | 'end'
    | 'expr'
    | 'false'
    | 'feature'
    | 'featured'
    | 'featuring'
    | 'filter'
    | 'first'
    | 'flow'
    | 'for'
    | 'from'
    | 'function'
    | 'hastype'
    | 'if'
    | 'implies'
    | 'import'
    | 'in'
    | 'inout'
    | 'interaction'
    | 'intersects'
    | 'inv'
    | 'inverse'
    | 'inverting'
    | 'istype'
    | 'language'
    | 'member'
    | 'metaclass'
    | 'metadata'
    | 'multiplicity'
    | 'namespace'
    | 'nonunique'
    | 'not'
    | 'null'
    | 'of'
    | 'or'
    | 'ordered'
    | 'out'
    | 'package'
    | 'portion'
    | 'predicate'
    | 'private'
    | 'protected'
    | 'public'
    | 'redefines'
    | 'redefinition'
    | 'references'
    | 'rep'
    | 'return'
    | 'specialization'
    | 'specializes'
    | 'step'
    | 'struct'
    | 'subclassifier'
    | 'subset'
    | 'subsets'
    | 'subtype'
    | 'succession'
    | 'then'
    | 'to'
    | 'true'
    | 'type'
    | 'typed'
    | 'typing'
    | 'unions'
    | 'var'
    | 'xor'

// Clause 8.2.2.7 Symbols

RESERVED_SYMBOL =
      '!='
    | '!=='
    | '#'
    | '%'
    | '&'
    | '('
    | ')'
    | '*'
    | '**'
    | '+'
    | ','
    | '-'
    | '->'
    | '.'
    | '..'
    | '.?'
    | '/'
    | ':'
    | '::'
    | '::>'
    | ':='
    | ':>'
    | ':>>'
    | ';'
    | '<'
    | '<='
    | '='
    | '=='
    | '==='
    | '=>'
    | '>'
    | '>='
    | '?'
    | '??'
    | '@'
    | '['
    | ']'
    | '^'
    | '{'
    | '|'
    | '}'
    | '~'

TYPED_BY    = ':'   | 'typed' 'by'

SPECIALIZES = ':>'  | 'specializes'

SUBSETS     = ':>'  | 'subsets'

REFERENCES  = '::>' | 'references'

CROSSES     = '=>'  | 'crosses'

REDEFINES   = ':>>' | 'redefines'

CONJUGATES  = '~'   | 'conjugates'

// Clause 8.2.3 Root Concrete Syntax

// Clause 8.2.3.1 Elements and Relationships Concrete Syntax

Identification : Element =
    ( '<' declaredShortName = NAME '>' )?
    ( declaredName = NAME )?

RelationshipBody : Relationship =
    ';' | '{' RelationshipOwnedElement* '}'

RelationshipOwnedElement : Relationship =
      ownedRelatedElement += OwnedRelatedElement
    | ownedRelationship += OwnedAnnotation

OwnedRelatedElement : Element =
    NonFeatureElement | FeatureElement

// Clause 8.2.3.2 Dependencies Concrete Syntax

Dependency =
    ( ownedRelationship += PrefixMetadataAnnotation )*
    'dependency' ( Identification? 'from' )?
    client += [QualifiedName] ( ',' client += [QualifiedName] )* 'to'
    supplier += [QualifiedName] ( ',' supplier += [QualifiedName] )*
    RelationshipBody

// Clause 8.2.3.3 Annotations Concrete Syntax

// Clause 8.2.3.3.1 Annotations

Annotation =
    annotatedElement = [QualifiedName]

OwnedAnnotation : Annotation =
    ownedRelatedElement += AnnotatingElement

AnnotatingElement =
      Comment
    | Documentation
    | TextualRepresentation
    | MetadataFeature

// Clause 8.2.3.3.2 Comments and Documentation

Comment =
    ( 'comment' Identification
      ( 'about' ownedRelationsip += Annotation
        ( ',' ownedRelationship += Annotation )*
      )?
    )?
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT

Documentation =
    'doc' Identification
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT

// Clause 8.2.3.3.3 Textual Representation

TextualRepresentation =
    ( 'rep' Identification )?
    'language' language = STRING_VALUE
    body = REGULAR_COMMENT

// Clause 8.2.3.4 Namespaces Concrete Syntax

// Clause 8.2.3.4.1 Namespaces

RootNamespace : Namespace =
    NamespaceBodyElement*

// (See Note 1)

Namespace =
    ( ownedRelationship += PrefixMetadataMember )*
    NamespaceDeclaration NamespaceBody

// (See Note 2)

NamespaceDeclaration : Namespace =
    'namespace' Identification

NamespaceBody : Namespace =
    ';' | '{' NamespaceBodyElement* '}'

NamespaceBodyElement : Namespace =
      ownedRelationship += NamespaceMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

MemberPrefix : Membership =
    ( visibility = VisibilityIndicator )?

VisibilityIndicator : VisibilityKind =
    'public' | 'private' | 'protected'

NamespaceMember : OwningMembership =
      NonFeatureMember
    | NamespaceFeatureMember

NonFeatureMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += MemberElement

NamespaceFeatureMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += FeatureElement

AliasMember : Membership =
    MemberPrefix
    'alias' ( '<' memberShortName = NAME '>' )?
    ( memberName = NAME )?
    'for' memberElement = [QualifiedName]
    RelationshipBody

QualifiedName =
   ( '$' '::' )? ( NAME '::' )* NAME

// (See Note 3)

// Notes:
// Note 1: A root Namespace is a Namespace that has no owningNamespace (see 8.3.2.4 ). Every Element other than a root Namespace must be contained, directly or indirectly, within some root Namespace. Therefore, every valid KerML concrete syntax text can be parsed starting from the RootNamespace production.
// Note 2: PrefixMetadataMember is defined in the Kernel layer (see 8.2.5.12 ).
// Note 3: A qualified name is notated as a sequence of segment names separated by " :: " punctuation, optionally with the global scope qualifier " $ " as an initial segment. An unqualified name can be considered the degenerate case of a qualified name with a single segment name. A qualified name is used in the KerML textual concrete syntax to identify an Element that is being referred to in the representation of another Element. A qualified name used in this way does not appear in the corresponding abstract syntaxâ€”instead, the abstract syntax representation contains an actual reference to the identified Element. Name resolution is the process of determining the Element that is identified by a qualified name. The segment names of the qualified name other than the last identify a sequence of nested Namespaces that provide the context for resolving the final segment name (see 8.2.3.5 ). The notation [QualifiedName] is used in concrete syntax grammar productions to indicate the result of resolving text parsed as a QualifiedName (see also 8.2.1 ).

// Clause 8.2.3.4.2 Imports

Import =
    visibility = VisibilityIndicator
    'import' ( isImportAll ?= 'all' )?
    ImportDeclaration RelationshipBody
ImportDeclaration : Import
    MembershipImport | NamespaceImport

MembershipImport =
    importedMembership = [QualifiedName]
    ( '::' isRecursive ?= '**' )?

// (see Note 1)

NamespaceImport =
      importedNamespace = [QualifiedName] '::' '*'
      ( '::' isRecursive ?= '**' )?
    | importedNamespace = FilterPackage
      { ownedRelatedElement += importedNamespace }

FilterPackage : Package =
    ownedRelationship += ImportDeclaration
    ( ownedRelationship += FilterPackageMember )+

FilterPackageMember : ElementFilterMembership =
    '[' ownedRelatedElement += OwnedExpression ']'

// Notes:
// Note 1: The importedMembership of a MembershipImport is the single case in which the Element required from the resolution [QualifiedName] is the actual Membership identified by the QualifedName, not the memberElement of that Membership (see 8.2.3.5 ).

// Clause 8.2.3.4.3 Namespace Elements

MemberElement : Element =
    AnnotatingElement | NonFeatureElement

NonFeatureElement : Element =
      Dependency
    | Namespace
    | Type
    | Classifier
    | DataType
    | Class
    | Structure
    | Metaclass
    | Association
    | AssociationStructure
    | Interaction
    | Behavior
    | Function
    | Predicate
    | Multiplicity
    | Package
    | LibraryPackage
    | Specialization
    | Conjugation
    | Subclassification
    | Disjoining
    | FeatureInverting
    | FeatureTyping
    | Subsetting
    | Redefinition
    | TypeFeaturing

FeatureElement : Feature =
      Feature
    | Step
    | Expression
    | BooleanExpression
    | Invariant
    | Connector
    | BindingConnector
    | Succession
    | Flow
    | SuccessionFlow

// Clause 8.2.3.5 Name Resolution

// Clause 8.2.3.5.1 Name Resolution Overview

// Clause 8.2.3.5.2 Local and Global Namespaces

// Clause 8.2.3.5.3 Local and Visible Resolution

// Clause 8.2.3.5.4 Full Resolution

// Clause 8.2.4 Core Concrete Syntax

// Clause 8.2.4.1 Types Concrete Syntax

// Clause 8.2.4.1.1 Types

Type =
    TypePrefix 'type'
    TypeDeclaration TypeBody

TypePrefix : Type =
    ( isAbstract ?= 'abstract' )?
    ( ownedRelationship += PrefixMetadataMember )*

TypeDeclaration : Type =
    ( isSufficient ?= 'all' )? Identification
    ( ownedRelationship += OwnedMultiplicity )?
    ( SpecializationPart | ConjugationPart )+
    TypeRelationshipPart*

SpecializationPart : Type =
    SPECIALIZES ownedRelationship += OwnedSpecialization
    ( ',' ownedRelationship += OwnedSpecialization )*

ConjugationPart : Type =
    CONJUGATES ownedRelationship += OwnedConjugation

TypeRelationshipPart : Type =
      DisjoiningPart
    | UnioningPart
    | IntersectingPart
    | DifferencingPart

DisjoiningPart : Type =
    'disjoint' 'from' ownedRelationship += OwnedDisjoining
    ( ',' ownedRelationship += OwnedDisjoining )*

UnioningPart : Type =
    'unions' ownedRelationship += Unioning
    ( ',' ownedRelationship += Unioning )*

IntersectingPart : Type =
    'intersects' ownedRelationship += Intersecting
    ( ',' ownedRelationship += Intersecting )*

DifferencingPart : Type =
    'differences' ownedRelationship += Differencing
    ( ',' ownedRelationship += Differencing )*

TypeBody : Type =
    ';' | '{' TypeBodyElement* '}'

TypeBodyElement : Type =
      ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

// Clause 8.2.4.1.2 Specialization

Specialization =
    ( 'specialization' Identification )?
    'subtype' SpecificType
    SPECIALIZES GeneralType
    RelationshipBody

OwnedSpecialization : Specialization =
    GeneralType
SpecificType : Specialization :
      specific = [QualifiedName]
    | specific += OwnedFeatureChain
      { ownedRelatedElement += specific }

GeneralType : Specialization =
      general = [QualifiedName]
    | general += OwnedFeatureChain
      { ownedRelatedElement += general }

// Clause 8.2.4.1.3 Conjugation

Conjugation =
    ( 'conjugation' Identification )?
    'conjugate'
    ( conjugatedType = [QualifiedName]
    | conjugatedType = FeatureChain
      { ownedRelatedElement += conjugatedType }
    )
    CONJUGATES
    ( originalType = [QualifiedName]
    | originalType = FeatureChain
      { ownedRelatedElement += originalType }
    )
    RelationshipBody

OwnedConjugation : Conjugation =
      originalType = [QualifiedName]
    | originalType = FeatureChain
      { ownedRelatedElement += originalType }

// Clause 8.2.4.1.4 Disjoining

Disjoining =
    ( 'disjoining' Identification )?
    'disjoint'
    ( typeDisjoined = [QualifiedName]
    | typeDisjoined = FeatureChain
      { ownedRelatedElement += typeDisjoined }
    )
    'from'
    ( disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
      { ownedRelatedElement += disjoiningType }
    )
    RelationshipBody

OwnedDisjoining : Disjoining =
      disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
      { ownedRelatedElement += disjoiningType }

// Clause 8.2.4.1.5 Unioning, Intersecting and Differencing

Unioning =
      unioningType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain

Intersecting =
      intersectingType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain

Differencing =
      differencingType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain

// Clause 8.2.4.1.6 Feature Membership

FeatureMember : OwningMembership =
      TypeFeatureMember
    | OwnedFeatureMember

TypeFeatureMember : OwningMembership =
    MemberPrefix 'member' ownedRelatedElement += FeatureElement

OwnedFeatureMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += FeatureElement

// Clause 8.2.4.2 Classifiers Concrete Syntax

// Clause 8.2.4.2.1 Classifiers

Classifier =
    TypePrefix 'classifier'
    ClassifierDeclaration TypeBody

ClassifierDeclaration : Classifier =
    ( isSufficient ?= 'all' )? Identification
    ( ownedRelationship += OwnedMultiplicity )?
    ( SuperclassingPart | ConjugationPart )?
    TypeRelationshipPart*

SuperclassingPart : Classifier =
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )*

// Clause 8.2.4.2.2 Subclassification

Subclassification =
    ( 'specialization' Identification )?
    'subclassifier' subclassifier = [QualifiedName]
    SPECIALIZES superclassifier = [QualifiedName]
    RelationshipBody

OwnedSubclassification : Subclassification =
    superclassifier = [QualifiedName]

// Clause 8.2.4.3 Features Concrete Syntax

// Clause 8.2.4.3.1 Features

Feature =
    ( FeaturePrefix
      ( 'feature' | ownedRelationship += PrefixMetadataMember )
      FeatureDeclaration?
      )
    | ( EndFeaturePrefix | BasicFeaturePrefix )
      FeatureDeclaration
    )
    ValuePart? TypeBody

// (See Note 1)

EndFeaturePrefix : Feature =
    ( isConstant ?= 'const' { isVariable = true } )?
    isEnd ?= 'end'
BasicFeaturePrefix : Feature :
    ( direction = FeatureDirection )?
    ( isDerived ?= 'derived' )?
    ( isAbstract ?= 'abstract' )?
    ( isComposite ?= 'composite' | isPortion ?= 'portion' )?
    ( isVariable ?= 'var' | isConstant ?= 'const' { isVariable = true } )?
FeaturePrefix :
    ( EndFeaturePrefix ( ownedRelationship += OwnedCrossFeatureMember )?
    | BasicFeaturePrefix
    )
    ( ownedRelationship += PrefixMetadataMember )*

// (see Note 1)

OwnedCrossFeatureMember : OwningMembership =
    ownedRelatedElement += OwnedCrossFeature

OwnedCrossFeature : Feature =
    BasicFeaturePrefix FeatureDeclaration

FeatureDirection : FeatureDirectionKind =
    'in' | 'out' | 'inout'

FeatureDeclaration : Feature =
    ( isSufficient ?= 'all' )?
    ( FeatureIdentification
      ( FeatureSpecializationPart | ConjugationPart )?
    | FeatureSpecializationPart
    | ConjugationPart
    )
    FeatureRelationshipPart*

FeatureIdentification : Feature =
      '<' declaredShortName = NAME '>' ( declaredName = NAME )?
    | declaredName = NAME

FeatureRelationshipPart : Feature =
      TypeRelationshipPart
    | ChainingPart
    | InvertingPart
    | TypeFeaturingPart

ChainingPart : Feature =
    'chains'
    ( ownedRelationship += OwnedFeatureChaining
    | FeatureChain )

InvertingPart : Feature =
    'inverse' 'of' ownedRelationship += OwnedFeatureInverting

TypeFeaturingPart : Feature =
    'featured' 'by' ownedRelatioship += OwnedTypeFeaturing
    ( ',' ownedTypeFeaturing += OwnedTypeFeaturing )*

FeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization*

MultiplicityPart : Feature =
      ownedRelationship += OwnedMultiplicity
    | ( ownedRelationship += OwnedMultiplicity )?
      ( isOrdered ?= 'ordered' ( {isUnique = false} 'nonunique' )?
      | {isUnique = false} 'nonunique' ( isOrdered ?= 'ordered' )? )

FeatureSpecialization : Feature =
    Typings | Subsettings | References | Crosses | Redefinitions

Typings : Feature =
      TypedBy ( ',' ownedRelationship += OwnedFeatureTyping )*

TypedBy : Feature =
    TYPED_BY ownedRelationship += OwnedFeatureTyping

Subsettings : Feature =
    Subsets ( ',' ownedRelationship += OwnedSubsetting )*

Subsets : Feature =
    SUBSETS ownedRelationship += OwnedSubsetting

References : Feature =
    REFERENCES ownedRelationship += OwnedReferenceSubsetting

Crosses : Feature =
    CROSSES ownedRelationship += OwnedCrossSubsetting

Redefinitions : Feature =
    Redefines ( ',' ownedRelationship += OwnedRedefinition )*

Redefines : Feature =
    REDEFINES ownedRelationship += OwnedRedefinition

// Notes:
// Note 1: PrefixMetadataMember is defined in the Kernel layer (see 8.3.4.12 ).

// Clause 8.2.4.3.2 Feature Typing

FeatureTyping =
    ( 'specialization' Identification )?
    'typing' typedFeature = [QualifiedName]
    TYPED_BY GeneralType
    RelationshipBody

OwnedFeatureTyping : FeatureTyping =
    GeneralType

// Clause 8.2.4.3.3 Subsetting

Subsetting =
    ( 'specialization' Identification )?
    'subset' SpecificType
    SUBSETS GeneralType
    RelationshipBody

OwnedSubsetting : Subsetting =
    GeneralType

OwnedReferenceSubsetting : ReferenceSubsetting =
    GeneralType

OwnedCrossSubsetting : CrossSubsetting =
    GeneralType

// Clause 8.2.4.3.4 Redefinition

Redefinition =
    ( 'specialization' Identification )?
    'redefinition' SpecificType
    REDEFINES GeneralType
    RelationshipBody

OwnedRedefinition : Redefinition =
    GeneralType

// Clause 8.2.4.3.5 Feature Chaining

OwnedFeatureChain : Feature =
    FeatureChain

FeatureChain : Feature =
    ownedRelationship += OwnedFeatureChaining
    ( '.' ownedRelationship += OwnedFeatureChaining )+

OwnedFeatureChaining : FeatureChaining =
    chainingFeature = [QualifiedName]

// Clause 8.2.4.3.6 Feature Inverting

FeatureInverting =
    ( 'inverting' Identification? )?
    'inverse'
    ( featureInverted = [QualifiedName]
    | featureInverted = OwnedFeatureChain
      { ownedRelatedElement += featureInverted }
    )
    'of'
    ( invertingFeature = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain
      { ownedRelatedElement += invertingFeature }
    )
    RelationshipBody

OwnedFeatureInverting : FeatureInverting =
      invertingFeature = [QualifiedName]
    | invertingFeature = OwnedFeatureChain
      { ownedRelatedElement += invertingFeature }

// Clause 8.2.4.3.7 Type Featuring

TypeFeaturing =
    'featuring' ( Identification 'of' )?
    featureOfType = [QualifiedName]
    'by' featuringType = [QualifiedName]
    RelationshipBody

OwnedTypeFeaturing : TypeFeaturing =
    featuringType = [QualifiedName]

// Clause 8.2.5 Kernel Concrete Syntax

// Clause 8.2.5.1 Data Types Concrete Syntax

DataType =
    TypePrefix 'datatype'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.2 Classes Concrete Syntax

Class =
    TypePrefix 'class'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.3 Structures Concrete Syntax

Structure =
    TypePrefix 'struct'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.4 Associations Concrete Syntax

Association =
    TypePrefix 'assoc'
    ClassifierDeclaration TypeBody

AssociationStructure =
    TypePrefix 'assoc' 'struct'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.5 Connectors Concrete Syntax

// Clause 8.2.5.5.1 Connectors

Connector =
    FeaturePrefix 'connector'
    ( FeatureDeclaration? ValuePart?
    | ConnectorDeclaration
    )
    TypeBody

ConnectorDeclaration : Connector =
    BinaryConnectorDeclaration | NaryConnectorDeclaration

BinaryConnectorDeclaration : Connector =
    ( FeatureDeclaration? 'from' | isSufficient ?= 'all' 'from'? )?
    ownedRelationship += ConnectorEndMember 'to'
    ownedRelationship += ConnectorEndMember

NaryConnectorDeclaration : Connector =
    FeatureDeclaration?
    '(' ownedRelationship += ConnectorEndMember ','
        ownedRelationship += ConnectorEndMember
        ( ',' ownedRelationship += ConnectorEndMember )*
    ')'

ConnectorEndMember : EndFeatureMembership =
    ownedRelatedElement += ConnectorEnd

ConnectorEnd : Feature =

	( ownedRelationship += OwnedCrossMultiplicityMember )?

	( declaredName = NAME REFERENCES )?

	ownedRelationship += OwnedReferenceSubsetting

OwnedCrossMultiplicityMember : OwningMembership =

	ownedRelatedElement += OwnedCrossMultiplicity

OwnedCrossMultiplicity : Feature =

	ownedRelationship += OwnedMultiplicity

// Clause 8.2.5.5.2 Binding Connectors

BindingConnector =
    FeaturePrefix 'binding'
    BindingConnectorDeclaration TypeBody

BindingConnectorDeclaration : BindingConnector =
      FeatureDeclaration
      ( 'of' ownedRelationship += ConnectorEndMember
        '='  ownedRelationship += ConnectorEndMember )?
    | ( isSufficient ?= 'all' )?
      ( 'of'? ownedRelationship += ConnectorEndMember
        '='   ownedRelationship += ConnectorEndMember )?

// Clause 8.2.5.5.3 Successions

Succession =
    FeaturePrefix 'succession'
    SuccessionDeclaration TypeBody

SuccessionDeclaration : Succession =
      FeatureDeclaration
      ( 'first' ownedRelationship += ConnectorEndMember
        'then'  ownedRelationship += ConnectorEndMember )?
    | ( s.isSufficient ?= 'all' )?
      ( 'first'? ownedRelationship += ConnectorEndMember
        'then'   ownedRelationship += ConnectorEndMember )?

// Clause 8.2.5.6 Behaviors Concrete Syntax

// Clause 8.2.5.6.1 Behaviors

Behavior =
    TypePrefix 'behavior'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.6.2 Steps

Step =
    FeaturePrefix
    'step' FeatureDeclaration ValuePart?
    TypeBody

// Clause 8.2.5.7 Functions Concrete Syntax

// Clause 8.2.5.7.1 Functions

Function =
    TypePrefix 'function'
    ClassifierDeclaration FunctionBody

FunctionBody : Type =
    ';' | '{' FunctionBodyPart '}'

FunctionBodyPart : Type =
    ( TypeBodyElement
    | ownedRelationship += ReturnFeatureMember
    )*
   ( ownedRelationship += ResultExpressionMember )?

ReturnFeatureMember : ReturnParameterMembership =
    MemberPrefix 'return'
    ownedRelatedElement += FeatureElement

ResultExpressionMember : ResultExpressionMembership =
    MemberPrefix
    ownedRelatedElement += OwnedExpression

// Clause 8.2.5.7.2 Expressions

Expression =
    FeaturePrefix
    'expr' FeatureDeclaration ValuePart?
    FunctionBody

// Clause 8.2.5.7.3 Predicates

Predicate =
    TypePrefix 'predicate'
    ClassifierDeclaration FunctionBody

// Clause 8.2.5.7.4 Boolean Expressions and Invariants

BooleanExpression =
    FeaturePrefix
    'bool' FeatureDeclaration ValuePart?
    FunctionBody

Invariant =
    FeaturePrefix
    'inv' ( 'true' | isNegated ?= 'false' )?
    FeatureDeclaration ValuePart?
    FunctionBody

// Clause 8.2.5.8 Expressions Concrete Syntax

// Clause 8.2.5.8.1 Operator Expressions

OwnedExpressionReferenceMember : FeatureMembership =
    ownedRelationship += OwnedExpressionReference

OwnedExpressionReference : FeatureReferenceExpression =
    ownedRelationship += OwnedExpressionMember

OwnedExpressionMember : FeatureMembership =
    ownedFeatureMember = OwnedExpression

OwnedExpression : Expression =
      ConditionalExpression
    | ConditionalBinaryOperatorExpression
    | BinaryOperatorExpression
    | UnaryOperatorExpression
    | ClassificationExpression
    | MetaclassificationExpression
    | ExtentExpression
    | PrimaryExpression

ConditionalExpression : OperatorExpression =
    operator = 'if'
    ownedRelationship += ArgumentMember '?'
    ownedRelationship += ArgumentExpressionMember 'else'
    ownedRelationship += ArgumentExpressionMember
    ownedRelationship += EmptyResultMember

ConditionalBinaryOperatorExpression : OperatorExpression =
    ownedRelationship += ArgumentMember
    operator = ConditionalBinaryOperator
    ownedRelationship += ArgumentExpressionMember
    ownedRelationship += EmptyResultMember

ConditionalBinaryOperator =
    '??' | 'or' | 'and' | 'implies'

BinaryOperatorExpression : OperatorExpression =
    ownedRelationship += ArgumentMember
    operator = BinaryOperator
    ownedRelationship += ArgumentMember
    ownedRelationship += EmptyResultMember

BinaryOperator =
      '|'  | '&'  | 'xor' | '..'
    | '==' | '!=' | '===' | '!=='
    | '<'  | '>'  | '<='  | '>='
    | '+'  | '-'  | '*'   | '/'
    | '%'  | '^'  | '**'

UnaryOperatorExpression : OperatorExpression =
    operator = UnaryOperator
    ownedRelationship += ArgumentMember
    ownedRelationship += EmptyResultMember

UnaryOperator =
    '+' | '-' | '~' | 'not'

ClassificationExpression : OperatorExpression =
    ( ownedRelationship += ArgumentMember )?
    ( operator = ClassificationTestOperator
      ownedRelationship += TypeReferenceMember
    | operator = CastOperator
      ownedRelationship += TypeResultMember
    )
    ownedRelationship += EmptyResultMember

ClassificationTestOperator =
    'istype' | 'hastype' | '@'

CastOperator =
    'as'

MetaclassificationExpression : OperatorExpression =
    ownedRelationship += MetadataArgumentMember
    ( operator = MetaClassificationTestOperator
      ownedRelationship += TypeReferenceMember
    | operator = MetaCastOperator
      ownedRelationship += TypeResultMember
    )
    ownedRelationship += EmptyResultMember

ArgumentMember : ParameterMembership =
    ownedMemberParameter = Argument

Argument : Feature =
    ownedRelationship += ArgumentValue

ArgumentValue : FeatureValue =
    value = OwnedExpression

ArgumentExpressionMember : FeatureMembership =
    ownedRelatedElement += ArgumentExpression

ArgumentExpression : Feature =
    ownedRelationship += ArgumentExpressionValue

ArgumentExpressionValue : FeatureValue =
    value = OwnedExpressionReference

MetadataArgumentMember : ParameterMembership =
    ownedRelatedElement += MetadataArgument

MetadataArgument : Feature =
    ownedRelationship += MetadataValue

MetadataValue : FeatureValue =
    value = MetadataReference

MetadataReference : MetadataAccessExpression =
    ownedRelationship += ElementReferenceMember

MetaclassificationTestOperator =
    '@@'

MetaCastOperator =
    'meta'

ExtentExpression : OperatorExpression =
    operator = 'all'
    ownedRelationship += TypeReferenceMember

TypeReferenceMember : FeatureMembership =
    ownedMemberFeature = TypeReference

TypeResultMember : ResultParameterMembership =
    ownedMemberFeature = TypeReference

TypeReference : Feature =
    ownedRelationship += ReferenceTyping

ReferenceTyping : FeatureTyping =
    type = [QualifiedName]

EmptyResultMember : ReturnParameterMembership =
    ownedRelatedElement += EmptyFeature

EmptyFeature : Feature =
    { }

// Clause 8.2.5.8.2 Primary Expressions

PrimaryExpression : Expression =
      FeatureChainExpression
    | NonFeatureChainPrimaryExpression

PrimaryArgumentValue : FeatureValue =
    value = PrimaryExpression

PrimaryArgument : Feature =
    ownedRelationship += PrimaryArgumentValue

PrimaryArgumentMember : ParameterMembershiup =
    ownedMemberParameter = PrimaryArgument

NonFeatureChainPrimaryExpression : Expression =
      BracketExpression
    | IndexExpression
    | SequenceExpression
    | SelectExpression
    | CollectExpression
    | FunctionOperationExpression
    | BaseExpression

NonFeatureChainPrimaryArgumentValue : FeatureValue =
    value = NonFeatureChainPrimaryExpression

NonFeatureChainPrimaryArgument : Feature =
    ownedRelationship += NonFeatureChainPrimaryArgumentValue

NonFeatureChainPrimaryArgumentMember : ParameterMembershiup =
    ownedMemberParameter = PrimaryArgument

BracketExpression : OperatorExpression =
    ownedRelationship += PrimaryArgumentMember
    operator = '['
    ownedRelationship += SequenceExpressionListMember ']'

IndexExpression =
    ownedRelationship += PrimaryArgumentMember '#'
    '(' ownedRelationship += SequenceExpressionListMember ')'

SequenceExpression : Expression =
    '(' SequenceExpressionList ')'

SequenceExpressionList : Expression =
    OwnedExpression ','? | SequenceOperatorExpression

SequenceOperatorExpression : OperatorExpression =
    ownedRelationship += OwnedExpressionMember
    operator = ','
    ownedRelationship += SequenceExpressionListMember

SequenceExpressionListMember : FeatureMembership =
    ownedMemberFeature = SequenceExpressionList

FeatureChainExpression =
    ownedRelationship += NonFeatureChainPrimaryArgumentMember '.'
    ownedRelationship += FeatureChainMember

CollectExpression =
    ownedRelationship += PrimaryArgumentMember '.'
    ownedRelationship += BodyArgumentMember

SelectExpression =
    ownedRelationship += PrimaryArgumentMember '.?'
    ownedRelationship += BodyArgumentMember

FunctionOperationExpression : InvocationExpression =
    ownedRelationship += PrimaryArgumentMember '->'
    ownedRelationship += InvocationTypeMember
    ( ownedRelationship += BodyArgumentMember
    | ownedRelationship += FunctionReferenceArgumentMember
    | ArgumentList )
    ownedRelationship += EmptyResultMember

BodyArgumentMember : ParameterMembershiup =
    ownedMemberParameter = BodyArgument

BodyArgument : Feature =
    ownedRelationship += BodyArgumentValue

BodyArgumentValue : FeatureValue =
    value = BodyExpression

FunctionReferenceArgumentMember : ParameterMembershiup =
    ownedMemberParameter = FunctionReferenceArgument

FunctionReferenceArgument : Feature =
    ownedRelationship += FunctionReferenceArgumentValue

FunctionReferenceArgumentValue : FeatureValue =
    value = FunctionReferenceExpression

FunctionReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FunctionReferenceMember

FunctionReferenceMember : FeatureMembership =
    ownedMemberFeature = FunctionReference

FunctionReference : Expression =
    ownedRelationship += ReferenceTyping

FeatureChainMember : Membership =
      FeatureReferenceMember
    | OwnedFeatureChainMember

OwnedFeatureChainMember : OwningMembership =
    ownedMemberElement = FeatureChain

// Clause 8.2.5.8.3 Base Expressions

BaseExpression : Expression =
      NullExpression
    | LiteralExpression
    | FeatureReferenceExpression
    | MetadataAccessExpression
    | InvocationExpression
    | ConstructorExpression
    | BodyExpression

NullExpression : NullExpression =
    'null' | '(' ')'

FeatureReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FeatureReferenceMember
    ownedRelationship += EmptyResultMember

FeatureReferenceMember : Membership =
    memberElement = FeatureReference

FeatureReference : Feature =
    [QualifiedName]

MetadataAccessExpression =
    ownedRelationship += ElementReferenceMember '.' 'metadata'

ElementReferenceMember : Membership =
    memberElement = [QualifiedName]

InvocationExpression : InvocationExpression =
    ownedRelationship += InstatiatedTypeMember
    ArgumentList
    ownedRelationship += EmptyResultMember

ConstructorExpression =
    'new' ownedRelationship += InstantiatedTypeMember
    ownedRelationship += ConstructorResultMember

ConstructorResultMember : ReturnParameterMembership =
    ownedRelatedElement += ConstructorResult

ConstructorResult : Feature =
    ArgumentList

InstantiatedTypeMember : Membership =
      memberElement = InstantiatedTypeReference
    | OwnedFeatureChainMember

InstantiatedTypeReference : Type =
    [QualifiedName]

ArgumentList : Feature =
    '(' ( PositionalArgumentList | NamedArgumentList )? ')'

PositionalArgumentList : Feature =
    e.ownedRelationship += ArgumentMember
    ( ',' e.ownedRelationship += ArgumentMember )*

NamedArgumentList : Feature =
    ownedRelationship += NamedArgumentMember
    ( ',' ownedRelationship += NamedArgumentMember )*

NamedArgumentMember : FeatureMembership =
    ownedMemberFeature = NamedArgument

NamedArgument : Feature =
    ownedRelationship += ParameterRedefinition '='
    ownedRelationship += ArgumentValue

ParameterRedefinition : Redefinition =
    redefinedFeature = [QualifiedName]

BodyExpression : FeatureReferenceExpression =
    ownedRelationship += ExpressionBodyMember

ExpressionBodyMember : FeatureMembership =
    ownedMemberFeature = ExpressionBody

ExpressionBody : Expression =
    '{' FunctionBodyPart '}'

// Clause 8.2.5.8.4 Literal Expressions

LiteralExpression =
      LiteralBoolean
    | LiteralString
    | LiteralInteger
    | LiteralReal
    | LiteralInfinity

LiteralBoolean =
    value = BooleanValue

BooleanValue : Boolean =
    'true' | 'false'

LiteralString =
    value = STRING_VALUE

LiteralInteger =
    value = DECIMAL_VALUE

LiteralReal =
    value = RealValue

RealValue : Real =
      DECIMAL_VALUE? '.' ( DECIMAL_VALUE | EXPONENTIAL_VALUE )
    | EXPONENTIAL_VALUE

LiteralInfinity =
    '*'

// Clause 8.2.5.9 Interactions Concrete Syntax

// Clause 8.2.5.9.1 Interactions

Interaction =
    TypePrefix 'interaction'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.9.2 Flows

Flow =
    FeaturePrefix 'flow'
    ItemFlowDeclaration TypeBody

SuccessionFlow =
    FeaturePrefix 'succession' 'flow'
    ItemFlowDeclaration TypeBody

FlowDeclaration : Flow =
      FeatureDeclaration ValuePart?
      ( 'of' ownedRelationship += PayloadFeatureMember )?
      ( 'from' ownedRelationship += FlowEndMember
        'to' ownedRelationship += FlowEndMember )?
    | ( isSufficient ?= 'all' )?
      ownedRelationship += FlowEndMember 'to'
      ownedRelationship += FlowEndMember

PayloadFeatureMember : FeatureMembership =
    ownedRelatedElement = PayloadFeature

PayloadFeature =
      Identification PayloadFeatureSpecializationPart ValuePart?
    | Identification ValuePart
    | ( ownedRelationship += OwnedFeatureTyping
      ( ownedRelationship += OwnedMultiplicity )?
    | ownedRelationship += OwnedMultiplicity
      ( ownedRelationship += OwnedFeatureTyping )?

PauloadFeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart?
      FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization+

FlowEndMember : EndFeatureMembership =
    ownedRelatedElement += FlowEnd

FlowEnd =
    ( ownedRelationship += OwnedReferenceSubsetting '.' )?
    ownedRelationship += FlowFeatureMember

FlowFeatureMember : FeatureMembership =
    ownedRelatedElement += FlowFeature

FlowFeature : Feature =
    ownedRelationship += FlowFeatureRedefinition

// (See Note 1)

FlowFeatureRedefinition : Redefinition =
    redefinedFeature = [QualifiedName]

// Notes:
// Note 1: To ensure that an FlowFeature passes the validateRedefinitionDirectionConformance constraint (see 8.3.3.3.8 ), its direction must be set to the direction of its redefinedFeature, relative to its owning FlowEnd, that is, the result of the following OCL expression: owningType.directionOf(ownedRedefinition->at(1).redefinedFeature)

// Clause 8.2.5.10 Feature Values Concrete Syntax

ValuePart : Feature =
    ownedRelationship += FeatureValue

FeatureValue =
    ( '='
    | isInitial ?= ':='
    | isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?
    )
    ownedRelatedElement += OwnedExpression

// Clause 8.2.5.11 Multiplicities Concrete Syntax

Multiplicity =
    MultiplicitySubset | MultiplicityRange

MultiplicitySubset : Multiplicity =
    'multiplicity' Identification Subsets
    TypeBody

MultiplicityRange =
    'multiplicity' Identification MultiplicityBounds
    TypeBody

OwnedMultiplicity : OwningMembership =
    ownedRelatedElement += OwnedMultiplicityRange

OwnedMultiplicityRange : MultiplicityRange =
    MultiplicityBounds

MultiplicityBounds : MultiplicityRange =
    '[' ( ownedRelationship += MultiplicityExpressionMember '..' )?
          ownedRelationship += MultiplicityExpressionMember ']'

MultiplicityExpressionMember : OwningMembership =
    ownedRelatedElement += ( LiteralExpression | FeatureReferenceExpression )

// Clause 8.2.5.12 Metadata Concrete Syntax

Metaclass =
    TypePrefix 'metaclass'
    ClassifierDeclaration TypeBody

PrefixMetadataAnnotation : Annotation =
    '#' ownedRelatedElement += PrefixMetadataFeature

PrefixMetadataMember : OwningMembership =
    '#' ownedRelatedElement += PrefixMetadataFeature
PrefixMetadataFeature : MetadataFeature :
    ownedRelationship += OwnedFeatureTyping

MetadataFeature =
    ( ownedRelationship += PrefixMetadataMember )*
    ( '@' | 'metadata' )
    MetadataFeatureDeclaration
    ( 'about' ownedRelationship += Annotation
      ( ',' ownedRelationship += Annotation )*
    )?
    MetadataBody

MetadataFeatureDeclaration : MetadataFeature =
    ( Identification ( ':' | 'typed' 'by' ) )?
    ownedRelationship += OwnedFeatureTyping

MetadataBody : Feature =
    ';' | '{' ( ownedRelationship += MetadataBodyElement )* '}'

MetadataBodyElement : Membership =
      NonFeatureMember
    | MetadataBodyFeatureMember
    | AliasMember
    | Import

MetadataBodyFeatureMember : FeatureMembership =
    ownedMemberFeature = MetadataBodyFeature

MetadataBodyFeature : Feature =
    'feature'? ( ':>>' | 'redefines')? ownedRelationship += OwnedRedefinition
    FeatureSpecializationPart? ValuePart?
    MetadataBody

// Clause 8.2.5.13 Packages Concrete Syntax

Package =
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody

LibraryPackage =
    ( isStandard ?= 'standard' ) 'library'
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody

PackageDeclaration : Package =
    'package' Identification

PackageBody : Package =
      ';'
    | '{' ( NamespaceBodyElement
          | ownedRelationship += ElementFilterMember
          )*
      '}'

ElementFilterMember : ElementFilterMembership =
    MemberPrefix
    'filter' condition = OwnedExpression ';'

// End of BNF
// Start of Textual Notation Grammar Checks
// 
// Keywords extracted from textual BNF grammar scan:
//   'conjugates'
//   'filter'
// Comparison of declared reserved keywords versus extracted keywords
// 
// Declared reserved keywords not in extracted keywords:
//   
// 
// Extracted keywords not in declared reserved keywords:
//   conjugates, filter
// 
// End of Textual Notation Grammar Checks
// 
// Start of Graphical Notation Grammar Checks
// img_tokens:
// End of Graphical Notation Grammar Checks

