/*
 * generated by Xtext 2.28.0
 */
package org.omg.kerml.expressions.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.omg.kerml.expressions.xtext.services.KerMLExpressionsGrammarAccess;
import org.omg.sysml.lang.sysml.CollectExpression;
import org.omg.sysml.lang.sysml.Expression;
import org.omg.sysml.lang.sysml.Feature;
import org.omg.sysml.lang.sysml.FeatureChainExpression;
import org.omg.sysml.lang.sysml.FeatureChaining;
import org.omg.sysml.lang.sysml.FeatureMembership;
import org.omg.sysml.lang.sysml.FeatureReferenceExpression;
import org.omg.sysml.lang.sysml.FeatureTyping;
import org.omg.sysml.lang.sysml.FeatureValue;
import org.omg.sysml.lang.sysml.InvocationExpression;
import org.omg.sysml.lang.sysml.LiteralBoolean;
import org.omg.sysml.lang.sysml.LiteralInfinity;
import org.omg.sysml.lang.sysml.LiteralInteger;
import org.omg.sysml.lang.sysml.LiteralRational;
import org.omg.sysml.lang.sysml.LiteralString;
import org.omg.sysml.lang.sysml.Membership;
import org.omg.sysml.lang.sysml.MetadataAccessExpression;
import org.omg.sysml.lang.sysml.NullExpression;
import org.omg.sysml.lang.sysml.OperatorExpression;
import org.omg.sysml.lang.sysml.OwningMembership;
import org.omg.sysml.lang.sysml.ParameterMembership;
import org.omg.sysml.lang.sysml.Redefinition;
import org.omg.sysml.lang.sysml.ResultExpressionMembership;
import org.omg.sysml.lang.sysml.ReturnParameterMembership;
import org.omg.sysml.lang.sysml.SelectExpression;
import org.omg.sysml.lang.sysml.SysMLPackage;

@SuppressWarnings("all")
public abstract class AbstractKerMLExpressionsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KerMLExpressionsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SysMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SysMLPackage.COLLECT_EXPRESSION:
				sequence_PrimaryExpression(context, (CollectExpression) semanticObject); 
				return; 
			case SysMLPackage.EXPRESSION:
				if (rule == grammarAccess.getExpressionBodyRule()) {
					sequence_ExpressionBody(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionReferenceRule()) {
					sequence_FunctionReference(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE:
				if (rule == grammarAccess.getArgumentRule()) {
					sequence_Argument(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBodyParameterRule()) {
					sequence_BodyParameter(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmptyFeatureRule()) {
					sequence_EmptyFeature(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOwnedFeatureChainRule()) {
					sequence_FeatureChain(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNamedArgumentRule()) {
					sequence_NamedArgument(context, (Feature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeReferenceRule()) {
					sequence_TypeReference(context, (Feature) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_CHAIN_EXPRESSION:
				sequence_PrimaryExpression(context, (FeatureChainExpression) semanticObject); 
				return; 
			case SysMLPackage.FEATURE_CHAINING:
				sequence_OwnedFeatureChaining(context, (FeatureChaining) semanticObject); 
				return; 
			case SysMLPackage.FEATURE_MEMBERSHIP:
				if (rule == grammarAccess.getEqualityExpressionMemberRule()) {
					sequence_EqualityExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionBodyMemberRule()) {
					sequence_ExpressionBodyMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionReferenceMemberRule()) {
					sequence_FunctionReferenceMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImpliesExpressionMemberRule()) {
					sequence_ImpliesExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrExpressionMemberRule()) {
					sequence_OrExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOwnedExpressionMemberRule()) {
					sequence_OwnedExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeReferenceMemberRule()) {
					sequence_TypeReferenceMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXorExpressionMemberRule()) {
					sequence_XorExpressionMember(context, (FeatureMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_REFERENCE_EXPRESSION:
				if (rule == grammarAccess.getBodyExpressionRule()) {
					sequence_BodyExpression(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOwnedExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()
						|| rule == grammarAccess.getNullCoalescingExpressionRule()
						|| action == grammarAccess.getNullCoalescingExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getClassificationExpressionRule()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_0_1_0_0()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_0_1_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getExponentiationExpressionRule()
						|| action == grammarAccess.getExponentiationExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getExtentExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getFeatureChainExpressionOperandAction_1_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_0_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_1_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_2_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getCollectExpressionOperandAction_2_0_3_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getSelectExpressionOperandAction_2_0_4_0()
						|| rule == grammarAccess.getBaseExpressionRule()
						|| rule == grammarAccess.getSequenceExpressionRule()
						|| action == grammarAccess.getSequenceExpressionAccess().getOperatorExpressionOperandAction_1_1_0()) {
					sequence_BodyExpression_FeatureReferenceExpression(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEqualityExpressionReferenceRule()) {
					sequence_EqualityExpressionReference(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureReferenceExpressionRule()) {
					sequence_FeatureReferenceExpression(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionReferenceExpressionRule()) {
					sequence_FunctionReferenceExpression(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImpliesExpressionReferenceRule()) {
					sequence_ImpliesExpressionReference(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrExpressionReferenceRule()) {
					sequence_OrExpressionReference(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOwnedExpressionReferenceRule()) {
					sequence_OwnedExpressionReference(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelfReferenceExpressionRule()) {
					sequence_SelfReferenceExpression(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXorExpressionReferenceRule()) {
					sequence_XorExpressionReference(context, (FeatureReferenceExpression) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_TYPING:
				if (rule == grammarAccess.getOwnedFeatureTypingRule()) {
					sequence_OwnedFeatureTyping(context, (FeatureTyping) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReferenceTypingRule()) {
					sequence_ReferenceTyping(context, (FeatureTyping) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.FEATURE_VALUE:
				sequence_ArgumentValue(context, (FeatureValue) semanticObject); 
				return; 
			case SysMLPackage.INVOCATION_EXPRESSION:
				sequence_InvocationExpression_NamedArgumentList_PositionalArgumentList(context, (InvocationExpression) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_BOOLEAN:
				sequence_LiteralBoolean(context, (LiteralBoolean) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_INFINITY:
				sequence_LiteralInfinity(context, (LiteralInfinity) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_INTEGER:
				sequence_LiteralInteger(context, (LiteralInteger) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_RATIONAL:
				sequence_LiteralReal(context, (LiteralRational) semanticObject); 
				return; 
			case SysMLPackage.LITERAL_STRING:
				sequence_LiteralString(context, (LiteralString) semanticObject); 
				return; 
			case SysMLPackage.MEMBERSHIP:
				if (rule == grammarAccess.getFeatureChainMemberRule()) {
					sequence_FeatureChainMember(context, (Membership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureReferenceMemberRule()) {
					sequence_FeatureReferenceMember(context, (Membership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.METADATA_ACCESS_EXPRESSION:
				if (rule == grammarAccess.getOwnedExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()
						|| rule == grammarAccess.getNullCoalescingExpressionRule()
						|| action == grammarAccess.getNullCoalescingExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getClassificationExpressionRule()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_0_1_0_0()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_0_1_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getExponentiationExpressionRule()
						|| action == grammarAccess.getExponentiationExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getExtentExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getFeatureChainExpressionOperandAction_1_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_0_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_1_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_2_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getCollectExpressionOperandAction_2_0_3_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getSelectExpressionOperandAction_2_0_4_0()
						|| rule == grammarAccess.getBaseExpressionRule()
						|| rule == grammarAccess.getSequenceExpressionRule()
						|| action == grammarAccess.getSequenceExpressionAccess().getOperatorExpressionOperandAction_1_1_0()
						|| rule == grammarAccess.getMetadataAccessExpressionRule()) {
					sequence_MetadataAccessExpression(context, (MetadataAccessExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMetadataReferenceRule()) {
					sequence_MetadataReference(context, (MetadataAccessExpression) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.NULL_EXPRESSION:
				sequence_NullExpression(context, (NullExpression) semanticObject); 
				return; 
			case SysMLPackage.OPERATOR_EXPRESSION:
				if (rule == grammarAccess.getOwnedExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()
						|| rule == grammarAccess.getNullCoalescingExpressionRule()
						|| action == grammarAccess.getNullCoalescingExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getXorExpressionRule()
						|| action == grammarAccess.getXorExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getClassificationExpressionRule()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_0_1_0_0()
						|| action == grammarAccess.getClassificationExpressionAccess().getOperatorExpressionOperandAction_0_1_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getRangeExpressionRule()
						|| action == grammarAccess.getRangeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getExponentiationExpressionRule()
						|| action == grammarAccess.getExponentiationExpressionAccess().getOperatorExpressionOperandAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getExtentExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getFeatureChainExpressionOperandAction_1_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_0_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_1_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getOperatorExpressionOperandAction_2_0_2_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getCollectExpressionOperandAction_2_0_3_0()
						|| action == grammarAccess.getPrimaryExpressionAccess().getSelectExpressionOperandAction_2_0_4_0()
						|| rule == grammarAccess.getBaseExpressionRule()
						|| rule == grammarAccess.getSequenceExpressionRule()
						|| action == grammarAccess.getSequenceExpressionAccess().getOperatorExpressionOperandAction_1_1_0()) {
					sequence_AdditiveExpression_AndExpression_ClassificationExpression_ConditionalExpression_EqualityExpression_ExponentiationExpression_ExtentExpression_ImpliesExpression_MultiplicativeExpression_NamedArgumentList_NullCoalescingExpression_OrExpression_PositionalArgumentList_PrimaryExpression_RangeExpression_RelationalExpression_SequenceExpression_UnaryExpression_XorExpression(context, (OperatorExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getPrimaryExpressionAccess().getFeatureChainExpressionOperandAction_2_1_0()) {
					sequence_NamedArgumentList_PositionalArgumentList_PrimaryExpression_FeatureChainExpression_2_1_0(context, (OperatorExpression) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.OWNING_MEMBERSHIP:
				sequence_FeatureChainMember(context, (OwningMembership) semanticObject); 
				return; 
			case SysMLPackage.PARAMETER_MEMBERSHIP:
				if (rule == grammarAccess.getArgumentMemberRule()) {
					sequence_ArgumentMember(context, (ParameterMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBodyParameterMemberRule()) {
					sequence_BodyParameterMember(context, (ParameterMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNamedArgumentMemberRule()) {
					sequence_NamedArgumentMember(context, (ParameterMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.REDEFINITION:
				sequence_ParameterRedefinition(context, (Redefinition) semanticObject); 
				return; 
			case SysMLPackage.RESULT_EXPRESSION_MEMBERSHIP:
				sequence_ResultExpressionMember(context, (ResultExpressionMembership) semanticObject); 
				return; 
			case SysMLPackage.RETURN_PARAMETER_MEMBERSHIP:
				if (rule == grammarAccess.getSelfReferenceMemberRule()) {
					sequence_SelfReferenceMember(context, (ReturnParameterMembership) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeResultMemberRule()) {
					sequence_TypeResultMember(context, (ReturnParameterMembership) semanticObject); 
					return; 
				}
				else break;
			case SysMLPackage.SELECT_EXPRESSION:
				sequence_PrimaryExpression(context, (SelectExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns OperatorExpression
	 *     ConditionalExpression returns OperatorExpression
	 *     NullCoalescingExpression returns OperatorExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     ImpliesExpression returns OperatorExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     OrExpression returns OperatorExpression
	 *     OrExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     XorExpression returns OperatorExpression
	 *     XorExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     AndExpression returns OperatorExpression
	 *     AndExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     EqualityExpression returns OperatorExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     ClassificationExpression returns OperatorExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns OperatorExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns OperatorExpression
	 *     RelationalExpression returns OperatorExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     RangeExpression returns OperatorExpression
	 *     RangeExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     AdditiveExpression returns OperatorExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     MultiplicativeExpression returns OperatorExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     ExponentiationExpression returns OperatorExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns OperatorExpression
	 *     UnaryExpression returns OperatorExpression
	 *     ExtentExpression returns OperatorExpression
	 *     PrimaryExpression returns OperatorExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns OperatorExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns OperatorExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns OperatorExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns OperatorExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns OperatorExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns OperatorExpression
	 *     BaseExpression returns OperatorExpression
	 *     SequenceExpression returns OperatorExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns OperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         (operator=ConditionalOperator operand+=NullCoalescingExpression operand+=OwnedExpressionReference operand+=OwnedExpressionReference) | 
	 *         (operand+=NullCoalescingExpression_OperatorExpression_1_0 operator=NullCoalescingOperator operand+=ImpliesExpressionReference) | 
	 *         (operand+=ImpliesExpression_OperatorExpression_1_0 operator=ImpliesOperator operand+=OrExpressionReference) | 
	 *         (
	 *             operand+=OrExpression_OperatorExpression_1_0 
	 *             ((operator=OrOperator operand+=XorExpression) | (operator=ConditionalOrOperator operand+=XorExpressionReference))
	 *         ) | 
	 *         (operand+=XorExpression_OperatorExpression_1_0 operator=XorOperator operand+=AndExpression) | 
	 *         (
	 *             operand+=AndExpression_OperatorExpression_1_0 
	 *             ((operator=AndOperator operand+=EqualityExpression) | (operator=ConditionalAndOperator operand+=EqualityExpressionReference))
	 *         ) | 
	 *         (operand+=EqualityExpression_OperatorExpression_1_0 operator=EqualityOperator operand+=ClassificationExpression) | 
	 *         (operand+=ClassificationExpression_OperatorExpression_0_1_0_0 operator=ClassificationTestOperator ownedRelationship+=TypeReferenceMember) | 
	 *         (operand+=ClassificationExpression_OperatorExpression_0_1_1_0 operator=CastOperator ownedRelationship+=TypeResultMember) | 
	 *         (operand+=SelfReferenceExpression operator=ClassificationTestOperator ownedRelationship+=TypeReferenceMember) | 
	 *         (operand+=MetadataReference operator=MetaClassificationTestOperator ownedRelationship+=TypeReferenceMember) | 
	 *         (operand+=SelfReferenceExpression operator=CastOperator ownedRelationship+=TypeResultMember) | 
	 *         (operand+=MetadataReference operator=MetaCastOperator ownedRelationship+=TypeResultMember) | 
	 *         (operand+=RelationalExpression_OperatorExpression_1_0 operator=RelationalOperator operand+=RangeExpression) | 
	 *         (operand+=RangeExpression_OperatorExpression_1_0 operator='..' operand+=AdditiveExpression) | 
	 *         (operand+=AdditiveExpression_OperatorExpression_1_0 operator=AdditiveOperator operand+=MultiplicativeExpression) | 
	 *         (operand+=MultiplicativeExpression_OperatorExpression_1_0 operator=MultiplicativeOperator operand+=ExponentiationExpression) | 
	 *         (operand+=ExponentiationExpression_OperatorExpression_1_0 operator=ExponentiationOperator operand+=UnaryExpression) | 
	 *         (operator=UnaryOperator operand+=ExtentExpression) | 
	 *         (operator='all' ownedRelationship+=TypeResultMember) | 
	 *         (operand+=PrimaryExpression_OperatorExpression_2_0_0_0 operator='#' operand+=SequenceExpression) | 
	 *         (operand+=PrimaryExpression_OperatorExpression_2_0_1_0 operator='[' operand+=SequenceExpression) | 
	 *         (
	 *             operand+=PrimaryExpression_OperatorExpression_2_0_2_0 
	 *             ownedRelationship+=ReferenceTyping 
	 *             (
	 *                 operand+=BodyExpression | 
	 *                 operand+=FunctionReferenceExpression | 
	 *                 (ownedRelationship+=ArgumentMember ownedRelationship+=ArgumentMember*) | 
	 *                 (ownedRelationship+=NamedArgumentMember ownedRelationship+=NamedArgumentMember*)
	 *             )?
	 *         ) | 
	 *         (operand+=SequenceExpression_OperatorExpression_1_1_0 operator=',' operand+=SequenceExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_AdditiveExpression_AndExpression_ClassificationExpression_ConditionalExpression_EqualityExpression_ExponentiationExpression_ExtentExpression_ImpliesExpression_MultiplicativeExpression_NamedArgumentList_NullCoalescingExpression_OrExpression_PositionalArgumentList_PrimaryExpression_RangeExpression_RelationalExpression_SequenceExpression_UnaryExpression_XorExpression(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentMember returns ParameterMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=Argument
	 * </pre>
	 */
	protected void sequence_ArgumentMember(ISerializationContext context, ParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentValue returns FeatureValue
	 *
	 * Constraint:
	 *     ownedRelatedElement+=OwnedExpression
	 * </pre>
	 */
	protected void sequence_ArgumentValue(ISerializationContext context, FeatureValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Argument returns Feature
	 *
	 * Constraint:
	 *     ownedRelationship+=ArgumentValue
	 * </pre>
	 */
	protected void sequence_Argument(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BodyExpression returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=ExpressionBodyMember
	 * </pre>
	 */
	protected void sequence_BodyExpression(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns FeatureReferenceExpression
	 *     ConditionalExpression returns FeatureReferenceExpression
	 *     NullCoalescingExpression returns FeatureReferenceExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     ImpliesExpression returns FeatureReferenceExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     OrExpression returns FeatureReferenceExpression
	 *     OrExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     XorExpression returns FeatureReferenceExpression
	 *     XorExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     AndExpression returns FeatureReferenceExpression
	 *     AndExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     EqualityExpression returns FeatureReferenceExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     ClassificationExpression returns FeatureReferenceExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns FeatureReferenceExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns FeatureReferenceExpression
	 *     RelationalExpression returns FeatureReferenceExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     RangeExpression returns FeatureReferenceExpression
	 *     RangeExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     AdditiveExpression returns FeatureReferenceExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     MultiplicativeExpression returns FeatureReferenceExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     ExponentiationExpression returns FeatureReferenceExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns FeatureReferenceExpression
	 *     UnaryExpression returns FeatureReferenceExpression
	 *     ExtentExpression returns FeatureReferenceExpression
	 *     PrimaryExpression returns FeatureReferenceExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns FeatureReferenceExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns FeatureReferenceExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns FeatureReferenceExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns FeatureReferenceExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns FeatureReferenceExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns FeatureReferenceExpression
	 *     BaseExpression returns FeatureReferenceExpression
	 *     SequenceExpression returns FeatureReferenceExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     (ownedRelationship+=ExpressionBodyMember | ownedRelationship+=FeatureReferenceMember)
	 * </pre>
	 */
	protected void sequence_BodyExpression_FeatureReferenceExpression(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BodyParameterMember returns ParameterMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=BodyParameter
	 * </pre>
	 */
	protected void sequence_BodyParameterMember(ISerializationContext context, ParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BodyParameter returns Feature
	 *
	 * Constraint:
	 *     declaredName=Name
	 * </pre>
	 */
	protected void sequence_BodyParameter(ISerializationContext context, Feature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.ELEMENT__DECLARED_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.ELEMENT__DECLARED_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBodyParameterAccess().getDeclaredNameNameParserRuleCall_0(), semanticObject.getDeclaredName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EmptyFeature returns Feature
	 *
	 * Constraint:
	 *     {Feature}
	 * </pre>
	 */
	protected void sequence_EmptyFeature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=EqualityExpression
	 * </pre>
	 */
	protected void sequence_EqualityExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityExpressionReference returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=EqualityExpressionMember
	 * </pre>
	 */
	protected void sequence_EqualityExpressionReference(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBodyMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=ExpressionBody
	 * </pre>
	 */
	protected void sequence_ExpressionBodyMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBody returns Expression
	 *
	 * Constraint:
	 *     (ownedRelationship+=BodyParameterMember* ownedRelationship+=ResultExpressionMember)
	 * </pre>
	 */
	protected void sequence_ExpressionBody(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureChainMember returns Membership
	 *
	 * Constraint:
	 *     memberElement=[Feature|QualifiedName]
	 * </pre>
	 */
	protected void sequence_FeatureChainMember(ISerializationContext context, Membership semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.MEMBERSHIP__MEMBER_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.MEMBERSHIP__MEMBER_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureChainMemberAccess().getMemberElementFeatureQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SysMLPackage.Literals.MEMBERSHIP__MEMBER_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureChainMember returns OwningMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=OwnedFeatureChain
	 * </pre>
	 */
	protected void sequence_FeatureChainMember(ISerializationContext context, OwningMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedFeatureChain returns Feature
	 *
	 * Constraint:
	 *     (ownedRelationship+=OwnedFeatureChaining ownedRelationship+=OwnedFeatureChaining+)
	 * </pre>
	 */
	protected void sequence_FeatureChain(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureReferenceExpression returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=FeatureReferenceMember
	 * </pre>
	 */
	protected void sequence_FeatureReferenceExpression(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureReferenceMember returns Membership
	 *
	 * Constraint:
	 *     memberElement=[Feature|QualifiedName]
	 * </pre>
	 */
	protected void sequence_FeatureReferenceMember(ISerializationContext context, Membership semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.MEMBERSHIP__MEMBER_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.MEMBERSHIP__MEMBER_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureReferenceMemberAccess().getMemberElementFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.MEMBERSHIP__MEMBER_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionReferenceExpression returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=FunctionReferenceMember
	 * </pre>
	 */
	protected void sequence_FunctionReferenceExpression(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionReferenceMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=FunctionReference
	 * </pre>
	 */
	protected void sequence_FunctionReferenceMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionReference returns Expression
	 *
	 * Constraint:
	 *     ownedRelationship+=ReferenceTyping
	 * </pre>
	 */
	protected void sequence_FunctionReference(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImpliesExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=ImpliesExpression
	 * </pre>
	 */
	protected void sequence_ImpliesExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImpliesExpressionReference returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=ImpliesExpressionMember
	 * </pre>
	 */
	protected void sequence_ImpliesExpressionReference(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns InvocationExpression
	 *     ConditionalExpression returns InvocationExpression
	 *     NullCoalescingExpression returns InvocationExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     ImpliesExpression returns InvocationExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     OrExpression returns InvocationExpression
	 *     OrExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     XorExpression returns InvocationExpression
	 *     XorExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     AndExpression returns InvocationExpression
	 *     AndExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     EqualityExpression returns InvocationExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     ClassificationExpression returns InvocationExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns InvocationExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns InvocationExpression
	 *     RelationalExpression returns InvocationExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     RangeExpression returns InvocationExpression
	 *     RangeExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     AdditiveExpression returns InvocationExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     MultiplicativeExpression returns InvocationExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     ExponentiationExpression returns InvocationExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns InvocationExpression
	 *     UnaryExpression returns InvocationExpression
	 *     ExtentExpression returns InvocationExpression
	 *     PrimaryExpression returns InvocationExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns InvocationExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns InvocationExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns InvocationExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns InvocationExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns InvocationExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns InvocationExpression
	 *     BaseExpression returns InvocationExpression
	 *     SequenceExpression returns InvocationExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns InvocationExpression
	 *     InvocationExpression returns InvocationExpression
	 *
	 * Constraint:
	 *     (
	 *         ownedRelationship+=OwnedFeatureTyping 
	 *         (
	 *             (ownedRelationship+=ArgumentMember ownedRelationship+=ArgumentMember*) | 
	 *             (ownedRelationship+=NamedArgumentMember ownedRelationship+=NamedArgumentMember*)
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_InvocationExpression_NamedArgumentList_PositionalArgumentList(ISerializationContext context, InvocationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns LiteralBoolean
	 *     ConditionalExpression returns LiteralBoolean
	 *     NullCoalescingExpression returns LiteralBoolean
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     ImpliesExpression returns LiteralBoolean
	 *     ImpliesExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     OrExpression returns LiteralBoolean
	 *     OrExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     XorExpression returns LiteralBoolean
	 *     XorExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     AndExpression returns LiteralBoolean
	 *     AndExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     EqualityExpression returns LiteralBoolean
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     ClassificationExpression returns LiteralBoolean
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns LiteralBoolean
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns LiteralBoolean
	 *     RelationalExpression returns LiteralBoolean
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     RangeExpression returns LiteralBoolean
	 *     RangeExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     AdditiveExpression returns LiteralBoolean
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     MultiplicativeExpression returns LiteralBoolean
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     ExponentiationExpression returns LiteralBoolean
	 *     ExponentiationExpression.OperatorExpression_1_0 returns LiteralBoolean
	 *     UnaryExpression returns LiteralBoolean
	 *     ExtentExpression returns LiteralBoolean
	 *     PrimaryExpression returns LiteralBoolean
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns LiteralBoolean
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns LiteralBoolean
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns LiteralBoolean
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns LiteralBoolean
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns LiteralBoolean
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns LiteralBoolean
	 *     BaseExpression returns LiteralBoolean
	 *     SequenceExpression returns LiteralBoolean
	 *     SequenceExpression.OperatorExpression_1_1_0 returns LiteralBoolean
	 *     LiteralExpression returns LiteralBoolean
	 *     LiteralBoolean returns LiteralBoolean
	 *
	 * Constraint:
	 *     value=BooleanValue
	 * </pre>
	 */
	protected void sequence_LiteralBoolean(ISerializationContext context, LiteralBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralBooleanAccess().getValueBooleanValueParserRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns LiteralInfinity
	 *     ConditionalExpression returns LiteralInfinity
	 *     NullCoalescingExpression returns LiteralInfinity
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     ImpliesExpression returns LiteralInfinity
	 *     ImpliesExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     OrExpression returns LiteralInfinity
	 *     OrExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     XorExpression returns LiteralInfinity
	 *     XorExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     AndExpression returns LiteralInfinity
	 *     AndExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     EqualityExpression returns LiteralInfinity
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     ClassificationExpression returns LiteralInfinity
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns LiteralInfinity
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns LiteralInfinity
	 *     RelationalExpression returns LiteralInfinity
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     RangeExpression returns LiteralInfinity
	 *     RangeExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     AdditiveExpression returns LiteralInfinity
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     MultiplicativeExpression returns LiteralInfinity
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     ExponentiationExpression returns LiteralInfinity
	 *     ExponentiationExpression.OperatorExpression_1_0 returns LiteralInfinity
	 *     UnaryExpression returns LiteralInfinity
	 *     ExtentExpression returns LiteralInfinity
	 *     PrimaryExpression returns LiteralInfinity
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns LiteralInfinity
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns LiteralInfinity
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns LiteralInfinity
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns LiteralInfinity
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns LiteralInfinity
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns LiteralInfinity
	 *     BaseExpression returns LiteralInfinity
	 *     SequenceExpression returns LiteralInfinity
	 *     SequenceExpression.OperatorExpression_1_1_0 returns LiteralInfinity
	 *     LiteralExpression returns LiteralInfinity
	 *     LiteralInfinity returns LiteralInfinity
	 *
	 * Constraint:
	 *     {LiteralInfinity}
	 * </pre>
	 */
	protected void sequence_LiteralInfinity(ISerializationContext context, LiteralInfinity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns LiteralInteger
	 *     ConditionalExpression returns LiteralInteger
	 *     NullCoalescingExpression returns LiteralInteger
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     ImpliesExpression returns LiteralInteger
	 *     ImpliesExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     OrExpression returns LiteralInteger
	 *     OrExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     XorExpression returns LiteralInteger
	 *     XorExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     AndExpression returns LiteralInteger
	 *     AndExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     EqualityExpression returns LiteralInteger
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     ClassificationExpression returns LiteralInteger
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns LiteralInteger
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns LiteralInteger
	 *     RelationalExpression returns LiteralInteger
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     RangeExpression returns LiteralInteger
	 *     RangeExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     AdditiveExpression returns LiteralInteger
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     MultiplicativeExpression returns LiteralInteger
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     ExponentiationExpression returns LiteralInteger
	 *     ExponentiationExpression.OperatorExpression_1_0 returns LiteralInteger
	 *     UnaryExpression returns LiteralInteger
	 *     ExtentExpression returns LiteralInteger
	 *     PrimaryExpression returns LiteralInteger
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns LiteralInteger
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns LiteralInteger
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns LiteralInteger
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns LiteralInteger
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns LiteralInteger
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns LiteralInteger
	 *     BaseExpression returns LiteralInteger
	 *     SequenceExpression returns LiteralInteger
	 *     SequenceExpression.OperatorExpression_1_1_0 returns LiteralInteger
	 *     LiteralExpression returns LiteralInteger
	 *     LiteralInteger returns LiteralInteger
	 *
	 * Constraint:
	 *     value=DECIMAL_VALUE
	 * </pre>
	 */
	protected void sequence_LiteralInteger(ISerializationContext context, LiteralInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralIntegerAccess().getValueDECIMAL_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns LiteralRational
	 *     ConditionalExpression returns LiteralRational
	 *     NullCoalescingExpression returns LiteralRational
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralRational
	 *     ImpliesExpression returns LiteralRational
	 *     ImpliesExpression.OperatorExpression_1_0 returns LiteralRational
	 *     OrExpression returns LiteralRational
	 *     OrExpression.OperatorExpression_1_0 returns LiteralRational
	 *     XorExpression returns LiteralRational
	 *     XorExpression.OperatorExpression_1_0 returns LiteralRational
	 *     AndExpression returns LiteralRational
	 *     AndExpression.OperatorExpression_1_0 returns LiteralRational
	 *     EqualityExpression returns LiteralRational
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralRational
	 *     ClassificationExpression returns LiteralRational
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns LiteralRational
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns LiteralRational
	 *     RelationalExpression returns LiteralRational
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralRational
	 *     RangeExpression returns LiteralRational
	 *     RangeExpression.OperatorExpression_1_0 returns LiteralRational
	 *     AdditiveExpression returns LiteralRational
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralRational
	 *     MultiplicativeExpression returns LiteralRational
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralRational
	 *     ExponentiationExpression returns LiteralRational
	 *     ExponentiationExpression.OperatorExpression_1_0 returns LiteralRational
	 *     UnaryExpression returns LiteralRational
	 *     ExtentExpression returns LiteralRational
	 *     PrimaryExpression returns LiteralRational
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns LiteralRational
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns LiteralRational
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns LiteralRational
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns LiteralRational
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns LiteralRational
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns LiteralRational
	 *     BaseExpression returns LiteralRational
	 *     SequenceExpression returns LiteralRational
	 *     SequenceExpression.OperatorExpression_1_1_0 returns LiteralRational
	 *     LiteralExpression returns LiteralRational
	 *     LiteralReal returns LiteralRational
	 *
	 * Constraint:
	 *     value=RealValue
	 * </pre>
	 */
	protected void sequence_LiteralReal(ISerializationContext context, LiteralRational semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_RATIONAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_RATIONAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralRealAccess().getValueRealValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns LiteralString
	 *     ConditionalExpression returns LiteralString
	 *     NullCoalescingExpression returns LiteralString
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns LiteralString
	 *     ImpliesExpression returns LiteralString
	 *     ImpliesExpression.OperatorExpression_1_0 returns LiteralString
	 *     OrExpression returns LiteralString
	 *     OrExpression.OperatorExpression_1_0 returns LiteralString
	 *     XorExpression returns LiteralString
	 *     XorExpression.OperatorExpression_1_0 returns LiteralString
	 *     AndExpression returns LiteralString
	 *     AndExpression.OperatorExpression_1_0 returns LiteralString
	 *     EqualityExpression returns LiteralString
	 *     EqualityExpression.OperatorExpression_1_0 returns LiteralString
	 *     ClassificationExpression returns LiteralString
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns LiteralString
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns LiteralString
	 *     RelationalExpression returns LiteralString
	 *     RelationalExpression.OperatorExpression_1_0 returns LiteralString
	 *     RangeExpression returns LiteralString
	 *     RangeExpression.OperatorExpression_1_0 returns LiteralString
	 *     AdditiveExpression returns LiteralString
	 *     AdditiveExpression.OperatorExpression_1_0 returns LiteralString
	 *     MultiplicativeExpression returns LiteralString
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns LiteralString
	 *     ExponentiationExpression returns LiteralString
	 *     ExponentiationExpression.OperatorExpression_1_0 returns LiteralString
	 *     UnaryExpression returns LiteralString
	 *     ExtentExpression returns LiteralString
	 *     PrimaryExpression returns LiteralString
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns LiteralString
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns LiteralString
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns LiteralString
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns LiteralString
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns LiteralString
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns LiteralString
	 *     BaseExpression returns LiteralString
	 *     SequenceExpression returns LiteralString
	 *     SequenceExpression.OperatorExpression_1_1_0 returns LiteralString
	 *     LiteralExpression returns LiteralString
	 *     LiteralString returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING_VALUE
	 * </pre>
	 */
	protected void sequence_LiteralString(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralStringAccess().getValueSTRING_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns MetadataAccessExpression
	 *     ConditionalExpression returns MetadataAccessExpression
	 *     NullCoalescingExpression returns MetadataAccessExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     ImpliesExpression returns MetadataAccessExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     OrExpression returns MetadataAccessExpression
	 *     OrExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     XorExpression returns MetadataAccessExpression
	 *     XorExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     AndExpression returns MetadataAccessExpression
	 *     AndExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     EqualityExpression returns MetadataAccessExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     ClassificationExpression returns MetadataAccessExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns MetadataAccessExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns MetadataAccessExpression
	 *     RelationalExpression returns MetadataAccessExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     RangeExpression returns MetadataAccessExpression
	 *     RangeExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     AdditiveExpression returns MetadataAccessExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     MultiplicativeExpression returns MetadataAccessExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     ExponentiationExpression returns MetadataAccessExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns MetadataAccessExpression
	 *     UnaryExpression returns MetadataAccessExpression
	 *     ExtentExpression returns MetadataAccessExpression
	 *     PrimaryExpression returns MetadataAccessExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns MetadataAccessExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns MetadataAccessExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns MetadataAccessExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns MetadataAccessExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns MetadataAccessExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns MetadataAccessExpression
	 *     BaseExpression returns MetadataAccessExpression
	 *     SequenceExpression returns MetadataAccessExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns MetadataAccessExpression
	 *     MetadataAccessExpression returns MetadataAccessExpression
	 *
	 * Constraint:
	 *     referencedElement=[Element|QualifiedName]
	 * </pre>
	 */
	protected void sequence_MetadataAccessExpression(ISerializationContext context, MetadataAccessExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.METADATA_ACCESS_EXPRESSION__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.METADATA_ACCESS_EXPRESSION__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetadataAccessExpressionAccess().getReferencedElementElementQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SysMLPackage.Literals.METADATA_ACCESS_EXPRESSION__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MetadataReference returns MetadataAccessExpression
	 *
	 * Constraint:
	 *     referencedElement=[Element|QualifiedName]
	 * </pre>
	 */
	protected void sequence_MetadataReference(ISerializationContext context, MetadataAccessExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.METADATA_ACCESS_EXPRESSION__REFERENCED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.METADATA_ACCESS_EXPRESSION__REFERENCED_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetadataReferenceAccess().getReferencedElementElementQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.METADATA_ACCESS_EXPRESSION__REFERENCED_ELEMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression.FeatureChainExpression_2_1_0 returns OperatorExpression
	 *
	 * Constraint:
	 *     (
	 *         (operand+=PrimaryExpression_OperatorExpression_2_0_0_0 operator='#' operand+=SequenceExpression) | 
	 *         (operand+=PrimaryExpression_OperatorExpression_2_0_1_0 operator='[' operand+=SequenceExpression) | 
	 *         (
	 *             operand+=PrimaryExpression_OperatorExpression_2_0_2_0 
	 *             ownedRelationship+=ReferenceTyping 
	 *             (
	 *                 operand+=BodyExpression | 
	 *                 operand+=FunctionReferenceExpression | 
	 *                 (ownedRelationship+=ArgumentMember ownedRelationship+=ArgumentMember*) | 
	 *                 (ownedRelationship+=NamedArgumentMember ownedRelationship+=NamedArgumentMember*)
	 *             )?
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_NamedArgumentList_PositionalArgumentList_PrimaryExpression_FeatureChainExpression_2_1_0(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedArgumentMember returns ParameterMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=NamedArgument
	 * </pre>
	 */
	protected void sequence_NamedArgumentMember(ISerializationContext context, ParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedArgument returns Feature
	 *
	 * Constraint:
	 *     (ownedRelationship+=ParameterRedefinition ownedRelationship+=ArgumentValue)
	 * </pre>
	 */
	protected void sequence_NamedArgument(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns NullExpression
	 *     ConditionalExpression returns NullExpression
	 *     NullCoalescingExpression returns NullExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns NullExpression
	 *     ImpliesExpression returns NullExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns NullExpression
	 *     OrExpression returns NullExpression
	 *     OrExpression.OperatorExpression_1_0 returns NullExpression
	 *     XorExpression returns NullExpression
	 *     XorExpression.OperatorExpression_1_0 returns NullExpression
	 *     AndExpression returns NullExpression
	 *     AndExpression.OperatorExpression_1_0 returns NullExpression
	 *     EqualityExpression returns NullExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns NullExpression
	 *     ClassificationExpression returns NullExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns NullExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns NullExpression
	 *     RelationalExpression returns NullExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns NullExpression
	 *     RangeExpression returns NullExpression
	 *     RangeExpression.OperatorExpression_1_0 returns NullExpression
	 *     AdditiveExpression returns NullExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns NullExpression
	 *     MultiplicativeExpression returns NullExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns NullExpression
	 *     ExponentiationExpression returns NullExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns NullExpression
	 *     UnaryExpression returns NullExpression
	 *     ExtentExpression returns NullExpression
	 *     PrimaryExpression returns NullExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns NullExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns NullExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns NullExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns NullExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns NullExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns NullExpression
	 *     BaseExpression returns NullExpression
	 *     SequenceExpression returns NullExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns NullExpression
	 *     NullExpression returns NullExpression
	 *
	 * Constraint:
	 *     {NullExpression}
	 * </pre>
	 */
	protected void sequence_NullExpression(ISerializationContext context, NullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OrExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=OrExpression
	 * </pre>
	 */
	protected void sequence_OrExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OrExpressionReference returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=OrExpressionMember
	 * </pre>
	 */
	protected void sequence_OrExpressionReference(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=OwnedExpression
	 * </pre>
	 */
	protected void sequence_OwnedExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpressionReference returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=OwnedExpressionMember
	 * </pre>
	 */
	protected void sequence_OwnedExpressionReference(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedFeatureChaining returns FeatureChaining
	 *
	 * Constraint:
	 *     chainingFeature=[Feature|QualifiedName]
	 * </pre>
	 */
	protected void sequence_OwnedFeatureChaining(ISerializationContext context, FeatureChaining semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_CHAINING__CHAINING_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_CHAINING__CHAINING_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOwnedFeatureChainingAccess().getChainingFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_CHAINING__CHAINING_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedFeatureTyping returns FeatureTyping
	 *
	 * Constraint:
	 *     (type=[Type|QualifiedName] | ownedRelatedElement+=OwnedFeatureChain)
	 * </pre>
	 */
	protected void sequence_OwnedFeatureTyping(ISerializationContext context, FeatureTyping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterRedefinition returns Redefinition
	 *
	 * Constraint:
	 *     redefinedFeature=[Feature|QualifiedName]
	 * </pre>
	 */
	protected void sequence_ParameterRedefinition(ISerializationContext context, Redefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterRedefinitionAccess().getRedefinedFeatureFeatureQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.REDEFINITION__REDEFINED_FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns CollectExpression
	 *     ConditionalExpression returns CollectExpression
	 *     NullCoalescingExpression returns CollectExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns CollectExpression
	 *     ImpliesExpression returns CollectExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns CollectExpression
	 *     OrExpression returns CollectExpression
	 *     OrExpression.OperatorExpression_1_0 returns CollectExpression
	 *     XorExpression returns CollectExpression
	 *     XorExpression.OperatorExpression_1_0 returns CollectExpression
	 *     AndExpression returns CollectExpression
	 *     AndExpression.OperatorExpression_1_0 returns CollectExpression
	 *     EqualityExpression returns CollectExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns CollectExpression
	 *     ClassificationExpression returns CollectExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns CollectExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns CollectExpression
	 *     RelationalExpression returns CollectExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns CollectExpression
	 *     RangeExpression returns CollectExpression
	 *     RangeExpression.OperatorExpression_1_0 returns CollectExpression
	 *     AdditiveExpression returns CollectExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns CollectExpression
	 *     MultiplicativeExpression returns CollectExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns CollectExpression
	 *     ExponentiationExpression returns CollectExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns CollectExpression
	 *     UnaryExpression returns CollectExpression
	 *     ExtentExpression returns CollectExpression
	 *     PrimaryExpression returns CollectExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns CollectExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns CollectExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns CollectExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns CollectExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns CollectExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns CollectExpression
	 *     PrimaryExpression.FeatureChainExpression_2_1_0 returns CollectExpression
	 *     BaseExpression returns CollectExpression
	 *     SequenceExpression returns CollectExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns CollectExpression
	 *
	 * Constraint:
	 *     (operand+=PrimaryExpression_CollectExpression_2_0_3_0 operand+=BodyExpression)
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, CollectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns FeatureChainExpression
	 *     ConditionalExpression returns FeatureChainExpression
	 *     NullCoalescingExpression returns FeatureChainExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     ImpliesExpression returns FeatureChainExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     OrExpression returns FeatureChainExpression
	 *     OrExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     XorExpression returns FeatureChainExpression
	 *     XorExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     AndExpression returns FeatureChainExpression
	 *     AndExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     EqualityExpression returns FeatureChainExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     ClassificationExpression returns FeatureChainExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns FeatureChainExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns FeatureChainExpression
	 *     RelationalExpression returns FeatureChainExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     RangeExpression returns FeatureChainExpression
	 *     RangeExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     AdditiveExpression returns FeatureChainExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     MultiplicativeExpression returns FeatureChainExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     ExponentiationExpression returns FeatureChainExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns FeatureChainExpression
	 *     UnaryExpression returns FeatureChainExpression
	 *     ExtentExpression returns FeatureChainExpression
	 *     PrimaryExpression returns FeatureChainExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns FeatureChainExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns FeatureChainExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns FeatureChainExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns FeatureChainExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns FeatureChainExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns FeatureChainExpression
	 *     BaseExpression returns FeatureChainExpression
	 *     SequenceExpression returns FeatureChainExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns FeatureChainExpression
	 *
	 * Constraint:
	 *     (
	 *         (operand+=PrimaryExpression_FeatureChainExpression_1_0 ownedRelationship+=FeatureChainMember) | 
	 *         (operand+=PrimaryExpression_FeatureChainExpression_2_1_0 ownedRelationship+=FeatureChainMember)
	 *     )
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, FeatureChainExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OwnedExpression returns SelectExpression
	 *     ConditionalExpression returns SelectExpression
	 *     NullCoalescingExpression returns SelectExpression
	 *     NullCoalescingExpression.OperatorExpression_1_0 returns SelectExpression
	 *     ImpliesExpression returns SelectExpression
	 *     ImpliesExpression.OperatorExpression_1_0 returns SelectExpression
	 *     OrExpression returns SelectExpression
	 *     OrExpression.OperatorExpression_1_0 returns SelectExpression
	 *     XorExpression returns SelectExpression
	 *     XorExpression.OperatorExpression_1_0 returns SelectExpression
	 *     AndExpression returns SelectExpression
	 *     AndExpression.OperatorExpression_1_0 returns SelectExpression
	 *     EqualityExpression returns SelectExpression
	 *     EqualityExpression.OperatorExpression_1_0 returns SelectExpression
	 *     ClassificationExpression returns SelectExpression
	 *     ClassificationExpression.OperatorExpression_0_1_0_0 returns SelectExpression
	 *     ClassificationExpression.OperatorExpression_0_1_1_0 returns SelectExpression
	 *     RelationalExpression returns SelectExpression
	 *     RelationalExpression.OperatorExpression_1_0 returns SelectExpression
	 *     RangeExpression returns SelectExpression
	 *     RangeExpression.OperatorExpression_1_0 returns SelectExpression
	 *     AdditiveExpression returns SelectExpression
	 *     AdditiveExpression.OperatorExpression_1_0 returns SelectExpression
	 *     MultiplicativeExpression returns SelectExpression
	 *     MultiplicativeExpression.OperatorExpression_1_0 returns SelectExpression
	 *     ExponentiationExpression returns SelectExpression
	 *     ExponentiationExpression.OperatorExpression_1_0 returns SelectExpression
	 *     UnaryExpression returns SelectExpression
	 *     ExtentExpression returns SelectExpression
	 *     PrimaryExpression returns SelectExpression
	 *     PrimaryExpression.FeatureChainExpression_1_0 returns SelectExpression
	 *     PrimaryExpression.OperatorExpression_2_0_0_0 returns SelectExpression
	 *     PrimaryExpression.OperatorExpression_2_0_1_0 returns SelectExpression
	 *     PrimaryExpression.OperatorExpression_2_0_2_0 returns SelectExpression
	 *     PrimaryExpression.CollectExpression_2_0_3_0 returns SelectExpression
	 *     PrimaryExpression.SelectExpression_2_0_4_0 returns SelectExpression
	 *     PrimaryExpression.FeatureChainExpression_2_1_0 returns SelectExpression
	 *     BaseExpression returns SelectExpression
	 *     SequenceExpression returns SelectExpression
	 *     SequenceExpression.OperatorExpression_1_1_0 returns SelectExpression
	 *
	 * Constraint:
	 *     (operand+=PrimaryExpression_SelectExpression_2_0_4_0 operand+=BodyExpression)
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, SelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReferenceTyping returns FeatureTyping
	 *
	 * Constraint:
	 *     type=[Type|QualifiedName]
	 * </pre>
	 */
	protected void sequence_ReferenceTyping(ISerializationContext context, FeatureTyping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SysMLPackage.Literals.FEATURE_TYPING__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceTypingAccess().getTypeTypeQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SysMLPackage.Literals.FEATURE_TYPING__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResultExpressionMember returns ResultExpressionMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=OwnedExpression
	 * </pre>
	 */
	protected void sequence_ResultExpressionMember(ISerializationContext context, ResultExpressionMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelfReferenceExpression returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=SelfReferenceMember
	 * </pre>
	 */
	protected void sequence_SelfReferenceExpression(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelfReferenceMember returns ReturnParameterMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=EmptyFeature
	 * </pre>
	 */
	protected void sequence_SelfReferenceMember(ISerializationContext context, ReturnParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeReferenceMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=TypeReference
	 * </pre>
	 */
	protected void sequence_TypeReferenceMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeReference returns Feature
	 *
	 * Constraint:
	 *     ownedRelationship+=ReferenceTyping
	 * </pre>
	 */
	protected void sequence_TypeReference(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeResultMember returns ReturnParameterMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=TypeReference
	 * </pre>
	 */
	protected void sequence_TypeResultMember(ISerializationContext context, ReturnParameterMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     XorExpressionMember returns FeatureMembership
	 *
	 * Constraint:
	 *     ownedRelatedElement+=XorExpression
	 * </pre>
	 */
	protected void sequence_XorExpressionMember(ISerializationContext context, FeatureMembership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     XorExpressionReference returns FeatureReferenceExpression
	 *
	 * Constraint:
	 *     ownedRelationship+=XorExpressionMember
	 * </pre>
	 */
	protected void sequence_XorExpressionReference(ISerializationContext context, FeatureReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
