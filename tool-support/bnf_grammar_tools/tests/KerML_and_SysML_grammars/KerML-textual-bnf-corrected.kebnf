// Source document: tests\KerML_and_SysML_spec_sources\KerML-spec.html

// Generated by bnf_grammar_extractor at: 2025-11-14T23:08:48Z
// Manual corrections by HP de Koning

// Part 1 - Kernel Modeling Language (KerML)

// Clause 8.2 Concrete Syntax

// Clause 8.2.1 Concrete Syntax Overview

// Clause 8.2.2 Lexical Structure

// Clause 8.2.2.1 Line Terminators and White Space

LINE_TERMINATOR =
    '\n' | '\r' | '\r\n'
// implementation defined character sequence

LINE_TEXT =
    '[^\r\n]*'
// character sequence excluding LINE_TERMINATORs

WHITE_SPACE =
    ' ' | '\t' | '\f' | LINE_TERMINATOR
// space | tab | form_feed | LINE_TERMINATOR

// Notes:
//   1. Notation text is divided up into lines separated by line terminators. A line terminator may be a single character (such as a line feed) or a sequence of characters (such as a carriage return/line feed combination). This specification does not require any specific encoding for a line terminator, but any encoding used must be consistent throughout any specific input text.
//   2. Any characters in text line that are not a part of the line terminator are referred to as line text.
//   3. A white space character is a space, tab, form feed or line terminator. Any contiguous sequence of white space characters can be used to separate tokens that would otherwise be considered to be part of a single token. It is otherwise ignored, with the single exception that a line terminator is used to mark the end of a single-line note (see 8.2.2.2 ).

// Clause 8.2.2.2 Notes and Comments

SINGLE_LINE_NOTE =
    '//' LINE_TEXT

MULTILINE_NOTE =
    '//*' COMMENT_TEXT '*/'

REGULAR_COMMENT =
    '/*' COMMENT_TEXT '*/'

COMMENT_TEXT =
    ( COMMENT_LINE_TEXT | LINE_TERMINATOR )*

COMMENT_LINE_TEXT =
    '.*(?=(\r|\n|\*/))'
// LINE_TEXT excluding the sequence '*/'

// Clause 8.2.2.3 Names

NAME =
    BASIC_NAME | UNRESTRICTED_NAME

BASIC_NAME =
    BASIC_INITIAL_CHARACTER BASIC_NAME_CHARACTER*

SINGLE_QUOTE =
    '#x27'

UNRESTRICTED_NAME =
    SINGLE_QUOTE ( NAME_CHARACTER | ESCAPE_SEQUENCE )* SINGLE_QUOTE

// (See Note 1)

BASIC_INITIAL_CHARACTER =
    ALPHABETIC_CHARACTER | '_'

BASIC_NAME_CHARACTER =
    BASIC_INITIAL_CHARACTER | DECIMAL_DIGIT

ALPHABETIC_CHARACTER =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' |
    'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
// any character 'a' through 'z' or 'A' through 'Z'

DECIMAL_DIGIT =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

NAME_CHARACTER =
    'any printable character other than backslash or single_quote'

ESCAPE_SEQUENCE =
    '\f' | '\n' | '\t' | '\r' | '\v'
// (See Note 2)

// Notes:
//   1. The single_quote character is '. The name represented by an UNRESTRICTED_NAME shall consist of the characters within the single quotes, with escape characters resolved as described below. The surrounding single quote characters are not part of the represented name.
//   2. An ESCAPE_SEQUENCE is a sequence of two text characters starting with a backslash that actually denotes only a single character, except for the newline escape sequence, which represents however many characters is necessary to represent an end of line in a specific implementation (see also 8.2.2.1 ). Table 4 shows the meaning of the allowed escape sequences. The ESCAPE_SEQUENCES in an UNRESTRICTED_NAME shall be replaced by the characters specified as their meanings in the actual represented name.

// Clause 8.2.2.4 Numeric Values

DECIMAL_VALUE =
    DECIMAL_DIGIT+

EXPONENTIAL_VALUE =
    DECIMAL_VALUE ('e' | 'E') ('+' | '-')? DECIMAL_VALUE

// Notes:
//   1. A DECIMAL_VALUE may specify a natural literal, or it may be part of the specification of a real literal (see 8.2.5.8.4 ). Note that a DECIMAL_VALUE does not include a sign, because negating a literal is an operator in the KerML Expression syntax.
//   2. An EXPONENTIAL_VALUE may be used in the specification of a real literal (see 8.2.5.8.4 ). Note that a decimal point and fractional part are not included in the lexical structure of an exponential value. They are handled as part of the syntax of real  literals.

// Clause 8.2.2.5 String Value

STRING_VALUE =
    '"' ( STRING_CHARACTER | ESCAPE_SEQUENCE )* '"'

STRING_CHARACTER =
    'any printable character other than backslash or "'

// Notes:
//   1. ESCAPE_SEQUENCE is specified in 8.2.2.3.

// Clause 8.2.2.6 Reserved Words

RESERVED_KEYWORD =
    'about' | 'abstract' | 'alias' | 'all' | 'and' | 'as' | 'assoc' | 'behavior' | 'binding' | 'bool' | 'by' | 'chains'
    | 'class' | 'classifier' | 'comment' | 'composite' | 'conjugate' | 'conjugates' | 'conjugation' | 'connector'
    | 'const' | 'crosses' | 'datatype' | 'default' | 'dependency' | 'derived' | 'differences' | 'disjoining' | 'disjoint'
    | 'doc' | 'else' | 'end' | 'expr' | 'false' | 'feature' | 'featured' | 'featuring' | 'filter' | 'first' | 'flow'
    | 'for' | 'from' | 'function' | 'hastype' | 'if' | 'implies' | 'import' | 'in' | 'inout' | 'interaction'
    | 'intersects' | 'inv' | 'inverse' | 'inverting' | 'istype' | 'language' | 'library' | 'locale' | 'member' | 'meta'
    | 'metaclass' | 'metadata' | 'multiplicity' | 'namespace' | 'nonunique' | 'not' | 'null' | 'of' | 'or' | 'ordered'
    | 'out' | 'package' | 'portion' | 'predicate' | 'private' | 'protected' | 'public' | 'redefines' | 'redefinition'
    | 'references' | 'rep' | 'return' | 'specialization' | 'specializes' | 'standard' | 'step' | 'struct'
    | 'subclassifier' | 'subset' | 'subsets' | 'subtype' | 'succession' | 'then' | 'to' | 'true' | 'type' | 'typed'
    | 'typing' | 'unions' | 'var' | 'xor'

// Clause 8.2.2.7 Symbols

RESERVED_SYMBOL =
    '~' | '}' | '|' | '{' | '^' | ']' | '[' | '@' | '??' | '?' | '>=' | '>' | '=>' | '===' | '==' | '=' | '<=' | '<'
    | ';' | ':>>' | ':>' | ':=' | '::>' | '::' | ':' | '/' | '.?' | '..' | '.' | '->' | '-' | ',' | '+' | '**' | '*' | ')'
    | '(' | '&' | '%' | '$' | '#' | '!==' | '!='

TYPED_BY    = ':'   | 'typed' 'by'

SPECIALIZES = ':>'  | 'specializes'

SUBSETS     = ':>'  | 'subsets'

REFERENCES  = '::>' | 'references'

CROSSES     = '=>'  | 'crosses'

REDEFINES   = ':>>' | 'redefines'

CONJUGATES  = '~'   | 'conjugates'

// Clause 8.2.3 Root Concrete Syntax

// Clause 8.2.3.1 Elements and Relationships Concrete Syntax

Identification : Element =
    ( '<' declaredShortName = NAME '>' )?
    ( declaredName = NAME )?

RelationshipBody : Relationship =
    ';' | '{' RelationshipOwnedElement* '}'

RelationshipOwnedElement : Relationship =
      ownedRelatedElement += OwnedRelatedElement
    | ownedRelationship += OwnedAnnotation

OwnedRelatedElement : Element =
    NonFeatureElement | FeatureElement

// Clause 8.2.3.2 Dependencies Concrete Syntax

Dependency =
    ( ownedRelationship += PrefixMetadataAnnotation )*
    'dependency' ( Identification? 'from' )?
    client += [QualifiedName] ( ',' client += [QualifiedName] )* 'to'
    supplier += [QualifiedName] ( ',' supplier += [QualifiedName] )*
    RelationshipBody

// Notes:
//   1. PrefixMetadataAnnotation is defined in the Kernel layer (see 8.2.5.12 ).

// Clause 8.2.3.3 Annotations Concrete Syntax

// Clause 8.2.3.3.1 Annotations

Annotation =
    annotatedElement = [QualifiedName]

OwnedAnnotation : Annotation =
    ownedRelatedElement += AnnotatingElement

AnnotatingElement =
      Comment
    | Documentation
    | TextualRepresentation
    | MetadataFeature

// Notes:
//   1. MetadataFeature is defined in the Kernel layer (see 8.2.5.12 ).

// Clause 8.2.3.3.2 Comments and Documentation

Comment =
    ( 'comment' Identification
      ( 'about' ownedRelationship += Annotation
        ( ',' ownedRelationship += Annotation )*
      )?
    )?
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT

Documentation =
    'doc' Identification
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT

// Notes:
//   1. The text of a lexical REGULAR_COMMENT or PREFIX_COMMENT shall be processed as follows before it is included as the body of a Comment or Documentation : Remove the initial /* and final */ characters. Remove any white space immediately after the initial /*, up to and including the first line terminator (if any). On each subsequent line of the text: Strip initial white space other than line terminators. Then, if the first remaining character is " * ", remove it. Then, if the first remaining character is now a space, remove it.
//   2. The body text of a Comment can include markup information (such as HTML), and a conforming tool may display such text as rendered according to the markup. However, marked up "rich text" for a Comment written using the KerML textual concrete syntax shall be stored in the Comment body in plain text including all mark up text, with all line terminators and white space included as entered, other than what is removed according to the rules above.

// Clause 8.2.3.3.3 Textual Representation

TextualRepresentation =
    ( 'rep' Identification )?
    'language' language = STRING_VALUE
    body = REGULAR_COMMENT

// Notes:
//   1. The lexical text of a REGULAR_COMMENT shall be processed as specified in 8.2.3.3.2 for Comments before being included as the body of a TextualRepresentation.
//   2. See also 8.3.2.3.6 on the standard language names recognized for a TextualRepresentation.

// Clause 8.2.3.4 Namespaces Concrete Syntax

// Clause 8.2.3.4.1 Namespaces

RootNamespace : Namespace =
    NamespaceBodyElement*

// (See Note 1)

Namespace =
    ( ownedRelationship += PrefixMetadataMember )*
    NamespaceDeclaration NamespaceBody

// (See Note 2)

NamespaceDeclaration : Namespace =
    'namespace' Identification

NamespaceBody : Namespace =
    ';' | '{' NamespaceBodyElement* '}'

NamespaceBodyElement : Namespace =
      ownedRelationship += NamespaceMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

MemberPrefix : Membership =
    ( visibility = VisibilityIndicator )?

VisibilityIndicator : VisibilityKind =
    'public' | 'private' | 'protected'

NamespaceMember : OwningMembership =
      NonFeatureMember
    | NamespaceFeatureMember

NonFeatureMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += MemberElement

NamespaceFeatureMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += FeatureElement

AliasMember : Membership =
    MemberPrefix
    'alias' ( '<' memberShortName = NAME '>' )?
    ( memberName = NAME )?
    'for' memberElement = [QualifiedName]
    RelationshipBody

QualifiedName =
   ( '$' '::' )? ( NAME '::' )* NAME

// (See Note 3)

// Notes:
//   1. A root Namespace is a Namespace that has no owningNamespace (see 8.3.2.4 ). Every Element other than a root Namespace must be contained, directly or indirectly, within some root Namespace. Therefore, every valid KerML concrete syntax text can be parsed starting from the RootNamespace production.
//   2. PrefixMetadataMember is defined in the Kernel layer (see 8.2.5.12 ).
//   3. A qualified name is notated as a sequence of segment names separated by " :: " punctuation, optionally with the global scope qualifier " $ " as an initial segment. An unqualified name can be considered the degenerate case of a qualified name with a single segment name. A qualified name is used in the KerML textual concrete syntax to identify an Element that is being referred to in the representation of another Element. A qualified name used in this way does not appear in the corresponding abstract syntaxâ€”instead, the abstract syntax representation contains an actual reference to the identified Element. Name resolution is the process of determining the Element that is identified by a qualified name. The segment names of the qualified name other than the last identify a sequence of nested Namespaces that provide the context for resolving the final segment name (see 8.2.3.5 ). The notation [QualifiedName] is used in concrete syntax grammar productions to indicate the result of resolving text parsed as a QualifiedName (see also 8.2.1 ).

// Clause 8.2.3.4.2 Imports

Import =
    visibility = VisibilityIndicator
    'import' ( isImportAll ?= 'all' )?
    ImportDeclaration RelationshipBody

ImportDeclaration : Import =
    MembershipImport | NamespaceImport

MembershipImport =
    importedMembership = [QualifiedName]
    ( '::' isRecursive ?= '**' )?

// (See Note 1)

NamespaceImport =
      importedNamespace = [QualifiedName] '::' '*'
      ( '::' isRecursive ?= '**' )?
    | importedNamespace = FilterPackage
      { ownedRelatedElement += importedNamespace }

FilterPackage : Package =
    ownedRelationship += ImportDeclaration
    ( ownedRelationship += FilterPackageMember )+

FilterPackageMember : ElementFilterMembership =
    '[' ownedRelatedElement += OwnedExpression ']'

// Notes:
//   1. The importedMembership of a MembershipImport is the single case in which the Element required from the resolution [QualifiedName] is the actual Membership identified by the QualifiedName, not the memberElement of that Membership (see 8.2.3.5 ).

// Clause 8.2.3.4.3 Namespace Elements

MemberElement : Element =
    AnnotatingElement | NonFeatureElement

NonFeatureElement : Element =
      Dependency
    | Namespace
    | Type
    | Classifier
    | DataType
    | Class
    | Structure
    | Metaclass
    | Association
    | AssociationStructure
    | Interaction
    | Behavior
    | Function
    | Predicate
    | Multiplicity
    | Package
    | LibraryPackage
    | Specialization
    | Conjugation
    | Subclassification
    | Disjoining
    | FeatureInverting
    | FeatureTyping
    | Subsetting
    | Redefinition
    | TypeFeaturing

FeatureElement : Feature =
      Feature
    | Step
    | Expression
    | BooleanExpression
    | Invariant
    | Connector
    | BindingConnector
    | Succession
    | Flow
    | SuccessionFlow

// Clause 8.2.3.5 Name Resolution

// Clause 8.2.3.5.1 Name Resolution Overview

// Clause 8.2.3.5.2 Local and Global Namespaces

// Clause 8.2.3.5.3 Local and Visible Resolution

// Clause 8.2.3.5.4 Full Resolution

// Clause 8.2.4 Core Concrete Syntax

// Clause 8.2.4.1 Types Concrete Syntax

// Clause 8.2.4.1.1 Types

Type =
    TypePrefix 'type'
    TypeDeclaration TypeBody

TypePrefix : Type =
    ( isAbstract ?= 'abstract' )?
    ( ownedRelationship += PrefixMetadataMember )*

TypeDeclaration : Type =
    ( isSufficient ?= 'all' )? Identification
    ( ownedRelationship += OwnedMultiplicity )?
    ( SpecializationPart | ConjugationPart )+
    TypeRelationshipPart*

SpecializationPart : Type =
    SPECIALIZES ownedRelationship += OwnedSpecialization
    ( ',' ownedRelationship += OwnedSpecialization )*

ConjugationPart : Type =
    CONJUGATES ownedRelationship += OwnedConjugation

TypeRelationshipPart : Type =
      DisjoiningPart
    | UnioningPart
    | IntersectingPart
    | DifferencingPart

DisjoiningPart : Type =
    'disjoint' 'from' ownedRelationship += OwnedDisjoining
    ( ',' ownedRelationship += OwnedDisjoining )*

UnioningPart : Type =
    'unions' ownedRelationship += Unioning
    ( ',' ownedRelationship += Unioning )*

IntersectingPart : Type =
    'intersects' ownedRelationship += Intersecting
    ( ',' ownedRelationship += Intersecting )*

DifferencingPart : Type =
    'differences' ownedRelationship += Differencing
    ( ',' ownedRelationship += Differencing )*

TypeBody : Type =
    ';' | '{' TypeBodyElement* '}'

TypeBodyElement : Type =
      ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import

// Clause 8.2.4.1.2 Specialization

Specialization =
    ( 'specialization' Identification )?
    'subtype' SpecificType
    SPECIALIZES GeneralType
    RelationshipBody

OwnedSpecialization : Specialization =
    GeneralType

SpecificType : Specialization =
      specific = [QualifiedName]
    | specific += OwnedFeatureChain
      { ownedRelatedElement += specific }

GeneralType : Specialization =
      general = [QualifiedName]
    | general += OwnedFeatureChain
      { ownedRelatedElement += general }

// Clause 8.2.4.1.3 Conjugation

Conjugation =
    ( 'conjugation' Identification )?
    'conjugate'
    ( conjugatedType = [QualifiedName]
    | conjugatedType = FeatureChain
      { ownedRelatedElement += conjugatedType }
    )
    CONJUGATES
    ( originalType = [QualifiedName]
    | originalType = FeatureChain
      { ownedRelatedElement += originalType }
    )
    RelationshipBody

OwnedConjugation : Conjugation =
      originalType = [QualifiedName]
    | originalType = FeatureChain
      { ownedRelatedElement += originalType }

// Clause 8.2.4.1.4 Disjoining

Disjoining =
    ( 'disjoining' Identification )?
    'disjoint'
    ( typeDisjoined = [QualifiedName]
    | typeDisjoined = FeatureChain
      { ownedRelatedElement += typeDisjoined }
    )
    'from'
    ( disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
      { ownedRelatedElement += disjoiningType }
    )
    RelationshipBody

OwnedDisjoining : Disjoining =
      disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
      { ownedRelatedElement += disjoiningType }

// Clause 8.2.4.1.5 Unioning, Intersecting and Differencing

Unioning =
      unioningType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain

Intersecting =
      intersectingType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain

Differencing =
      differencingType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain

// Clause 8.2.4.1.6 Feature Membership

FeatureMember : OwningMembership =
      TypeFeatureMember
    | OwnedFeatureMember

TypeFeatureMember : OwningMembership =
    MemberPrefix 'member' ownedRelatedElement += FeatureElement

OwnedFeatureMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += FeatureElement

// Clause 8.2.4.2 Classifiers Concrete Syntax

// Clause 8.2.4.2.1 Classifiers

Classifier =
    TypePrefix 'classifier'
    ClassifierDeclaration TypeBody

ClassifierDeclaration : Classifier =
    ( isSufficient ?= 'all' )? Identification
    ( ownedRelationship += OwnedMultiplicity )?
    ( SuperclassingPart | ConjugationPart )?
    TypeRelationshipPart*

SuperclassingPart : Classifier =
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )*

// Clause 8.2.4.2.2 Subclassification

Subclassification =
    ( 'specialization' Identification )?
    'subclassifier' subclassifier = [QualifiedName]
    SPECIALIZES superclassifier = [QualifiedName]
    RelationshipBody

OwnedSubclassification : Subclassification =
    superclassifier = [QualifiedName]

// Clause 8.2.4.3 Features Concrete Syntax

// Clause 8.2.4.3.1 Features

Feature =
    ( FeaturePrefix
      ( 'feature' | ownedRelationship += PrefixMetadataMember )
      FeatureDeclaration?
    | ( EndFeaturePrefix | BasicFeaturePrefix )
      FeatureDeclaration
    )
    ValuePart? TypeBody

// (See Note 1)

EndFeaturePrefix : Feature =
    ( isConstant ?= 'const' { isVariable = true } )?
    isEnd ?= 'end'

BasicFeaturePrefix : Feature =
    ( direction = FeatureDirection )?
    ( isDerived ?= 'derived' )?
    ( isAbstract ?= 'abstract' )?
    ( isComposite ?= 'composite' | isPortion ?= 'portion' )?
    ( isVariable ?= 'var' | isConstant ?= 'const' { isVariable = true } )?

FeaturePrefix =
    ( EndFeaturePrefix ( ownedRelationship += OwnedCrossFeatureMember )?
    | BasicFeaturePrefix
    )
    ( ownedRelationship += PrefixMetadataMember )*

// (See Note 1)

OwnedCrossFeatureMember : OwningMembership =
    ownedRelatedElement += OwnedCrossFeature

OwnedCrossFeature : Feature =
    BasicFeaturePrefix FeatureDeclaration

FeatureDirection : FeatureDirectionKind =
    'in' | 'out' | 'inout'

FeatureDeclaration : Feature =
    ( isSufficient ?= 'all' )?
    ( FeatureIdentification
      ( FeatureSpecializationPart | ConjugationPart )?
    | FeatureSpecializationPart
    | ConjugationPart
    )
    FeatureRelationshipPart*

FeatureIdentification : Feature =
      '<' declaredShortName = NAME '>' ( declaredName = NAME )?
    | declaredName = NAME

FeatureRelationshipPart : Feature =
      TypeRelationshipPart
    | ChainingPart
    | InvertingPart
    | TypeFeaturingPart

ChainingPart : Feature =
    'chains'
    ( ownedRelationship += OwnedFeatureChaining
    | FeatureChain )

InvertingPart : Feature =
    'inverse' 'of' ownedRelationship += OwnedFeatureInverting

TypeFeaturingPart : Feature =
    'featured' 'by' ownedRelationship += OwnedTypeFeaturing
    ( ',' ownedTypeFeaturing += OwnedTypeFeaturing )*

FeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization*

MultiplicityPart : Feature =
      ownedRelationship += OwnedMultiplicity
    | ( ownedRelationship += OwnedMultiplicity )?
      ( isOrdered ?= 'ordered' ( {isUnique = false} 'nonunique' )?
      | {isUnique = false} 'nonunique' ( isOrdered ?= 'ordered' )? )

FeatureSpecialization : Feature =
    Typings | Subsettings | References | Crosses | Redefinitions

Typings : Feature =
      TypedBy ( ',' ownedRelationship += OwnedFeatureTyping )*

TypedBy : Feature =
    TYPED_BY ownedRelationship += OwnedFeatureTyping

Subsettings : Feature =
    Subsets ( ',' ownedRelationship += OwnedSubsetting )*

Subsets : Feature =
    SUBSETS ownedRelationship += OwnedSubsetting

References : Feature =
    REFERENCES ownedRelationship += OwnedReferenceSubsetting

Crosses : Feature =
    CROSSES ownedRelationship += OwnedCrossSubsetting

Redefinitions : Feature =
    Redefines ( ',' ownedRelationship += OwnedRedefinition )*

Redefines : Feature =
    REDEFINES ownedRelationship += OwnedRedefinition

// Notes:
//   1. PrefixMetadataMember is defined in the Kernel layer (see 8.3.4.12 ).

// Clause 8.2.4.3.2 Feature Typing

FeatureTyping =
    ( 'specialization' Identification )?
    'typing' typedFeature = [QualifiedName]
    TYPED_BY GeneralType
    RelationshipBody

OwnedFeatureTyping : FeatureTyping =
    GeneralType

// Clause 8.2.4.3.3 Subsetting

Subsetting =
    ( 'specialization' Identification )?
    'subset' SpecificType
    SUBSETS GeneralType
    RelationshipBody

OwnedSubsetting : Subsetting =
    GeneralType

OwnedReferenceSubsetting : ReferenceSubsetting =
    GeneralType

OwnedCrossSubsetting : CrossSubsetting =
    GeneralType

// Clause 8.2.4.3.4 Redefinition

Redefinition =
    ( 'specialization' Identification )?
    'redefinition' SpecificType
    REDEFINES GeneralType
    RelationshipBody

OwnedRedefinition : Redefinition =
    GeneralType

// Clause 8.2.4.3.5 Feature Chaining

OwnedFeatureChain : Feature =
    FeatureChain

FeatureChain : Feature =
    ownedRelationship += OwnedFeatureChaining
    ( '.' ownedRelationship += OwnedFeatureChaining )+

OwnedFeatureChaining : FeatureChaining =
    chainingFeature = [QualifiedName]

// Clause 8.2.4.3.6 Feature Inverting

FeatureInverting =
    ( 'inverting' Identification? )?
    'inverse'
    ( featureInverted = [QualifiedName]
    | featureInverted = OwnedFeatureChain
      { ownedRelatedElement += featureInverted }
    )
    'of'
    ( invertingFeature = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain
      { ownedRelatedElement += invertingFeature }
    )
    RelationshipBody

OwnedFeatureInverting : FeatureInverting =
      invertingFeature = [QualifiedName]
    | invertingFeature = OwnedFeatureChain
      { ownedRelatedElement += invertingFeature }

// Clause 8.2.4.3.7 Type Featuring

TypeFeaturing =
    'featuring' ( Identification 'of' )?
    featureOfType = [QualifiedName]
    'by' featuringType = [QualifiedName]
    RelationshipBody

OwnedTypeFeaturing : TypeFeaturing =
    featuringType = [QualifiedName]

// Clause 8.2.5 Kernel Concrete Syntax

// Clause 8.2.5.1 Data Types Concrete Syntax

DataType =
    TypePrefix 'datatype'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.2 Classes Concrete Syntax

Class =
    TypePrefix 'class'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.3 Structures Concrete Syntax

Structure =
    TypePrefix 'struct'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.4 Associations Concrete Syntax

Association =
    TypePrefix 'assoc'
    ClassifierDeclaration TypeBody

AssociationStructure =
    TypePrefix 'assoc' 'struct'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.5 Connectors Concrete Syntax

// Clause 8.2.5.5.1 Connectors

Connector =
    FeaturePrefix 'connector'
    ( FeatureDeclaration? ValuePart?
    | ConnectorDeclaration
    )
    TypeBody

ConnectorDeclaration : Connector =
    BinaryConnectorDeclaration | NaryConnectorDeclaration

BinaryConnectorDeclaration : Connector =
    ( FeatureDeclaration? 'from' | isSufficient ?= 'all' 'from'? )?
    ownedRelationship += ConnectorEndMember 'to'
    ownedRelationship += ConnectorEndMember

NaryConnectorDeclaration : Connector =
    FeatureDeclaration?
    '(' ownedRelationship += ConnectorEndMember ','
        ownedRelationship += ConnectorEndMember
        ( ',' ownedRelationship += ConnectorEndMember )*
    ')'

ConnectorEndMember : EndFeatureMembership =
    ownedRelatedElement += ConnectorEnd

ConnectorEnd : Feature =
	( ownedRelationship += OwnedCrossMultiplicityMember )?
	( declaredName = NAME REFERENCES )?
	ownedRelationship += OwnedReferenceSubsetting

OwnedCrossMultiplicityMember : OwningMembership =
	ownedRelatedElement += OwnedCrossMultiplicity

OwnedCrossMultiplicity : Feature =
	ownedRelationship += OwnedMultiplicity

// Clause 8.2.5.5.2 Binding Connectors

BindingConnector =
    FeaturePrefix 'binding'
    BindingConnectorDeclaration TypeBody

BindingConnectorDeclaration : BindingConnector =
      FeatureDeclaration
      ( 'of' ownedRelationship += ConnectorEndMember
        '='  ownedRelationship += ConnectorEndMember )?
    | ( isSufficient ?= 'all' )?
      ( 'of'? ownedRelationship += ConnectorEndMember
        '='   ownedRelationship += ConnectorEndMember )?

// Clause 8.2.5.5.3 Successions

Succession =
    FeaturePrefix 'succession'
    SuccessionDeclaration TypeBody

SuccessionDeclaration : Succession =
      FeatureDeclaration
      ( 'first' ownedRelationship += ConnectorEndMember
        'then'  ownedRelationship += ConnectorEndMember )?
    | ( s.isSufficient ?= 'all' )?
      ( 'first'? ownedRelationship += ConnectorEndMember
        'then'   ownedRelationship += ConnectorEndMember )?

// Clause 8.2.5.6 Behaviors Concrete Syntax

// Clause 8.2.5.6.1 Behaviors

Behavior =
    TypePrefix 'behavior'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.6.2 Steps

Step =
    FeaturePrefix
    'step' FeatureDeclaration ValuePart?
    TypeBody

// Clause 8.2.5.7 Functions Concrete Syntax

// Clause 8.2.5.7.1 Functions

Function =
    TypePrefix 'function'
    ClassifierDeclaration FunctionBody

FunctionBody : Type =
    ';' | '{' FunctionBodyPart '}'

FunctionBodyPart : Type =
    ( TypeBodyElement
    | ownedRelationship += ReturnFeatureMember
    )*
   ( ownedRelationship += ResultExpressionMember )?

ReturnFeatureMember : ReturnParameterMembership =
    MemberPrefix 'return'
    ownedRelatedElement += FeatureElement

ResultExpressionMember : ResultExpressionMembership =
    MemberPrefix
    ownedRelatedElement += OwnedExpression

// Clause 8.2.5.7.2 Expressions

Expression =
    FeaturePrefix
    'expr' FeatureDeclaration ValuePart?
    FunctionBody

// Clause 8.2.5.7.3 Predicates

Predicate =
    TypePrefix 'predicate'
    ClassifierDeclaration FunctionBody

// Clause 8.2.5.7.4 Boolean Expressions and Invariants

BooleanExpression =
    FeaturePrefix
    'bool' FeatureDeclaration ValuePart?
    FunctionBody

Invariant =
    FeaturePrefix
    'inv' ( 'true' | isNegated ?= 'false' )?
    FeatureDeclaration ValuePart?
    FunctionBody

// Clause 8.2.5.8 Expressions Concrete Syntax

// Clause 8.2.5.8.1 Operator Expressions

OwnedExpressionReferenceMember : FeatureMembership =
    ownedRelationship += OwnedExpressionReference

OwnedExpressionReference : FeatureReferenceExpression =
    ownedRelationship += OwnedExpressionMember

OwnedExpressionMember : FeatureMembership =
    ownedFeatureMember = OwnedExpression

OwnedExpression : Expression =
      ConditionalExpression
    | ConditionalBinaryOperatorExpression
    | BinaryOperatorExpression
    | UnaryOperatorExpression
    | ClassificationExpression
    | MetaclassificationExpression
    | ExtentExpression
    | PrimaryExpression

ConditionalExpression : OperatorExpression =
    operator = 'if'
    ownedRelationship += ArgumentMember '?'
    ownedRelationship += ArgumentExpressionMember 'else'
    ownedRelationship += ArgumentExpressionMember
    ownedRelationship += EmptyResultMember

ConditionalBinaryOperatorExpression : OperatorExpression =
    ownedRelationship += ArgumentMember
    operator = ConditionalBinaryOperator
    ownedRelationship += ArgumentExpressionMember
    ownedRelationship += EmptyResultMember

ConditionalBinaryOperator =
    '??' | 'or' | 'and' | 'implies'

BinaryOperatorExpression : OperatorExpression =
    ownedRelationship += ArgumentMember
    operator = BinaryOperator
    ownedRelationship += ArgumentMember
    ownedRelationship += EmptyResultMember

BinaryOperator =
      '|'  | '&'  | 'xor' | '..'
    | '==' | '!=' | '===' | '!=='
    | '<'  | '>'  | '<='  | '>='
    | '+'  | '-'  | '*'   | '/'
    | '%'  | '^'  | '**'

UnaryOperatorExpression : OperatorExpression =
    operator = UnaryOperator
    ownedRelationship += ArgumentMember
    ownedRelationship += EmptyResultMember

UnaryOperator =
    '+' | '-' | '~' | 'not'

ClassificationExpression : OperatorExpression =
    ( ownedRelationship += ArgumentMember )?
    ( operator = ClassificationTestOperator
      ownedRelationship += TypeReferenceMember
    | operator = CastOperator
      ownedRelationship += TypeResultMember
    )
    ownedRelationship += EmptyResultMember

ClassificationTestOperator =
    'istype' | 'hastype' | '@'

CastOperator =
    'as'

MetaclassificationExpression : OperatorExpression =
    ownedRelationship += MetadataArgumentMember
    ( operator = MetaClassificationTestOperator
      ownedRelationship += TypeReferenceMember
    | operator = MetaCastOperator
      ownedRelationship += TypeResultMember
    )
    ownedRelationship += EmptyResultMember

ArgumentMember : ParameterMembership =
    ownedMemberParameter = Argument

Argument : Feature =
    ownedRelationship += ArgumentValue

ArgumentValue : FeatureValue =
    value = OwnedExpression

ArgumentExpressionMember : FeatureMembership =
    ownedRelatedElement += ArgumentExpression

ArgumentExpression : Feature =
    ownedRelationship += ArgumentExpressionValue

ArgumentExpressionValue : FeatureValue =
    value = OwnedExpressionReference

MetadataArgumentMember : ParameterMembership =
    ownedRelatedElement += MetadataArgument

MetadataArgument : Feature =
    ownedRelationship += MetadataValue

MetadataValue : FeatureValue =
    value = MetadataReference

MetadataReference : MetadataAccessExpression =
    ownedRelationship += ElementReferenceMember

MetaclassificationTestOperator =
    '@@'

MetaCastOperator =
    'meta'

ExtentExpression : OperatorExpression =
    operator = 'all'
    ownedRelationship += TypeReferenceMember

TypeReferenceMember : ParameterMembership =
    ownedMemberFeature = TypeReference

TypeResultMember : ResultParameterMembership =
    ownedMemberFeature = TypeReference

TypeReference : Feature =
    ownedRelationship += ReferenceTyping

ReferenceTyping : FeatureTyping =
    type = [QualifiedName]

EmptyResultMember : ReturnParameterMembership =
    ownedRelatedElement += EmptyFeature

EmptyFeature : Feature =
    { }

// Notes:
//   1. OperatorExpressions provide a shorthand notation for InvocationExpressions that invoke a library Function represented as an operator symbol. Table 5 shows the mapping from operator symbols to the Functions they represent from the Kernel Model Library (see Clause 9 ). An OperatorExpression contains subexpressions called its operands that generally correspond to the argument Expressions of the OperatorExpression, except in the case of operators representing control Functions, in which case the evaluation of certain operands is as determined by the Function (see 8.4.4.9 for details).
//   2. Though not directly expressed in the syntactic productions given above, in any OperatorExpression containing nested OperatorExpressions, the nested OperatorExpressions shall be implicitly grouped according to the precedence of the operators involved, as given in Table 6. OperatorExpressions with higher precedence operators shall be grouped more tightly than those with lower precedence operators. Further, all BinaryOperators other than exponentiation are left-associative (i.e., they group to the left), while the exponentiation operators ( ^ and ** ) are right-associative (i.e., they group to the right).
//   3. The unary operator symbol ~ maps to the library Function DataFunctions::'~', as shown in Table 5. This abstract Function may be given a concrete definition in a domain-specific Function library, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this operator is used.

// Clause 8.2.5.8.2 Primary Expressions

PrimaryExpression : Expression =
      FeatureChainExpression
    | NonFeatureChainPrimaryExpression

PrimaryArgumentValue : FeatureValue =
    value = PrimaryExpression

PrimaryArgument : Feature =
    ownedRelationship += PrimaryArgumentValue

PrimaryArgumentMember : ParameterMembership =
    ownedMemberParameter = PrimaryArgument

NonFeatureChainPrimaryExpression : Expression =
      BracketExpression
    | IndexExpression
    | SequenceExpression
    | SelectExpression
    | CollectExpression
    | FunctionOperationExpression
    | BaseExpression

NonFeatureChainPrimaryArgumentValue : FeatureValue =
    value = NonFeatureChainPrimaryExpression

NonFeatureChainPrimaryArgument : Feature =
    ownedRelationship += NonFeatureChainPrimaryArgumentValue

NonFeatureChainPrimaryArgumentMember : ParameterMembership =
    ownedMemberParameter = PrimaryArgument

BracketExpression : OperatorExpression =
    ownedRelationship += PrimaryArgumentMember
    operator = '['
    ownedRelationship += SequenceExpressionListMember ']'

IndexExpression =
    ownedRelationship += PrimaryArgumentMember '#'
    '(' ownedRelationship += SequenceExpressionListMember ')'

SequenceExpression : Expression =
    '(' SequenceExpressionList ')'

SequenceExpressionList : Expression =
    OwnedExpression ','? | SequenceOperatorExpression

SequenceOperatorExpression : OperatorExpression =
    ownedRelationship += OwnedExpressionMember
    operator = ','
    ownedRelationship += SequenceExpressionListMember

SequenceExpressionListMember : FeatureMembership =
    ownedMemberFeature = SequenceExpressionList

FeatureChainExpression =
    ownedRelationship += NonFeatureChainPrimaryArgumentMember '.'
    ownedRelationship += FeatureChainMember

CollectExpression =
    ownedRelationship += PrimaryArgumentMember '.'
    ownedRelationship += BodyArgumentMember

SelectExpression =
    ownedRelationship += PrimaryArgumentMember '.?'
    ownedRelationship += BodyArgumentMember

FunctionOperationExpression : InvocationExpression =
    ownedRelationship += PrimaryArgumentMember '->'
    ownedRelationship += InvocationTypeMember
    ( ownedRelationship += BodyArgumentMember
    | ownedRelationship += FunctionReferenceArgumentMember
    | ArgumentList )
    ownedRelationship += EmptyResultMember

BodyArgumentMember : ParameterMembership =
    ownedMemberParameter = BodyArgument

BodyArgument : Feature =
    ownedRelationship += BodyArgumentValue

BodyArgumentValue : FeatureValue =
    value = BodyExpression

FunctionReferenceArgumentMember : ParameterMembership =
    ownedMemberParameter = FunctionReferenceArgument

FunctionReferenceArgument : Feature =
    ownedRelationship += FunctionReferenceArgumentValue

FunctionReferenceArgumentValue : FeatureValue =
    value = FunctionReferenceExpression

FunctionReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FunctionReferenceMember

FunctionReferenceMember : FeatureMembership =
    ownedMemberFeature = FunctionReference

FunctionReference : Expression =
    ownedRelationship += ReferenceTyping

FeatureChainMember : Membership =
      FeatureReferenceMember
    | OwnedFeatureChainMember

OwnedFeatureChainMember : OwningMembership =
    ownedMemberElement = FeatureChain

// Notes:
//   1. Primary expressions provide additional shorthand notations for certain kinds of InvocationExpressions. For those cases in which the InvocationExpression is an OperatorExpression, its operator shall be resolved to the appropriate library function as given in Table 7. Note also that, for a CollectionExpression or SelectExpression, the abstract syntax constrains the operator to be collect and select, respectively, separately from the. and.? symbols used in their concrete syntax notation (see 8.3.4.8.2 and 8.3.4.8.18 ).
//   2. The grammar allows a bracket syntax [... ] that parses to an invocation of the library Function Base Functions::'[', as shown in Table 7. This notation is available for use with domain-specific library models that given a concrete definition to the abstract base '[' Function, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this operator is used.

// Clause 8.2.5.8.3 Base Expressions

BaseExpression : Expression =
      NullExpression
    | LiteralExpression
    | FeatureReferenceExpression
    | MetadataAccessExpression
    | InvocationExpression
    | ConstructorExpression
    | BodyExpression

NullExpression : NullExpression =
    'null' | '(' ')'

FeatureReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FeatureReferenceMember
    ownedRelationship += EmptyResultMember

FeatureReferenceMember : Membership =
    memberElement = FeatureReference

FeatureReference : Feature =
    [QualifiedName]

MetadataAccessExpression =
    ownedRelationship += ElementReferenceMember '.' 'metadata'

ElementReferenceMember : Membership =
    memberElement = [QualifiedName]

InvocationExpression : InvocationExpression =
    ownedRelationship += InstantiatedTypeMember
    ArgumentList
    ownedRelationship += EmptyResultMember

ConstructorExpression =
    'new' ownedRelationship += InstantiatedTypeMember
    ownedRelationship += ConstructorResultMember

ConstructorResultMember : ReturnParameterMembership =
    ownedRelatedElement += ConstructorResult

ConstructorResult : Feature =
    ArgumentList

InstantiatedTypeMember : Membership =
      memberElement = InstantiatedTypeReference
    | OwnedFeatureChainMember

InstantiatedTypeReference : Type =
    [QualifiedName]

ArgumentList : Feature =
    '(' ( PositionalArgumentList | NamedArgumentList )? ')'

PositionalArgumentList : Feature =
    e.ownedRelationship += ArgumentMember
    ( ',' e.ownedRelationship += ArgumentMember )*

NamedArgumentList : Feature =
    ownedRelationship += NamedArgumentMember
    ( ',' ownedRelationship += NamedArgumentMember )*

NamedArgumentMember : FeatureMembership =
    ownedMemberFeature = NamedArgument

NamedArgument : Feature =
    ownedRelationship += ParameterRedefinition '='
    ownedRelationship += ArgumentValue

ParameterRedefinition : Redefinition =
    redefinedFeature = [QualifiedName]

BodyExpression : FeatureReferenceExpression =
    ownedRelationship += ExpressionBodyMember

ExpressionBodyMember : FeatureMembership =
    ownedMemberFeature = ExpressionBody

ExpressionBody : Expression =
    '{' FunctionBodyPart '}'

// Clause 8.2.5.8.4 Literal Expressions

LiteralExpression =
      LiteralBoolean
    | LiteralString
    | LiteralInteger
    | LiteralReal
    | LiteralInfinity

LiteralBoolean =
    value = BooleanValue

BooleanValue : Boolean =
    'true' | 'false'

LiteralString =
    value = STRING_VALUE

LiteralInteger =
    value = DECIMAL_VALUE

LiteralReal =
    value = RealValue

RealValue : Real =
      DECIMAL_VALUE? '.' ( DECIMAL_VALUE | EXPONENTIAL_VALUE )
    | EXPONENTIAL_VALUE

LiteralInfinity =
    '*'

// Clause 8.2.5.9 Interactions Concrete Syntax

// Clause 8.2.5.9.1 Interactions

Interaction =
    TypePrefix 'interaction'
    ClassifierDeclaration TypeBody

// Clause 8.2.5.9.2 Flows

Flow =
    FeaturePrefix 'flow'
    ItemFlowDeclaration TypeBody

SuccessionFlow =
    FeaturePrefix 'succession' 'flow'
    ItemFlowDeclaration TypeBody

FlowDeclaration : Flow =
      FeatureDeclaration ValuePart?
      ( 'of' ownedRelationship += PayloadFeatureMember )?
      ( 'from' ownedRelationship += FlowEndMember
        'to' ownedRelationship += FlowEndMember )?
    | ( isSufficient ?= 'all' )?
      ownedRelationship += FlowEndMember 'to'
      ownedRelationship += FlowEndMember

PayloadFeatureMember : FeatureMembership =
    ownedRelatedElement = PayloadFeature

PayloadFeature =
      Identification PayloadFeatureSpecializationPart ValuePart?
    | Identification ValuePart
    | ownedRelationship += OwnedFeatureTyping
      ( ownedRelationship += OwnedMultiplicity )?
    | ownedRelationship += OwnedMultiplicity
      ( ownedRelationship += OwnedFeatureTyping )?

PayloadFeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart?
      FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization+

FlowEndMember : EndFeatureMembership =
    ownedRelatedElement += FlowEnd

FlowEnd =
    ( ownedRelationship += OwnedReferenceSubsetting '.' )?
    ownedRelationship += FlowFeatureMember

FlowFeatureMember : FeatureMembership =
    ownedRelatedElement += FlowFeature

FlowFeature : Feature =
    ownedRelationship += FlowFeatureRedefinition

// (See Note 1)

FlowFeatureRedefinition : Redefinition =
    redefinedFeature = [QualifiedName]

// Notes:
//   1. To ensure that an FlowFeature passes the validateRedefinitionDirectionConformance constraint (see 8.3.3.3.8 ), its direction must be set to the direction of its redefinedFeature, relative to its owning FlowEnd, that is, the result of the following OCL expression: owningType.directionOf(ownedRedefinition->at(1).redefinedFeature)

// Clause 8.2.5.10 Feature Values Concrete Syntax

ValuePart : Feature =
    ownedRelationship += FeatureValue

FeatureValue =
    ( '='
    | isInitial ?= ':='
    | isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?
    )
    ownedRelatedElement += OwnedExpression

// Clause 8.2.5.11 Multiplicities Concrete Syntax

Multiplicity =
    MultiplicitySubset | MultiplicityRange

MultiplicitySubset : Multiplicity =
    'multiplicity' Identification Subsets
    TypeBody

MultiplicityRange =
    'multiplicity' Identification MultiplicityBounds
    TypeBody

OwnedMultiplicity : OwningMembership =
    ownedRelatedElement += OwnedMultiplicityRange

OwnedMultiplicityRange : MultiplicityRange =
    MultiplicityBounds

MultiplicityBounds : MultiplicityRange =
    '[' ( ownedRelationship += MultiplicityExpressionMember '..' )?
          ownedRelationship += MultiplicityExpressionMember ']'

MultiplicityExpressionMember : OwningMembership =
    ownedRelatedElement += ( LiteralExpression | FeatureReferenceExpression )

// Clause 8.2.5.12 Metadata Concrete Syntax

Metaclass =
    TypePrefix 'metaclass'
    ClassifierDeclaration TypeBody

PrefixMetadataAnnotation : Annotation =
    '#' ownedRelatedElement += PrefixMetadataFeature

PrefixMetadataMember : OwningMembership =
    '#' ownedRelatedElement += PrefixMetadataFeature

PrefixMetadataFeature : MetadataFeature =
    ownedRelationship += OwnedFeatureTyping

MetadataFeature =
    ( ownedRelationship += PrefixMetadataMember )*
    ( '@' | 'metadata' )
    MetadataFeatureDeclaration
    ( 'about' ownedRelationship += Annotation
      ( ',' ownedRelationship += Annotation )*
    )?
    MetadataBody

MetadataFeatureDeclaration : MetadataFeature =
    ( Identification ( ':' | 'typed' 'by' ) )?
    ownedRelationship += OwnedFeatureTyping

MetadataBody : Feature =
    ';' | '{' ( ownedRelationship += MetadataBodyElement )* '}'

MetadataBodyElement : Membership =
      NonFeatureMember
    | MetadataBodyFeatureMember
    | AliasMember
    | Import

MetadataBodyFeatureMember : FeatureMembership =
    ownedMemberFeature = MetadataBodyFeature

MetadataBodyFeature : Feature =
    'feature'? ( ':>>' | 'redefines')? ownedRelationship += OwnedRedefinition
    FeatureSpecializationPart? ValuePart?
    MetadataBody

// Clause 8.2.5.13 Packages Concrete Syntax

Package =
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody

LibraryPackage =
    ( isStandard ?= 'standard' ) 'library'
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody

PackageDeclaration : Package =
    'package' Identification

PackageBody : Package =
      ';'
    | '{' ( NamespaceBodyElement
          | ownedRelationship += ElementFilterMember
          )*
      '}'

ElementFilterMember : ElementFilterMembership =
    MemberPrefix
    'filter' condition = OwnedExpression ';'

// End of BNF
