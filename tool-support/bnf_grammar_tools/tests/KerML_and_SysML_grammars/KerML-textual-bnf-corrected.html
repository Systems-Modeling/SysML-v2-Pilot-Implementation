<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>KerML-textual-bnf-corrected</title>  
<link rel="stylesheet" type="text/css" href="bnf_styles.css">
</head>
<body>
<p>// Source document: tests/KerML_and_SysML_grammars/KerML-textual-bnf-corrected-marked_up.kebnf<br>
// Generated by bnf_grammar_extractor at: 2025-11-30T15:55:22Z
</p>
<p>// Source document: tests\KerML_and_SysML_spec_sources\KerML-spec.html
</p>
<p>// Generated by bnf_grammar_extractor at: 2025-11-14T23:08:48Z<br>
// Manual corrections by HP de Koning
</p>
<p>// Part 1 - Kernel Modeling Language (KerML)
</p>
<h2><a id="c8.2"></a>// Clause 8.2 Concrete Syntax</h2>
<h3><a id="c8.2.1"></a>// Clause 8.2.1 Concrete Syntax Overview</h3>
<h3><a id="c8.2.2"></a>// Clause 8.2.2 Lexical Structure</h3>
<h4><a id="c8.2.2.1"></a>// Clause 8.2.2.1 Line Terminators and White Space</h4>
<a id="LINE_TERMINATOR_"></a>
<pre>LINE_TERMINATOR =
    '\n' | '\r' | '\r\n'
// implementation defined character sequence
</pre>
<a id="LINE_TEXT_"></a>
<pre>LINE_TEXT =
    '[^\r\n]*'
// character sequence excluding LINE_TERMINATORs
</pre>
<a id="WHITE_SPACE_"></a>
<pre>WHITE_SPACE =
     ' ' | '\t' | '\f' | LINE_TERMINATOR
// space | tab | form_feed | LINE_TERMINATOR
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li> Notation text is divided up into lines separated by <em>line terminators</em>. A line terminator may be a single character (such as a line feed) or a sequence of characters (such as a carriage return/line feed combination). This specification does not require any specific encoding for a line terminator, but any encoding used must be consistent throughout any specific input text. </li> <li> Any characters in text line that are not a part of the line terminator are referred to as <em>line text</em>. </li> <li> A <em>white space</em> character is a space, tab, form feed or line terminator. Any contiguous sequence of white space characters can be used to separate tokens that would otherwise be considered to be part of a single token. It is otherwise ignored, with the single exception that a line terminator is used to mark the end of a single-line note (see 8.2.2.2). </li><br>
// </ol>
</p>
<h4><a id="c8.2.2.2"></a>// Clause 8.2.2.2 Notes and Comments</h4>
<a id="SINGLE_LINE_NOTE_"></a>
<pre>SINGLE_LINE_NOTE =
    '//' LINE_TEXT
</pre>
<a id="MULTILINE_NOTE_"></a>
<pre>MULTILINE_NOTE =
    '//*' COMMENT_TEXT '*/'
</pre>
<a id="REGULAR_COMMENT_"></a>
<pre>REGULAR_COMMENT =
    '/*' COMMENT_TEXT '*/'
</pre>
<a id="COMMENT_TEXT_"></a>
<pre>COMMENT_TEXT =
    ( COMMENT_LINE_TEXT | LINE_TERMINATOR )*
</pre>
<a id="COMMENT_LINE_TEXT_"></a>
<pre>COMMENT_LINE_TEXT =
    '.*(?=(\r|\n|\*/))'
// LINE_TEXT excluding the sequence '*/'
</pre>
<h4><a id="c8.2.2.3"></a>// Clause 8.2.2.3 Names</h4>
<a id="NAME_"></a>
<pre>NAME =
    BASIC_NAME | UNRESTRICTED_NAME
</pre>
<a id="BASIC_NAME_"></a>
<pre>BASIC_NAME =
    BASIC_INITIAL_CHARACTER BASIC_NAME_CHARACTER*
</pre>
<a id="SINGLE_QUOTE_"></a>
<pre>SINGLE_QUOTE =
    '#x27'
</pre>
<a id="UNRESTRICTED_NAME_"></a>
<pre>UNRESTRICTED_NAME =
    SINGLE_QUOTE ( NAME_CHARACTER | ESCAPE_SEQUENCE )* SINGLE_QUOTE
</pre>
<p>// (See Note 1)
</p>
<a id="BASIC_INITIAL_CHARACTER_"></a>
<pre>BASIC_INITIAL_CHARACTER =
    ALPHABETIC_CHARACTER | '_'
</pre>
<a id="BASIC_NAME_CHARACTER_"></a>
<pre>BASIC_NAME_CHARACTER =
    BASIC_INITIAL_CHARACTER | DECIMAL_DIGIT
</pre>
<a id="ALPHABETIC_CHARACTER_"></a>
<pre>ALPHABETIC_CHARACTER =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' |
    'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
// any character 'a' through 'z' or 'A' through 'Z'
</pre>
<a id="DECIMAL_DIGIT_"></a>
<pre>DECIMAL_DIGIT =
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</pre>
<a id="NAME_CHARACTER_"></a>
<pre>NAME_CHARACTER =
           'any printable character other than backslash or single_quote'
</pre>
<a id="ESCAPE_SEQUENCE_"></a>
<pre>ESCAPE_SEQUENCE =
    '\f' | '\n' | '\t' | '\r' | '\v'
// (See Note 2)
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>The <code>single_quote</code> character is <code>'</code>. The name represented by an <code>UNRESTRICTED_NAME</code> shall consist of the characters <em>within</em> the single quotes, with escape characters resolved as described below. The surrounding single quote characters are <em>not</em> part of the represented name.</li> <li>An <code>ESCAPE_SEQUENCE</code><em> </em>is a sequence of two text characters starting with a backslash that actually denotes only a single character, except for the newline escape sequence, which represents however many characters is necessary to represent an end of line in a specific implementation (see also <a href="#c8.2.2.1">8.2.2.1</a>). Table 4 shows the meaning of the allowed escape sequences. The <code>ESCAPE_SEQUENCES</code> in an <code>UNRESTRICTED_NAME</code> shall be replaced by the characters specified as their meanings in the actual represented name.</li><br>
// </ol>
</p>
<h4><a id="c8.2.2.4"></a>// Clause 8.2.2.4 Numeric Values</h4>
<a id="DECIMAL_VALUE_"></a>
<pre>DECIMAL_VALUE =
    DECIMAL_DIGIT+
</pre>
<a id="EXPONENTIAL_VALUE_"></a>
<pre>EXPONENTIAL_VALUE =
    DECIMAL_VALUE ('e' | 'E') ('+' | '-')? DECIMAL_VALUE
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>A <code>DECIMAL_VALUE</code> may specify a natural literal, or it may be part of the specification of a real literal (see <a href="#c8.2.5.8.4">8.2.5.8.4</a>). Note that a <code>DECIMAL_VALUE</code> does not include a sign, because negating a literal is an operator in the KerML <code>Expression</code> syntax.</li> <li>An <code>EXPONENTIAL_VALUE</code> may be used in the specification of a real literal (see <a href="#c8.2.5.8.4">8.2.5.8.4</a>). Note that a decimal point and fractional part are not included in the lexical structure of an exponential value. They are handled as part of the syntax of real  literals.</li><br>
// </ol>
</p>
<h4><a id="c8.2.2.5"></a>// Clause 8.2.2.5 String Value</h4>
<a id="STRING_VALUE_"></a>
<pre>STRING_VALUE =
    '"' ( STRING_CHARACTER | ESCAPE_SEQUENCE )* '"'
</pre>
<a id="STRING_CHARACTER_"></a>
<pre>STRING_CHARACTER =
           'any printable character other than backslash or "'
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li><code>ESCAPE_SEQUENCE</code> is specified in <a href="#c8.2.2.3">8.2.2.3</a>.</li><br>
// </ol>
</p>
<h4><a id="c8.2.2.6"></a>// Clause 8.2.2.6 Reserved Words</h4>
<a id="RESERVED_KEYWORD_"></a>
<pre>RESERVED_KEYWORD =
    'about' | 'abstract' | 'alias' | 'all' | 'and' | 'as' | 'assoc' | 'behavior' | 'binding' | 'bool' | 'by' | 'chains'
    | 'class' | 'classifier' | 'comment' | 'composite' | 'conjugate' | 'conjugates' | 'conjugation' | 'connector'
    | 'const' | 'crosses' | 'datatype' | 'default' | 'dependency' | 'derived' | 'differences' | 'disjoining' | 'disjoint'
    | 'doc' | 'else' | 'end' | 'expr' | 'false' | 'feature' | 'featured' | 'featuring' | 'filter' | 'first' | 'flow'
    | 'for' | 'from' | 'function' | 'hastype' | 'if' | 'implies' | 'import' | 'in' | 'inout' | 'interaction'
    | 'intersects' | 'inv' | 'inverse' | 'inverting' | 'istype' | 'language' | 'library' | 'locale' | 'member' | 'meta'
    | 'metaclass' | 'metadata' | 'multiplicity' | 'namespace' | 'nonunique' | 'not' | 'null' | 'of' | 'or' | 'ordered'
    | 'out' | 'package' | 'portion' | 'predicate' | 'private' | 'protected' | 'public' | 'redefines' | 'redefinition'
    | 'references' | 'rep' | 'return' | 'specialization' | 'specializes' | 'standard' | 'step' | 'struct'
    | 'subclassifier' | 'subset' | 'subsets' | 'subtype' | 'succession' | 'then' | 'to' | 'true' | 'type' | 'typed'
    | 'typing' | 'unions' | 'var' | 'xor'
</pre>
<h4><a id="c8.2.2.7"></a>// Clause 8.2.2.7 Symbols</h4>
<a id="RESERVED_SYMBOL_"></a>
<pre>RESERVED_SYMBOL =
    '~' | '}' | '|' | '{' | '^' | ']' | '[' | '@' | '??' | '?' | '>=' | '>' | '=>' | '===' | '==' | '=' | '<=' | '<'
    | ';' | ':>>' | ':>' | ':=' | '::>' | '::' | ':' | '/' | '.?' | '..' | '.' | '->' | '-' | ',' | '+' | '**' | '*' | ')'
    | '(' | '&' | '%' | '$' | '#' | '!==' | '!='
</pre>
<a id="TYPED_BY_"></a>
<pre>TYPED_BY    = ':'   | 'typed' 'by'
</pre>
<a id="SPECIALIZES_"></a>
<pre>SPECIALIZES = ':>'  | 'specializes'
</pre>
<a id="SUBSETS_"></a>
<pre>SUBSETS     = ':>'  | 'subsets'
</pre>
<a id="REFERENCES_"></a>
<pre>REFERENCES  = '::>' | 'references'
</pre>
<a id="CROSSES_"></a>
<pre>CROSSES     = '=>'  | 'crosses'
</pre>
<a id="REDEFINES_"></a>
<pre>REDEFINES   = ':>>' | 'redefines'
</pre>
<a id="CONJUGATES_"></a>
<pre>CONJUGATES  = '~'   | 'conjugates'
</pre>
<h3><a id="c8.2.3"></a>// Clause 8.2.3 Root Concrete Syntax</h3>
<h4><a id="c8.2.3.1"></a>// Clause 8.2.3.1 Elements and Relationships Concrete Syntax</h4>
<a id="Identification"></a>
<pre>Identification : Element =
    ( '<' declaredShortName = NAME '>' )?
    ( declaredName = NAME )?
</pre>
<a id="RelationshipBody"></a>
<pre>RelationshipBody : Relationship =
    ';' | '{' RelationshipOwnedElement* '}'
</pre>
<a id="RelationshipOwnedElement"></a>
<pre>RelationshipOwnedElement : Relationship =
      ownedRelatedElement += OwnedRelatedElement
    | ownedRelationship += OwnedAnnotation
</pre>
<a id="OwnedRelatedElement"></a>
<pre>OwnedRelatedElement : Element =
    NonFeatureElement | FeatureElement
</pre>
<h4><a id="c8.2.3.2"></a>// Clause 8.2.3.2 Dependencies Concrete Syntax</h4>
<a id="Dependency"></a>
<pre>Dependency =
    ( ownedRelationship += PrefixMetadataAnnotation )*
    'dependency' ( Identification? 'from' )?
    client += [QualifiedName] ( ',' client += [QualifiedName] )* 'to'
    supplier += [QualifiedName] ( ',' supplier += [QualifiedName] )*
    RelationshipBody
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li><code>PrefixMetadataAnnotation</code> is defined in the Kernel layer (see <a href="#c8.2.5.12">8.2.5.12</a>).</li><br>
// </ol>
</p>
<h4><a id="c8.2.3.3"></a>// Clause 8.2.3.3 Annotations Concrete Syntax</h4>
<h5><a id="c8.2.3.3.1"></a>// Clause 8.2.3.3.1 Annotations</h5>
<a id="Annotation"></a>
<pre>Annotation =
    annotatedElement = [QualifiedName]
</pre>
<a id="OwnedAnnotation"></a>
<pre>OwnedAnnotation : Annotation =
    ownedRelatedElement += AnnotatingElement
</pre>
<a id="AnnotatingElement"></a>
<pre>AnnotatingElement =
      Comment
    | Documentation
    | TextualRepresentation
    | MetadataFeature
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li><code>MetadataFeature</code> is defined in the Kernel layer (see <a href="#c8.2.5.12">8.2.5.12</a>).</li><br>
// </ol>
</p>
<h5><a id="c8.2.3.3.2"></a>// Clause 8.2.3.3.2 Comments and Documentation</h5>
<a id="Comment"></a>
<pre>Comment =
    ( 'comment' Identification
      ( 'about' ownedRelationship += Annotation
        ( ',' ownedRelationship += Annotation )*
      )?
    )?
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT
</pre>
<a id="Documentation"></a>
<pre>Documentation =
    'doc' Identification
    ( 'locale' locale = STRING_VALUE )?
    body = REGULAR_COMMENT
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>The text of a lexical <code>REGULAR_COMMENT</code> or <code>PREFIX_COMMENT</code> shall be processed as follows before it is included as the body of a <code>Comment</code> or <code>Documentation</code>:<br>
// <br>
// 	<ol> <li> Remove the initial <code>/*</code> and final <code>*/</code> characters. </li> <li> Remove any white space immediately after the initial <code>/*</code>, up to and including the first line terminator (if any). </li> <li> On each subsequent line of the text: <ol> <li> Strip initial white space other than line terminators. </li> <li> Then, if the first remaining character is "<code>*</code>", remove it. </li> <li> Then, if the first remaining character is now a space, remove it. </li> </ol> </li> </ol> </li> <li>The body text of a <code>Comment</code> can include markup information (such as HTML), and a conforming tool may display such text as rendered according to the markup. However, marked up "rich text" for a <code>Comment</code> written using the KerML textual concrete syntax shall be stored in the <code>Comment</code> body in plain text including all mark up text, with all line terminators and white space included as entered, other than what is removed according to the rules above.</li><br>
// </ol>
</p>
<h5><a id="c8.2.3.3.3"></a>// Clause 8.2.3.3.3 Textual Representation</h5>
<a id="TextualRepresentation"></a>
<pre>TextualRepresentation =
    ( 'rep' Identification )?
    'language' language = STRING_VALUE
    body = REGULAR_COMMENT
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>The lexical text of a <code>REGULAR_COMMENT</code> shall be processed as specified in <a href="#c8.2.3.3.2">8.2.3.3.2</a> for <code>Comments</code> before being included as the body of a <code>TextualRepresentation</code>.</li> <li>See also 8.3.2.3.6 on the standard <code>language</code> names recognized for a <code>TextualRepresentation</code>.</li><br>
// </ol>
</p>
<h4><a id="c8.2.3.4"></a>// Clause 8.2.3.4 Namespaces Concrete Syntax</h4>
<h5><a id="c8.2.3.4.1"></a>// Clause 8.2.3.4.1 Namespaces</h5>
<a id="RootNamespace"></a>
<pre>RootNamespace : Namespace =
    NamespaceBodyElement*
</pre>
<p>// (See Note 1)
</p>
<a id="Namespace"></a>
<pre>Namespace =
    ( ownedRelationship += PrefixMetadataMember )*
    NamespaceDeclaration NamespaceBody
</pre>
<p>// (See Note 2)
</p>
<a id="NamespaceDeclaration"></a>
<pre>NamespaceDeclaration : Namespace =
    'namespace' Identification
</pre>
<a id="NamespaceBody"></a>
<pre>NamespaceBody : Namespace =
    ';' | '{' NamespaceBodyElement* '}'
</pre>
<a id="NamespaceBodyElement"></a>
<pre>NamespaceBodyElement : Namespace =
      ownedRelationship += NamespaceMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
</pre>
<a id="MemberPrefix"></a>
<pre>MemberPrefix : Membership =
    ( visibility = VisibilityIndicator )?
</pre>
<a id="VisibilityIndicator"></a>
<pre>VisibilityIndicator : VisibilityKind =
    'public' | 'private' | 'protected'
</pre>
<a id="NamespaceMember"></a>
<pre>NamespaceMember : OwningMembership =
      NonFeatureMember
    | NamespaceFeatureMember
</pre>
<a id="NonFeatureMember"></a>
<pre>NonFeatureMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += MemberElement
</pre>
<a id="NamespaceFeatureMember"></a>
<pre>NamespaceFeatureMember : OwningMembership =
    MemberPrefix
    ownedRelatedElement += FeatureElement
</pre>
<a id="AliasMember"></a>
<pre>AliasMember : Membership =
    MemberPrefix
    'alias' ( '<' memberShortName = NAME '>' )?
    ( memberName = NAME )?
    'for' memberElement = [QualifiedName]
    RelationshipBody
</pre>
<a id="QualifiedName"></a>
<pre>QualifiedName =
   ( '$' '::' )? ( NAME '::' )* NAME
</pre>
<p>// (See Note 3)
</p>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>A <em>root</em> <code>Namespace</code> is a <code>Namespace</code> that has no <code>owningNamespace</code> (see 8.3.2.4). Every <code>Element</code> other than a root <code>Namespace</code> must be contained, directly or indirectly, within some root <code>Namespace</code>. Therefore, every valid KerML concrete syntax text can be parsed starting from the <code>RootNamespace</code> production.</li> <li><code>PrefixMetadataMember</code> is defined in the Kernel layer (see <a href="#c8.2.5.12">8.2.5.12</a>).</li> <li>A qualified name is notated as a sequence of <em>segment names</em> separated by "<code>::</code>" punctuation, optionally with the global scope qualifier "<code>$</code>" as an initial segment. An <em>unqualified</em> name can be considered the degenerate case of a qualified name with a single segment name. A qualified name is used in the KerML textual concrete syntax to identify an <code>Element</code> that is being referred to in the representation of another <code>Element</code>. A qualified name used in this way does not appear in the corresponding abstract syntaxâ€”instead, the abstract syntax representation contains an actual reference to the identified <code>Element</code>. <em>Name resolution</em> is the process of determining the <code>Element</code> that is identified by a qualified name. The segment names of the qualified name other than the last identify a sequence of nested <code>Namespaces</code> that provide the context for resolving the final segment name (see <a href="#c8.2.3.5">8.2.3.5</a>). The notation <code>[QualifiedName]</code> is used in concrete syntax grammar productions to indicate the result of resolving text parsed as a <code>QualifiedName</code> (see also <a href="#c8.2.1">8.2.1</a>).</li><br>
// </ol>
</p>
<h5><a id="c8.2.3.4.2"></a>// Clause 8.2.3.4.2 Imports</h5>
<a id="Import"></a>
<pre>Import =
    visibility = VisibilityIndicator
    'import' ( isImportAll ?= 'all' )?
    ImportDeclaration RelationshipBody
</pre>
<a id="ImportDeclaration"></a>
<pre>ImportDeclaration : Import =
    MembershipImport | NamespaceImport
</pre>
<a id="MembershipImport"></a>
<pre>MembershipImport =
    importedMembership = [QualifiedName]
    ( '::' isRecursive ?= '**' )?
</pre>
<p>// (See Note 1)
</p>
<a id="NamespaceImport"></a>
<pre>NamespaceImport =
      importedNamespace = [QualifiedName] '::' '*'
      ( '::' isRecursive ?= '**' )?
    | importedNamespace = FilterPackage
      { ownedRelatedElement += importedNamespace }
</pre>
<a id="FilterPackage"></a>
<pre>FilterPackage : Package =
    ownedRelationship += ImportDeclaration
    ( ownedRelationship += FilterPackageMember )+
</pre>
<a id="FilterPackageMember"></a>
<pre>FilterPackageMember : ElementFilterMembership =
    '[' ownedRelatedElement += OwnedExpression ']'
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>The <code>importedMembership</code> of a <code>MembershipImport</code> is the single case in which the <code>Element</code> required from the resolution <code>[QualifiedName]</code> is the actual <code>Membership</code> identified by the <code>QualifedName</code>, <em>not</em> the <code>memberElement</code> of that <code>Membership</code> (see <a href="#c8.2.3.5">8.2.3.5</a>).</li><br>
// </ol>
</p>
<h5><a id="c8.2.3.4.3"></a>// Clause 8.2.3.4.3 Namespace Elements</h5>
<a id="MemberElement"></a>
<pre>MemberElement : Element =
    AnnotatingElement | NonFeatureElement
</pre>
<a id="NonFeatureElement"></a>
<pre>NonFeatureElement : Element =
      Dependency
    | Namespace
    | Type
    | Classifier
    | DataType
    | Class
    | Structure
    | Metaclass
    | Association
    | AssociationStructure
    | Interaction
    | Behavior
    | Function
    | Predicate
    | Multiplicity
    | Package
    | LibraryPackage
    | Specialization
    | Conjugation
    | Subclassification
    | Disjoining
    | FeatureInverting
    | FeatureTyping
    | Subsetting
    | Redefinition
    | TypeFeaturing
</pre>
<a id="FeatureElement"></a>
<pre>FeatureElement : Feature =
      Feature
    | Step
    | Expression
    | BooleanExpression
    | Invariant
    | Connector
    | BindingConnector
    | Succession
    | Flow
    | SuccessionFlow
</pre>
<h4><a id="c8.2.3.5"></a>// Clause 8.2.3.5 Name Resolution</h4>
<h5><a id="c8.2.3.5.1"></a>// Clause 8.2.3.5.1 Name Resolution Overview</h5>
<h5><a id="c8.2.3.5.2"></a>// Clause 8.2.3.5.2 Local and Global Namespaces</h5>
<h5><a id="c8.2.3.5.3"></a>// Clause 8.2.3.5.3 Local and Visible Resolution</h5>
<h5><a id="c8.2.3.5.4"></a>// Clause 8.2.3.5.4 Full Resolution</h5>
<h3><a id="c8.2.4"></a>// Clause 8.2.4 Core Concrete Syntax</h3>
<h4><a id="c8.2.4.1"></a>// Clause 8.2.4.1 Types Concrete Syntax</h4>
<h5><a id="c8.2.4.1.1"></a>// Clause 8.2.4.1.1 Types</h5>
<a id="Type"></a>
<pre>Type =
    TypePrefix 'type'
    TypeDeclaration TypeBody
</pre>
<a id="TypePrefix"></a>
<pre>TypePrefix : Type =
    ( isAbstract ?= 'abstract' )?
    ( ownedRelationship += PrefixMetadataMember )*
</pre>
<a id="TypeDeclaration"></a>
<pre>TypeDeclaration : Type =
    ( isSufficient ?= 'all' )? Identification
    ( ownedRelationship += OwnedMultiplicity )?
    ( SpecializationPart | ConjugationPart )+
    TypeRelationshipPart*
</pre>
<a id="SpecializationPart"></a>
<pre>SpecializationPart : Type =
    SPECIALIZES ownedRelationship += OwnedSpecialization
    ( ',' ownedRelationship += OwnedSpecialization )*
</pre>
<a id="ConjugationPart"></a>
<pre>ConjugationPart : Type =
    CONJUGATES ownedRelationship += OwnedConjugation
</pre>
<a id="TypeRelationshipPart"></a>
<pre>TypeRelationshipPart : Type =
      DisjoiningPart
    | UnioningPart
    | IntersectingPart
    | DifferencingPart
</pre>
<a id="DisjoiningPart"></a>
<pre>DisjoiningPart : Type =
    'disjoint' 'from' ownedRelationship += OwnedDisjoining
    ( ',' ownedRelationship += OwnedDisjoining )*
</pre>
<a id="UnioningPart"></a>
<pre>UnioningPart : Type =
    'unions' ownedRelationship += Unioning
    ( ',' ownedRelationship += Unioning )*
</pre>
<a id="IntersectingPart"></a>
<pre>IntersectingPart : Type =
    'intersects' ownedRelationship += Intersecting
    ( ',' ownedRelationship += Intersecting )*
</pre>
<a id="DifferencingPart"></a>
<pre>DifferencingPart : Type =
    'differences' ownedRelationship += Differencing
    ( ',' ownedRelationship += Differencing )*
</pre>
<a id="TypeBody"></a>
<pre>TypeBody : Type =
    ';' | '{' TypeBodyElement* '}'
</pre>
<a id="TypeBodyElement"></a>
<pre>TypeBodyElement : Type =
      ownedRelationship += NonFeatureMember
    | ownedRelationship += FeatureMember
    | ownedRelationship += AliasMember
    | ownedRelationship += Import
</pre>
<h5><a id="c8.2.4.1.2"></a>// Clause 8.2.4.1.2 Specialization</h5>
<a id="Specialization"></a>
<pre>Specialization =
    ( 'specialization' Identification )?
    'subtype' SpecificType
    SPECIALIZES GeneralType
    RelationshipBody
</pre>
<a id="OwnedSpecialization"></a>
<pre>OwnedSpecialization : Specialization =
    GeneralType
</pre>
<a id="SpecificType"></a>
<pre>SpecificType : Specialization =
      specific = [QualifiedName]
    | specific += OwnedFeatureChain
      { ownedRelatedElement += specific }
</pre>
<a id="GeneralType"></a>
<pre>GeneralType : Specialization =
      general = [QualifiedName]
    | general += OwnedFeatureChain
      { ownedRelatedElement += general }
</pre>
<h5><a id="c8.2.4.1.3"></a>// Clause 8.2.4.1.3 Conjugation</h5>
<a id="Conjugation"></a>
<pre>Conjugation =
    ( 'conjugation' Identification )?
    'conjugate'
    ( conjugatedType = [QualifiedName]
    | conjugatedType = FeatureChain
      { ownedRelatedElement += conjugatedType }
    )
    CONJUGATES
    ( originalType = [QualifiedName]
    | originalType = FeatureChain
      { ownedRelatedElement += originalType }
    )
    RelationshipBody
</pre>
<a id="OwnedConjugation"></a>
<pre>OwnedConjugation : Conjugation =
      originalType = [QualifiedName]
    | originalType = FeatureChain
      { ownedRelatedElement += originalType }
</pre>
<h5><a id="c8.2.4.1.4"></a>// Clause 8.2.4.1.4 Disjoining</h5>
<a id="Disjoining"></a>
<pre>Disjoining =
    ( 'disjoining' Identification )?
    'disjoint'
    ( typeDisjoined = [QualifiedName]
    | typeDisjoined = FeatureChain
      { ownedRelatedElement += typeDisjoined }
    )
    'from'
    ( disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
      { ownedRelatedElement += disjoiningType }
    )
    RelationshipBody
</pre>
<a id="OwnedDisjoining"></a>
<pre>OwnedDisjoining : Disjoining =
      disjoiningType = [QualifiedName]
    | disjoiningType = FeatureChain
      { ownedRelatedElement += disjoiningType }
</pre>
<h5><a id="c8.2.4.1.5"></a>// Clause 8.2.4.1.5 Unioning, Intersecting and Differencing</h5>
<a id="Unioning"></a>
<pre>Unioning =
      unioningType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain
</pre>
<a id="Intersecting"></a>
<pre>Intersecting =
      intersectingType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain
</pre>
<a id="Differencing"></a>
<pre>Differencing =
      differencingType = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain
</pre>
<h5><a id="c8.2.4.1.6"></a>// Clause 8.2.4.1.6 Feature Membership</h5>
<a id="FeatureMember"></a>
<pre>FeatureMember : OwningMembership =
      TypeFeatureMember
    | OwnedFeatureMember
</pre>
<a id="TypeFeatureMember"></a>
<pre>TypeFeatureMember : OwningMembership =
    MemberPrefix 'member' ownedRelatedElement += FeatureElement
</pre>
<a id="OwnedFeatureMember"></a>
<pre>OwnedFeatureMember : FeatureMembership =
    MemberPrefix ownedRelatedElement += FeatureElement
</pre>
<h4><a id="c8.2.4.2"></a>// Clause 8.2.4.2 Classifiers Concrete Syntax</h4>
<h5><a id="c8.2.4.2.1"></a>// Clause 8.2.4.2.1 Classifiers</h5>
<a id="Classifier"></a>
<pre>Classifier =
    TypePrefix 'classifier'
    ClassifierDeclaration TypeBody
</pre>
<a id="ClassifierDeclaration"></a>
<pre>ClassifierDeclaration : Classifier =
    ( isSufficient ?= 'all' )? Identification
    ( ownedRelationship += OwnedMultiplicity )?
    ( SuperclassingPart | ConjugationPart )?
    TypeRelationshipPart*
</pre>
<a id="SuperclassingPart"></a>
<pre>SuperclassingPart : Classifier =
      SPECIALIZES ownedRelationship += OwnedSubclassification
      ( ',' ownedRelationship += OwnedSubclassification )*
</pre>
<h5><a id="c8.2.4.2.2"></a>// Clause 8.2.4.2.2 Subclassification</h5>
<a id="Subclassification"></a>
<pre>Subclassification =
    ( 'specialization' Identification )?
    'subclassifier' subclassifier = [QualifiedName]
    SPECIALIZES superclassifier = [QualifiedName]
    RelationshipBody
</pre>
<a id="OwnedSubclassification"></a>
<pre>OwnedSubclassification : Subclassification =
    superclassifier = [QualifiedName]
</pre>
<h4><a id="c8.2.4.3"></a>// Clause 8.2.4.3 Features Concrete Syntax</h4>
<h5><a id="c8.2.4.3.1"></a>// Clause 8.2.4.3.1 Features</h5>
<a id="Feature"></a>
<pre>Feature =
    ( FeaturePrefix
      ( 'feature' | ownedRelationship += PrefixMetadataMember )
      FeatureDeclaration?
    | ( EndFeaturePrefix | BasicFeaturePrefix )
      FeatureDeclaration
    )
    ValuePart? TypeBody
</pre>
<p>// (See Note 1)
</p>
<a id="EndFeaturePrefix"></a>
<pre>EndFeaturePrefix : Feature =
    ( isConstant ?= 'const' { isVariable = true } )?
    isEnd ?= 'end'
</pre>
<a id="BasicFeaturePrefix"></a>
<pre>BasicFeaturePrefix : Feature =
    ( direction = FeatureDirection )?
    ( isDerived ?= 'derived' )?
    ( isAbstract ?= 'abstract' )?
    ( isComposite ?= 'composite' | isPortion ?= 'portion' )?
    ( isVariable ?= 'var' | isConstant ?= 'const' { isVariable = true } )?
</pre>
<a id="FeaturePrefix"></a>
<pre>FeaturePrefix =
    ( EndFeaturePrefix ( ownedRelationship += OwnedCrossFeatureMember )?
    | BasicFeaturePrefix
    )
    ( ownedRelationship += PrefixMetadataMember )*
</pre>
<p>// (See Note 1)
</p>
<a id="OwnedCrossFeatureMember"></a>
<pre>OwnedCrossFeatureMember : OwningMembership =
    ownedRelatedElement += OwnedCrossFeature
</pre>
<a id="OwnedCrossFeature"></a>
<pre>OwnedCrossFeature : Feature =
    BasicFeaturePrefix FeatureDeclaration
</pre>
<a id="FeatureDirection"></a>
<pre>FeatureDirection : FeatureDirectionKind =
    'in' | 'out' | 'inout'
</pre>
<a id="FeatureDeclaration"></a>
<pre>FeatureDeclaration : Feature =
    ( isSufficient ?= 'all' )?
    ( FeatureIdentification
      ( FeatureSpecializationPart | ConjugationPart )?
    | FeatureSpecializationPart
    | ConjugationPart
    )
    FeatureRelationshipPart*
</pre>
<a id="FeatureIdentification"></a>
<pre>FeatureIdentification : Feature =
      '<' declaredShortName = NAME '>' ( declaredName = NAME )?
    | declaredName = NAME
</pre>
<a id="FeatureRelationshipPart"></a>
<pre>FeatureRelationshipPart : Feature =
      TypeRelationshipPart
    | ChainingPart
    | InvertingPart
    | TypeFeaturingPart
</pre>
<a id="ChainingPart"></a>
<pre>ChainingPart : Feature =
    'chains'
    ( ownedRelationship += OwnedFeatureChaining
    | FeatureChain )
</pre>
<a id="InvertingPart"></a>
<pre>InvertingPart : Feature =
    'inverse' 'of' ownedRelationship += OwnedFeatureInverting
</pre>
<a id="TypeFeaturingPart"></a>
<pre>TypeFeaturingPart : Feature =
    'featured' 'by' ownedRelationship += OwnedTypeFeaturing
    ( ',' ownedTypeFeaturing += OwnedTypeFeaturing )*
</pre>
<a id="FeatureSpecializationPart"></a>
<pre>FeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization*
</pre>
<a id="MultiplicityPart"></a>
<pre>MultiplicityPart : Feature =
      ownedRelationship += OwnedMultiplicity
    | ( ownedRelationship += OwnedMultiplicity )?
      ( isOrdered ?= 'ordered' ( {isUnique = false} 'nonunique' )?
      | {isUnique = false} 'nonunique' ( isOrdered ?= 'ordered' )? )
</pre>
<a id="FeatureSpecialization"></a>
<pre>FeatureSpecialization : Feature =
    Typings | Subsettings | References | Crosses | Redefinitions
</pre>
<a id="Typings"></a>
<pre>Typings : Feature =
      TypedBy ( ',' ownedRelationship += OwnedFeatureTyping )*
</pre>
<a id="TypedBy"></a>
<pre>TypedBy : Feature =
    TYPED_BY ownedRelationship += OwnedFeatureTyping
</pre>
<a id="Subsettings"></a>
<pre>Subsettings : Feature =
    Subsets ( ',' ownedRelationship += OwnedSubsetting )*
</pre>
<a id="Subsets"></a>
<pre>Subsets : Feature =
    SUBSETS ownedRelationship += OwnedSubsetting
</pre>
<a id="References"></a>
<pre>References : Feature =
    REFERENCES ownedRelationship += OwnedReferenceSubsetting
</pre>
<a id="Crosses"></a>
<pre>Crosses : Feature =
    CROSSES ownedRelationship += OwnedCrossSubsetting
</pre>
<a id="Redefinitions"></a>
<pre>Redefinitions : Feature =
    Redefines ( ',' ownedRelationship += OwnedRedefinition )*
</pre>
<a id="Redefines"></a>
<pre>Redefines : Feature =
    REDEFINES ownedRelationship += OwnedRedefinition
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li><code>PrefixMetadataMember</code> is defined in the Kernel layer (see 8.3.4.12).</li><br>
// </ol>
</p>
<h5><a id="c8.2.4.3.2"></a>// Clause 8.2.4.3.2 Feature Typing</h5>
<a id="FeatureTyping"></a>
<pre>FeatureTyping =
    ( 'specialization' Identification )?
    'typing' typedFeature = [QualifiedName]
    TYPED_BY GeneralType
    RelationshipBody
</pre>
<a id="OwnedFeatureTyping"></a>
<pre>OwnedFeatureTyping : FeatureTyping =
    GeneralType
</pre>
<h5><a id="c8.2.4.3.3"></a>// Clause 8.2.4.3.3 Subsetting</h5>
<a id="Subsetting"></a>
<pre>Subsetting =
    ( 'specialization' Identification )?
    'subset' SpecificType
    SUBSETS GeneralType
    RelationshipBody
</pre>
<a id="OwnedSubsetting"></a>
<pre>OwnedSubsetting : Subsetting =
    GeneralType
</pre>
<a id="OwnedReferenceSubsetting"></a>
<pre>OwnedReferenceSubsetting : ReferenceSubsetting =
    GeneralType
</pre>
<a id="OwnedCrossSubsetting"></a>
<pre>OwnedCrossSubsetting : CrossSubsetting =
    GeneralType
</pre>
<h5><a id="c8.2.4.3.4"></a>// Clause 8.2.4.3.4 Redefinition</h5>
<a id="Redefinition"></a>
<pre>Redefinition =
    ( 'specialization' Identification )?
    'redefinition' SpecificType
    REDEFINES GeneralType
    RelationshipBody
</pre>
<a id="OwnedRedefinition"></a>
<pre>OwnedRedefinition : Redefinition =
    GeneralType
</pre>
<h5><a id="c8.2.4.3.5"></a>// Clause 8.2.4.3.5 Feature Chaining</h5>
<a id="OwnedFeatureChain"></a>
<pre>OwnedFeatureChain : Feature =
    FeatureChain
</pre>
<a id="FeatureChain"></a>
<pre>FeatureChain : Feature =
    ownedRelationship += OwnedFeatureChaining
    ( '.' ownedRelationship += OwnedFeatureChaining )+
</pre>
<a id="OwnedFeatureChaining"></a>
<pre>OwnedFeatureChaining : FeatureChaining =
    chainingFeature = [QualifiedName]
</pre>
<h5><a id="c8.2.4.3.6"></a>// Clause 8.2.4.3.6 Feature Inverting</h5>
<a id="FeatureInverting"></a>
<pre>FeatureInverting =
    ( 'inverting' Identification? )?
    'inverse'
    ( featureInverted = [QualifiedName]
    | featureInverted = OwnedFeatureChain
      { ownedRelatedElement += featureInverted }
    )
    'of'
    ( invertingFeature = [QualifiedName]
    | ownedRelatedElement += OwnedFeatureChain
      { ownedRelatedElement += invertingFeature }
    )
    RelationshipBody
</pre>
<a id="OwnedFeatureInverting"></a>
<pre>OwnedFeatureInverting : FeatureInverting =
      invertingFeature = [QualifiedName]
    | invertingFeature = OwnedFeatureChain
      { ownedRelatedElement += invertingFeature }
</pre>
<h5><a id="c8.2.4.3.7"></a>// Clause 8.2.4.3.7 Type Featuring</h5>
<a id="TypeFeaturing"></a>
<pre>TypeFeaturing =
    'featuring' ( Identification 'of' )?
    featureOfType = [QualifiedName]
    'by' featuringType = [QualifiedName]
    RelationshipBody
</pre>
<a id="OwnedTypeFeaturing"></a>
<pre>OwnedTypeFeaturing : TypeFeaturing =
    featuringType = [QualifiedName]
</pre>
<h3><a id="c8.2.5"></a>// Clause 8.2.5 Kernel Concrete Syntax</h3>
<h4><a id="c8.2.5.1"></a>// Clause 8.2.5.1 Data Types Concrete Syntax</h4>
<a id="DataType"></a>
<pre>DataType =
    TypePrefix 'datatype'
    ClassifierDeclaration TypeBody
</pre>
<h4><a id="c8.2.5.2"></a>// Clause 8.2.5.2 Classes Concrete Syntax</h4>
<a id="Class"></a>
<pre>Class =
    TypePrefix 'class'
    ClassifierDeclaration TypeBody
</pre>
<h4><a id="c8.2.5.3"></a>// Clause 8.2.5.3 Structures Concrete Syntax</h4>
<a id="Structure"></a>
<pre>Structure =
    TypePrefix 'struct'
    ClassifierDeclaration TypeBody
</pre>
<h4><a id="c8.2.5.4"></a>// Clause 8.2.5.4 Associations Concrete Syntax</h4>
<a id="Association"></a>
<pre>Association =
    TypePrefix 'assoc'
    ClassifierDeclaration TypeBody
</pre>
<a id="AssociationStructure"></a>
<pre>AssociationStructure =
    TypePrefix 'assoc' 'struct'
    ClassifierDeclaration TypeBody
</pre>
<h4><a id="c8.2.5.5"></a>// Clause 8.2.5.5 Connectors Concrete Syntax</h4>
<h5><a id="c8.2.5.5.1"></a>// Clause 8.2.5.5.1 Connectors</h5>
<a id="Connector"></a>
<pre>Connector =
    FeaturePrefix 'connector'
    ( FeatureDeclaration? ValuePart?
    | ConnectorDeclaration
    )
    TypeBody
</pre>
<a id="ConnectorDeclaration"></a>
<pre>ConnectorDeclaration : Connector =
    BinaryConnectorDeclaration | NaryConnectorDeclaration
</pre>
<a id="BinaryConnectorDeclaration"></a>
<pre>BinaryConnectorDeclaration : Connector =
    ( FeatureDeclaration? 'from' | isSufficient ?= 'all' 'from'? )?
    ownedRelationship += ConnectorEndMember 'to'
    ownedRelationship += ConnectorEndMember
</pre>
<a id="NaryConnectorDeclaration"></a>
<pre>NaryConnectorDeclaration : Connector =
    FeatureDeclaration?
    '(' ownedRelationship += ConnectorEndMember ','
        ownedRelationship += ConnectorEndMember
        ( ',' ownedRelationship += ConnectorEndMember )*
    ')'
</pre>
<a id="ConnectorEndMember"></a>
<pre>ConnectorEndMember : EndFeatureMembership =
    ownedRelatedElement += ConnectorEnd
</pre>
<a id="ConnectorEnd"></a>
<pre>ConnectorEnd : Feature =
	( ownedRelationship += OwnedCrossMultiplicityMember )?
	( declaredName = NAME REFERENCES )?
	ownedRelationship += OwnedReferenceSubsetting
</pre>
<a id="OwnedCrossMultiplicityMember"></a>
<pre>OwnedCrossMultiplicityMember : OwningMembership =
	ownedRelatedElement += OwnedCrossMultiplicity
</pre>
<a id="OwnedCrossMultiplicity"></a>
<pre>OwnedCrossMultiplicity : Feature =
	ownedRelationship += OwnedMultiplicity
</pre>
<h5><a id="c8.2.5.5.2"></a>// Clause 8.2.5.5.2 Binding Connectors</h5>
<a id="BindingConnector"></a>
<pre>BindingConnector =
    FeaturePrefix 'binding'
    BindingConnectorDeclaration TypeBody
</pre>
<a id="BindingConnectorDeclaration"></a>
<pre>BindingConnectorDeclaration : BindingConnector =
      FeatureDeclaration
      ( 'of' ownedRelationship += ConnectorEndMember
        '='  ownedRelationship += ConnectorEndMember )?
    | ( isSufficient ?= 'all' )?
      ( 'of'? ownedRelationship += ConnectorEndMember
        '='   ownedRelationship += ConnectorEndMember )?
</pre>
<h5><a id="c8.2.5.5.3"></a>// Clause 8.2.5.5.3 Successions</h5>
<a id="Succession"></a>
<pre>Succession =
    FeaturePrefix 'succession'
    SuccessionDeclaration TypeBody
</pre>
<a id="SuccessionDeclaration"></a>
<pre>SuccessionDeclaration : Succession =
      FeatureDeclaration
      ( 'first' ownedRelationship += ConnectorEndMember
        'then'  ownedRelationship += ConnectorEndMember )?
    | ( s.isSufficient ?= 'all' )?
      ( 'first'? ownedRelationship += ConnectorEndMember
        'then'   ownedRelationship += ConnectorEndMember )?
</pre>
<h4><a id="c8.2.5.6"></a>// Clause 8.2.5.6 Behaviors Concrete Syntax</h4>
<h5><a id="c8.2.5.6.1"></a>// Clause 8.2.5.6.1 Behaviors</h5>
<a id="Behavior"></a>
<pre>Behavior =
    TypePrefix 'behavior'
    ClassifierDeclaration TypeBody
</pre>
<h5><a id="c8.2.5.6.2"></a>// Clause 8.2.5.6.2 Steps</h5>
<a id="Step"></a>
<pre>Step =
    FeaturePrefix
    'step' FeatureDeclaration ValuePart?
    TypeBody
</pre>
<h4><a id="c8.2.5.7"></a>// Clause 8.2.5.7 Functions Concrete Syntax</h4>
<h5><a id="c8.2.5.7.1"></a>// Clause 8.2.5.7.1 Functions</h5>
<a id="Function"></a>
<pre>Function =
    TypePrefix 'function'
    ClassifierDeclaration FunctionBody
</pre>
<a id="FunctionBody"></a>
<pre>FunctionBody : Type =
    ';' | '{' FunctionBodyPart '}'
</pre>
<a id="FunctionBodyPart"></a>
<pre>FunctionBodyPart : Type =
    ( TypeBodyElement
    | ownedRelationship += ReturnFeatureMember
    )*
   ( ownedRelationship += ResultExpressionMember )?
</pre>
<a id="ReturnFeatureMember"></a>
<pre>ReturnFeatureMember : ReturnParameterMembership =
    MemberPrefix 'return'
    ownedRelatedElement += FeatureElement
</pre>
<a id="ResultExpressionMember"></a>
<pre>ResultExpressionMember : ResultExpressionMembership =
    MemberPrefix
    ownedRelatedElement += OwnedExpression
</pre>
<h5><a id="c8.2.5.7.2"></a>// Clause 8.2.5.7.2 Expressions</h5>
<a id="Expression"></a>
<pre>Expression =
    FeaturePrefix
    'expr' FeatureDeclaration ValuePart?
    FunctionBody
</pre>
<h5><a id="c8.2.5.7.3"></a>// Clause 8.2.5.7.3 Predicates</h5>
<a id="Predicate"></a>
<pre>Predicate =
    TypePrefix 'predicate'
    ClassifierDeclaration FunctionBody
</pre>
<h5><a id="c8.2.5.7.4"></a>// Clause 8.2.5.7.4 Boolean Expressions and Invariants</h5>
<a id="BooleanExpression"></a>
<pre>BooleanExpression =
    FeaturePrefix
    'bool' FeatureDeclaration ValuePart?
    FunctionBody
</pre>
<a id="Invariant"></a>
<pre>Invariant =
    FeaturePrefix
    'inv' ( 'true' | isNegated ?= 'false' )?
    FeatureDeclaration ValuePart?
    FunctionBody
</pre>
<h4><a id="c8.2.5.8"></a>// Clause 8.2.5.8 Expressions Concrete Syntax</h4>
<h5><a id="c8.2.5.8.1"></a>// Clause 8.2.5.8.1 Operator Expressions</h5>
<a id="OwnedExpressionReferenceMember"></a>
<pre>OwnedExpressionReferenceMember : FeatureMembership =
    ownedRelationship += OwnedExpressionReference
</pre>
<a id="OwnedExpressionReference"></a>
<pre>OwnedExpressionReference : FeatureReferenceExpression =
    ownedRelationship += OwnedExpressionMember
</pre>
<a id="OwnedExpressionMember"></a>
<pre>OwnedExpressionMember : FeatureMembership =
    ownedFeatureMember = OwnedExpression
</pre>
<a id="OwnedExpression"></a>
<pre>OwnedExpression : Expression =
      ConditionalExpression
    | ConditionalBinaryOperatorExpression
    | BinaryOperatorExpression
    | UnaryOperatorExpression
    | ClassificationExpression
    | MetaclassificationExpression
    | ExtentExpression
    | PrimaryExpression
</pre>
<a id="ConditionalExpression"></a>
<pre>ConditionalExpression : OperatorExpression =
    operator = 'if'
    ownedRelationship += ArgumentMember '?'
    ownedRelationship += ArgumentExpressionMember 'else'
    ownedRelationship += ArgumentExpressionMember
    ownedRelationship += EmptyResultMember
</pre>
<a id="ConditionalBinaryOperatorExpression"></a>
<pre>ConditionalBinaryOperatorExpression : OperatorExpression =
    ownedRelationship += ArgumentMember
    operator = ConditionalBinaryOperator
    ownedRelationship += ArgumentExpressionMember
    ownedRelationship += EmptyResultMember
</pre>
<a id="ConditionalBinaryOperator"></a>
<pre>ConditionalBinaryOperator =
    '??' | 'or' | 'and' | 'implies'
</pre>
<a id="BinaryOperatorExpression"></a>
<pre>BinaryOperatorExpression : OperatorExpression =
    ownedRelationship += ArgumentMember
    operator = BinaryOperator
    ownedRelationship += ArgumentMember
    ownedRelationship += EmptyResultMember
</pre>
<a id="BinaryOperator"></a>
<pre>BinaryOperator =
      '|'  | '&'  | 'xor' | '..'
    | '==' | '!=' | '===' | '!=='
    | '<'  | '>'  | '<='  | '>='
    | '+'  | '-'  | '*'   | '/'
    | '%'  | '^'  | '**'
</pre>
<a id="UnaryOperatorExpression"></a>
<pre>UnaryOperatorExpression : OperatorExpression =
    operator = UnaryOperator
    ownedRelationship += ArgumentMember
    ownedRelationship += EmptyResultMember
</pre>
<a id="UnaryOperator"></a>
<pre>UnaryOperator =
    '+' | '-' | '~' | 'not'
</pre>
<a id="ClassificationExpression"></a>
<pre>ClassificationExpression : OperatorExpression =
    ( ownedRelationship += ArgumentMember )?
    ( operator = ClassificationTestOperator
      ownedRelationship += TypeReferenceMember
    | operator = CastOperator
      ownedRelationship += TypeResultMember
    )
    ownedRelationship += EmptyResultMember
</pre>
<a id="ClassificationTestOperator"></a>
<pre>ClassificationTestOperator =
    'istype' | 'hastype' | '@'
</pre>
<a id="CastOperator"></a>
<pre>CastOperator =
    'as'
</pre>
<a id="MetaclassificationExpression"></a>
<pre>MetaclassificationExpression : OperatorExpression =
    ownedRelationship += MetadataArgumentMember
    ( operator = MetaClassificationTestOperator
      ownedRelationship += TypeReferenceMember
    | operator = MetaCastOperator
      ownedRelationship += TypeResultMember
    )
    ownedRelationship += EmptyResultMember
</pre>
<a id="ArgumentMember"></a>
<pre>ArgumentMember : ParameterMembership =
    ownedMemberParameter = Argument
</pre>
<a id="Argument"></a>
<pre>Argument : Feature =
    ownedRelationship += ArgumentValue
</pre>
<a id="ArgumentValue"></a>
<pre>ArgumentValue : FeatureValue =
    value = OwnedExpression
</pre>
<a id="ArgumentExpressionMember"></a>
<pre>ArgumentExpressionMember : FeatureMembership =
    ownedRelatedElement += ArgumentExpression
</pre>
<a id="ArgumentExpression"></a>
<pre>ArgumentExpression : Feature =
    ownedRelationship += ArgumentExpressionValue
</pre>
<a id="ArgumentExpressionValue"></a>
<pre>ArgumentExpressionValue : FeatureValue =
    value = OwnedExpressionReference
</pre>
<a id="MetadataArgumentMember"></a>
<pre>MetadataArgumentMember : ParameterMembership =
    ownedRelatedElement += MetadataArgument
</pre>
<a id="MetadataArgument"></a>
<pre>MetadataArgument : Feature =
    ownedRelationship += MetadataValue
</pre>
<a id="MetadataValue"></a>
<pre>MetadataValue : FeatureValue =
    value = MetadataReference
</pre>
<a id="MetadataReference"></a>
<pre>MetadataReference : MetadataAccessExpression =
    ownedRelationship += ElementReferenceMember
</pre>
<a id="MetaclassificationTestOperator"></a>
<pre>MetaclassificationTestOperator =
    '@@'
</pre>
<a id="MetaCastOperator"></a>
<pre>MetaCastOperator =
    'meta'
</pre>
<a id="ExtentExpression"></a>
<pre>ExtentExpression : OperatorExpression =
    operator = 'all'
    ownedRelationship += TypeReferenceMember
</pre>
<a id="TypeReferenceMember"></a>
<pre>TypeReferenceMember : ParameterMembership =
    ownedMemberFeature = TypeReference
</pre>
<a id="TypeResultMember"></a>
<pre>TypeResultMember : ResultParameterMembership =
    ownedMemberFeature = TypeReference
</pre>
<a id="TypeReference"></a>
<pre>TypeReference : Feature =
    ownedRelationship += ReferenceTyping
</pre>
<a id="ReferenceTyping"></a>
<pre>ReferenceTyping : FeatureTyping =
    type = [QualifiedName]
</pre>
<a id="EmptyResultMember"></a>
<pre>EmptyResultMember : ReturnParameterMembership =
    ownedRelatedElement += EmptyFeature
</pre>
<a id="EmptyFeature"></a>
<pre>EmptyFeature : Feature =
    { }
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li><code>OperatorExpressions</code> provide a shorthand notation for <code>InvocationExpressions</code> that invoke a library <code>Function</code> represented as an <code>operator</code><em> symbol.</em> Table 5 shows the mapping from <code>operator</code> symbols to the <code>Functions</code> they represent from the Kernel Model Library (see Clause 9). An <code>OperatorExpression</code> contains subexpressions called its <em>operands</em> that generally correspond to the <code>argument</code> <code>Expressions</code> of the <code>OperatorExpression</code>, except in the case of <code>operators</code> representing <em>control </em><code>Functions</code>, in which case the evaluation of certain operands is as determined by the <code>Function</code> (see 8.4.4.9 for details).</li> <li>Though not directly expressed in the syntactic productions given above, in any <code>OperatorExpression</code> containing nested <code>OperatorExpressions</code>, the nested <code>OperatorExpressions</code> shall be implicitly grouped according to the <em>precedence</em> of the <code>operators</code> involved, as given in Table 6. <code>OperatorExpressions</code> with higher precedence <code>operators</code> shall be grouped more tightly than those with lower precedence <code>operators</code>. Further, all <code>BinaryOperators</code> other than exponentiation are left-associative (i.e, they group to the left), while the exponentiation operators (<code>^</code> and <code>**</code>) are right-associative (i.e., they group to the right).</li> <li>The unary <code>operator</code> symbol <code>~</code> maps to the library <code>Function</code> <em><code>DataFunctions::'~'</code></em>, as shown in Table 5. This abstract <code>Function</code> may be given a concrete definition in a domain-specific <code>Function</code> library, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this <code>operator</code> is used.</li><br>
// </ol>
</p>
<h5><a id="c8.2.5.8.2"></a>// Clause 8.2.5.8.2 Primary Expressions</h5>
<a id="PrimaryExpression"></a>
<pre>PrimaryExpression : Expression =
      FeatureChainExpression
    | NonFeatureChainPrimaryExpression
</pre>
<a id="PrimaryArgumentValue"></a>
<pre>PrimaryArgumentValue : FeatureValue =
    value = PrimaryExpression
</pre>
<a id="PrimaryArgument"></a>
<pre>PrimaryArgument : Feature =
    ownedRelationship += PrimaryArgumentValue
</pre>
<a id="PrimaryArgumentMember"></a>
<pre>PrimaryArgumentMember : ParameterMembership =
    ownedMemberParameter = PrimaryArgument
</pre>
<a id="NonFeatureChainPrimaryExpression"></a>
<pre>NonFeatureChainPrimaryExpression : Expression =
      BracketExpression
    | IndexExpression
    | SequenceExpression
    | SelectExpression
    | CollectExpression
    | FunctionOperationExpression
    | BaseExpression
</pre>
<a id="NonFeatureChainPrimaryArgumentValue"></a>
<pre>NonFeatureChainPrimaryArgumentValue : FeatureValue =
    value = NonFeatureChainPrimaryExpression
</pre>
<a id="NonFeatureChainPrimaryArgument"></a>
<pre>NonFeatureChainPrimaryArgument : Feature =
    ownedRelationship += NonFeatureChainPrimaryArgumentValue
</pre>
<a id="NonFeatureChainPrimaryArgumentMember"></a>
<pre>NonFeatureChainPrimaryArgumentMember : ParameterMembership =
    ownedMemberParameter = PrimaryArgument
</pre>
<a id="BracketExpression"></a>
<pre>BracketExpression : OperatorExpression =
    ownedRelationship += PrimaryArgumentMember
    operator = '['
    ownedRelationship += SequenceExpressionListMember ']'
</pre>
<a id="IndexExpression"></a>
<pre>IndexExpression =
    ownedRelationship += PrimaryArgumentMember '#'
    '(' ownedRelationship += SequenceExpressionListMember ')'
</pre>
<a id="SequenceExpression"></a>
<pre>SequenceExpression : Expression =
    '(' SequenceExpressionList ')'
</pre>
<a id="SequenceExpressionList"></a>
<pre>SequenceExpressionList : Expression =
    OwnedExpression ','? | SequenceOperatorExpression
</pre>
<a id="SequenceOperatorExpression"></a>
<pre>SequenceOperatorExpression : OperatorExpression =
    ownedRelationship += OwnedExpressionMember
    operator = ','
    ownedRelationship += SequenceExpressionListMember
</pre>
<a id="SequenceExpressionListMember"></a>
<pre>SequenceExpressionListMember : FeatureMembership =
    ownedMemberFeature = SequenceExpressionList
</pre>
<a id="FeatureChainExpression"></a>
<pre>FeatureChainExpression =
    ownedRelationship += NonFeatureChainPrimaryArgumentMember '.'
    ownedRelationship += FeatureChainMember
</pre>
<a id="CollectExpression"></a>
<pre>CollectExpression =
    ownedRelationship += PrimaryArgumentMember '.'
    ownedRelationship += BodyArgumentMember
</pre>
<a id="SelectExpression"></a>
<pre>SelectExpression =
    ownedRelationship += PrimaryArgumentMember '.?'
    ownedRelationship += BodyArgumentMember
</pre>
<a id="FunctionOperationExpression"></a>
<pre>FunctionOperationExpression : InvocationExpression =
    ownedRelationship += PrimaryArgumentMember '->'
    ownedRelationship += InvocationTypeMember
    ( ownedRelationship += BodyArgumentMember
    | ownedRelationship += FunctionReferenceArgumentMember
    | ArgumentList )
    ownedRelationship += EmptyResultMember
</pre>
<a id="BodyArgumentMember"></a>
<pre>BodyArgumentMember : ParameterMembership =
    ownedMemberParameter = BodyArgument
</pre>
<a id="BodyArgument"></a>
<pre>BodyArgument : Feature =
    ownedRelationship += BodyArgumentValue
</pre>
<a id="BodyArgumentValue"></a>
<pre>BodyArgumentValue : FeatureValue =
    value = BodyExpression
</pre>
<a id="FunctionReferenceArgumentMember"></a>
<pre>FunctionReferenceArgumentMember : ParameterMembership =
    ownedMemberParameter = FunctionReferenceArgument
</pre>
<a id="FunctionReferenceArgument"></a>
<pre>FunctionReferenceArgument : Feature =
    ownedRelationship += FunctionReferenceArgumentValue
</pre>
<a id="FunctionReferenceArgumentValue"></a>
<pre>FunctionReferenceArgumentValue : FeatureValue =
    value = FunctionReferenceExpression
</pre>
<a id="FunctionReferenceExpression"></a>
<pre>FunctionReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FunctionReferenceMember
</pre>
<a id="FunctionReferenceMember"></a>
<pre>FunctionReferenceMember : FeatureMembership =
    ownedMemberFeature = FunctionReference
</pre>
<a id="FunctionReference"></a>
<pre>FunctionReference : Expression =
    ownedRelationship += ReferenceTyping
</pre>
<a id="FeatureChainMember"></a>
<pre>FeatureChainMember : Membership =
      FeatureReferenceMember
    | OwnedFeatureChainMember
</pre>
<a id="OwnedFeatureChainMember"></a>
<pre>OwnedFeatureChainMember : OwningMembership =
    ownedMemberElement = FeatureChain
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>Primary expressions provide additional shorthand notations for certain kinds of <code>InvocationExpressions</code>. For those cases in which the <code>InvocationExpression</code> is an <code>OperatorExpression</code>, its <code>operator</code> shall be resolved to the appropriate library function as given in Table 7. Note also that, for a <code>CollectionExpression</code> or <code>SelectExpression</code>, the abstract syntax constrains the <code>operator</code> to be <em><code>collect</code></em> and <em><code>select</code></em>, respectively, separately from the <code>.</code> and <code>.?</code> symbols used in their concrete syntax notation (see 8.3.4.8.2 and 8.3.4.8.18).</li> <li>The grammar allows a bracket syntax <code>[</code>...<code>]</code>that parses to an invocation of the library <code>Function</code> <code><em>Base</em></code><em><code>Functions::'['</code>,</em> as shown in Table 7. This notation is available for use with domain-specific library models that given a concrete definition to the abstract base <code>'['</code> <code>Function</code>, but no default definition is provided in the Kernel Functions Library. If no domain-specific definition is available, a tool should give a warning if this operator is used.</li><br>
// </ol>
</p>
<h5><a id="c8.2.5.8.3"></a>// Clause 8.2.5.8.3 Base Expressions</h5>
<a id="BaseExpression"></a>
<pre>BaseExpression : Expression =
      NullExpression
    | LiteralExpression
    | FeatureReferenceExpression
    | MetadataAccessExpression
    | InvocationExpression
    | ConstructorExpression
    | BodyExpression
</pre>
<a id="NullExpression"></a>
<pre>NullExpression : NullExpression =
    'null' | '(' ')'
</pre>
<a id="FeatureReferenceExpression"></a>
<pre>FeatureReferenceExpression : FeatureReferenceExpression =
    ownedRelationship += FeatureReferenceMember
    ownedRelationship += EmptyResultMember
</pre>
<a id="FeatureReferenceMember"></a>
<pre>FeatureReferenceMember : Membership =
    memberElement = FeatureReference
</pre>
<a id="FeatureReference"></a>
<pre>FeatureReference : Feature =
    [QualifiedName]
</pre>
<a id="MetadataAccessExpression"></a>
<pre>MetadataAccessExpression =
    ownedRelationship += ElementReferenceMember '.' 'metadata'
</pre>
<a id="ElementReferenceMember"></a>
<pre>ElementReferenceMember : Membership =
    memberElement = [QualifiedName]
</pre>
<a id="InvocationExpression"></a>
<pre>InvocationExpression : InvocationExpression =
    ownedRelationship += InstantiatedTypeMember
    ArgumentList
    ownedRelationship += EmptyResultMember
</pre>
<a id="ConstructorExpression"></a>
<pre>ConstructorExpression =
    'new' ownedRelationship += InstantiatedTypeMember
    ownedRelationship += ConstructorResultMember
</pre>
<a id="ConstructorResultMember"></a>
<pre>ConstructorResultMember : ReturnParameterMembership =
    ownedRelatedElement += ConstructorResult
</pre>
<a id="ConstructorResult"></a>
<pre>ConstructorResult : Feature =
    ArgumentList
</pre>
<a id="InstantiatedTypeMember"></a>
<pre>InstantiatedTypeMember : Membership =
      memberElement = InstantiatedTypeReference
    | OwnedFeatureChainMember
</pre>
<a id="InstantiatedTypeReference"></a>
<pre>InstantiatedTypeReference : Type =
    [QualifiedName]
</pre>
<a id="ArgumentList"></a>
<pre>ArgumentList : Feature =
    '(' ( PositionalArgumentList | NamedArgumentList )? ')'
</pre>
<a id="PositionalArgumentList"></a>
<pre>PositionalArgumentList : Feature =
    e.ownedRelationship += ArgumentMember
    ( ',' e.ownedRelationship += ArgumentMember )*
</pre>
<a id="NamedArgumentList"></a>
<pre>NamedArgumentList : Feature =
    ownedRelationship += NamedArgumentMember
    ( ',' ownedRelationship += NamedArgumentMember )*
</pre>
<a id="NamedArgumentMember"></a>
<pre>NamedArgumentMember : FeatureMembership =
    ownedMemberFeature = NamedArgument
</pre>
<a id="NamedArgument"></a>
<pre>NamedArgument : Feature =
    ownedRelationship += ParameterRedefinition '='
    ownedRelationship += ArgumentValue
</pre>
<a id="ParameterRedefinition"></a>
<pre>ParameterRedefinition : Redefinition =
    redefinedFeature = [QualifiedName]
</pre>
<a id="BodyExpression"></a>
<pre>BodyExpression : FeatureReferenceExpression =
    ownedRelationship += ExpressionBodyMember
</pre>
<a id="ExpressionBodyMember"></a>
<pre>ExpressionBodyMember : FeatureMembership =
    ownedMemberFeature = ExpressionBody
</pre>
<a id="ExpressionBody"></a>
<pre>ExpressionBody : Expression =
    '{' FunctionBodyPart '}'
</pre>
<h5><a id="c8.2.5.8.4"></a>// Clause 8.2.5.8.4 Literal Expressions</h5>
<a id="LiteralExpression"></a>
<pre>LiteralExpression =
      LiteralBoolean
    | LiteralString
    | LiteralInteger
    | LiteralReal
    | LiteralInfinity
</pre>
<a id="LiteralBoolean"></a>
<pre>LiteralBoolean =
    value = BooleanValue
</pre>
<a id="BooleanValue"></a>
<pre>BooleanValue : Boolean =
    'true' | 'false'
</pre>
<a id="LiteralString"></a>
<pre>LiteralString =
    value = STRING_VALUE
</pre>
<a id="LiteralInteger"></a>
<pre>LiteralInteger =
    value = DECIMAL_VALUE
</pre>
<a id="LiteralReal"></a>
<pre>LiteralReal =
    value = RealValue
</pre>
<a id="RealValue"></a>
<pre>RealValue : Real =
      DECIMAL_VALUE? '.' ( DECIMAL_VALUE | EXPONENTIAL_VALUE )
    | EXPONENTIAL_VALUE
</pre>
<a id="LiteralInfinity"></a>
<pre>LiteralInfinity =
    '*'
</pre>
<h4><a id="c8.2.5.9"></a>// Clause 8.2.5.9 Interactions Concrete Syntax</h4>
<h5><a id="c8.2.5.9.1"></a>// Clause 8.2.5.9.1 Interactions</h5>
<a id="Interaction"></a>
<pre>Interaction =
    TypePrefix 'interaction'
    ClassifierDeclaration TypeBody
</pre>
<h5><a id="c8.2.5.9.2"></a>// Clause 8.2.5.9.2 Flows</h5>
<a id="Flow"></a>
<pre>Flow =
    FeaturePrefix 'flow'
    ItemFlowDeclaration TypeBody
</pre>
<a id="SuccessionFlow"></a>
<pre>SuccessionFlow =
    FeaturePrefix 'succession' 'flow'
    ItemFlowDeclaration TypeBody
</pre>
<a id="FlowDeclaration"></a>
<pre>FlowDeclaration : Flow =
      FeatureDeclaration ValuePart?
      ( 'of' ownedRelationship += PayloadFeatureMember )?
      ( 'from' ownedRelationship += FlowEndMember
        'to' ownedRelationship += FlowEndMember )?
    | ( isSufficient ?= 'all' )?
      ownedRelationship += FlowEndMember 'to'
      ownedRelationship += FlowEndMember
</pre>
<a id="PayloadFeatureMember"></a>
<pre>PayloadFeatureMember : FeatureMembership =
    ownedRelatedElement = PayloadFeature
</pre>
<a id="PayloadFeature"></a>
<pre>PayloadFeature =
      Identification PayloadFeatureSpecializationPart ValuePart?
    | Identification ValuePart
    | ownedRelationship += OwnedFeatureTyping
      ( ownedRelationship += OwnedMultiplicity )?
    | ownedRelationship += OwnedMultiplicity
      ( ownedRelationship += OwnedFeatureTyping )?
</pre>
<a id="PayloadFeatureSpecializationPart"></a>
<pre>PayloadFeatureSpecializationPart : Feature =
      FeatureSpecialization+ MultiplicityPart?
      FeatureSpecialization*
    | MultiplicityPart FeatureSpecialization+
</pre>
<a id="FlowEndMember"></a>
<pre>FlowEndMember : EndFeatureMembership =
    ownedRelatedElement += FlowEnd
</pre>
<a id="FlowEnd"></a>
<pre>FlowEnd =
    ( ownedRelationship += OwnedReferenceSubsetting '.' )?
    ownedRelationship += FlowFeatureMember
</pre>
<a id="FlowFeatureMember"></a>
<pre>FlowFeatureMember : FeatureMembership =
    ownedRelatedElement += FlowFeature
</pre>
<a id="FlowFeature"></a>
<pre>FlowFeature : Feature =
    ownedRelationship += FlowFeatureRedefinition
</pre>
<p>// (See Note 1)
</p>
<a id="FlowFeatureRedefinition"></a>
<pre>FlowFeatureRedefinition : Redefinition =
    redefinedFeature = [QualifiedName]
</pre>
<p>// <p>// <strong>Notes</strong></p><br>
// <ol> <li>To ensure that an <code>FlowFeature</code> passes the <code>validateRedefinitionDirectionConformance</code> constraint (see 8.3.3.3.8), its <code>direction</code> must be set to the direction of its <code>redefinedFeature</code>, relative to its owning <code>FlowEnd</code>, that is, the result of the following OCL expression:<br>
// <br>
// 	<code>owningType.directionOf(ownedRedefinition-&gt;at(1).redefinedFeature)</code> </li><br>
// </ol>
</p>
<h4><a id="c8.2.5.10"></a>// Clause 8.2.5.10 Feature Values Concrete Syntax</h4>
<a id="ValuePart"></a>
<pre>ValuePart : Feature =
    ownedRelationship += FeatureValue
</pre>
<a id="FeatureValue"></a>
<pre>FeatureValue =
    ( '='
    | isInitial ?= ':='
    | isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?
    )
    ownedRelatedElement += OwnedExpression
</pre>
<h4><a id="c8.2.5.11"></a>// Clause 8.2.5.11 Multiplicities Concrete Syntax</h4>
<a id="Multiplicity"></a>
<pre>Multiplicity =
    MultiplicitySubset | MultiplicityRange
</pre>
<a id="MultiplicitySubset"></a>
<pre>MultiplicitySubset : Multiplicity =
    'multiplicity' Identification Subsets
    TypeBody
</pre>
<a id="MultiplicityRange"></a>
<pre>MultiplicityRange =
    'multiplicity' Identification MultiplicityBounds
    TypeBody
</pre>
<a id="OwnedMultiplicity"></a>
<pre>OwnedMultiplicity : OwningMembership =
    ownedRelatedElement += OwnedMultiplicityRange
</pre>
<a id="OwnedMultiplicityRange"></a>
<pre>OwnedMultiplicityRange : MultiplicityRange =
    MultiplicityBounds
</pre>
<a id="MultiplicityBounds"></a>
<pre>MultiplicityBounds : MultiplicityRange =
    '[' ( ownedRelationship += MultiplicityExpressionMember '..' )?
          ownedRelationship += MultiplicityExpressionMember ']'
</pre>
<a id="MultiplicityExpressionMember"></a>
<pre>MultiplicityExpressionMember : OwningMembership =
    ownedRelatedElement += ( LiteralExpression | FeatureReferenceExpression )
</pre>
<h4><a id="c8.2.5.12"></a>// Clause 8.2.5.12 Metadata Concrete Syntax</h4>
<a id="Metaclass"></a>
<pre>Metaclass =
    TypePrefix 'metaclass'
    ClassifierDeclaration TypeBody
</pre>
<a id="PrefixMetadataAnnotation"></a>
<pre>PrefixMetadataAnnotation : Annotation =
    '#' ownedRelatedElement += PrefixMetadataFeature
</pre>
<a id="PrefixMetadataMember"></a>
<pre>PrefixMetadataMember : OwningMembership =
    '#' ownedRelatedElement += PrefixMetadataFeature
</pre>
<a id="PrefixMetadataFeature"></a>
<pre>PrefixMetadataFeature : MetadataFeature =
    ownedRelationship += OwnedFeatureTyping
</pre>
<a id="MetadataFeature"></a>
<pre>MetadataFeature =
    ( ownedRelationship += PrefixMetadataMember )*
    ( '@' | 'metadata' )
    MetadataFeatureDeclaration
    ( 'about' ownedRelationship += Annotation
      ( ',' ownedRelationship += Annotation )*
    )?
    MetadataBody
</pre>
<a id="MetadataFeatureDeclaration"></a>
<pre>MetadataFeatureDeclaration : MetadataFeature =
    ( Identification ( ':' | 'typed' 'by' ) )?
    ownedRelationship += OwnedFeatureTyping
</pre>
<a id="MetadataBody"></a>
<pre>MetadataBody : Feature =
    ';' | '{' ( ownedRelationship += MetadataBodyElement )* '}'
</pre>
<a id="MetadataBodyElement"></a>
<pre>MetadataBodyElement : Membership =
      NonFeatureMember
    | MetadataBodyFeatureMember
    | AliasMember
    | Import
</pre>
<a id="MetadataBodyFeatureMember"></a>
<pre>MetadataBodyFeatureMember : FeatureMembership =
    ownedMemberFeature = MetadataBodyFeature
</pre>
<a id="MetadataBodyFeature"></a>
<pre>MetadataBodyFeature : Feature =
    'feature'? ( ':>>' | 'redefines')? ownedRelationship += OwnedRedefinition
    FeatureSpecializationPart? ValuePart?
    MetadataBody
</pre>
<h4><a id="c8.2.5.13"></a>// Clause 8.2.5.13 Packages Concrete Syntax</h4>
<a id="Package"></a>
<pre>Package =
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody
</pre>
<a id="LibraryPackage"></a>
<pre>LibraryPackage =
    ( isStandard ?= 'standard' ) 'library'
    ( ownedRelationship += PrefixMetadataMember )*
    PackageDeclaration PackageBody
</pre>
<a id="PackageDeclaration"></a>
<pre>PackageDeclaration : Package =
    'package' Identification
</pre>
<a id="PackageBody"></a>
<pre>PackageBody : Package =
      ';'
    | '{' ( NamespaceBodyElement
          | ownedRelationship += ElementFilterMember
          )*
      '}'
</pre>
<a id="ElementFilterMember"></a>
<pre>ElementFilterMember : ElementFilterMembership =
    MemberPrefix
    'filter' condition = OwnedExpression ';'
</pre>
<p>// End of BNF<br>

</p>
</body>
</html>
